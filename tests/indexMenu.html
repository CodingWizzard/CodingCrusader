<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Coding Crusader's</title>

    <script src="../vendors/babylon.js"></script>
    <script src="../vendors/havokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="../vendors/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>

    <script src="../classes/text3D.js"></script>
    <script src="../classes/sun.js"></script>
    <script src="../classes/registerBeforeRender.js"></script>


    <script src="../moduls/pluginBase.js"></script>
    <script src="../moduls/hemisphereStandard.js"></script>
    <script src="../moduls/shadow.js"></script>
    <script src="../moduls/helper.js"></script>


    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas"></canvas>

    <script>
        let canvas = document.getElementById("renderCanvas");


        // let levels = [1, 2, 3, 4, 5];
        let levelsMax = 5;
        let names = ["Charlie Chaplin", "Keanu Reeves", "Marilyn Monroe", "Martin Luther King"];

        function generateData(numEntries) {
            let data = [];

            // for (let i = 0; i < numEntries; i++) {
            //     let level = levels[Math.floor(Math.random() * levels.length)];
            //     let name = names[Math.floor(Math.random() * names.length)];
            //     let timestamp = new Date();
            //     let randomDays = Math.floor(Math.random() * 365) + 1;
            //     timestamp.setDate(timestamp.getDate() + randomDays);
            //     data.push({ id: i + 1, level: level, name: name, timestamp: timestamp, mesh: undefined });
            // }

            let timestamp = new Date();
            data.push({ id: 1, level: 1, name: "Charlie Chaplin", timestamp: timestamp, mesh: undefined });
            data.push({ id: 2, level: 1, name: "Keanu Reeves", timestamp: timestamp, mesh: undefined });
            data.push({ id: 3, level: 1, name: "Marilyn Monroe", timestamp: timestamp, mesh: undefined });
            data.push({ id: 4, level: 1, name: "Martin Luther King", timestamp: timestamp, mesh: undefined });


            return data;
        }


        let data = generateData(100); // 0);

        data.sort(function (a, b) {
            if (a.level === b.level) {
                return b.timestamp - a.timestamp;
            }
            return a.level - b.level;
        });


        let createScene = async function () {
            let scene = new BABYLON.Scene(engine);
            scene.clearColor = BABYLON.Color3.Gray();

            let camera = new BABYLON.ArcRotateCamera("",
                BABYLON.Tools.ToRadians(-90),
                BABYLON.Tools.ToRadians(80),
                3,
                new BABYLON.Vector3(0, 0, 0),
                scene);
            // camera.lowerBetaLimit = BABYLON.Tools.ToRadians(80);
            // camera.upperBetaLimit = BABYLON.Tools.ToRadians(80);
            camera.wheelPrecision = 100;
            camera.attachControl(canvas, true);

            let light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.position = new BABYLON.Vector3(20, 150, 70);
            light.intensity = 0.7;



            let skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("https://www.babylonjs-playground.com/textures/TropicalSunnyDay", scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.disableLighting = true;

            let skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
            skybox.material = skyboxMaterial;
            skybox.isPickable = false;


            let createText = (text, width, color, callback) => {
                let dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", { width: 256 * width, height: 64 }, scene, true);
                // dynamicTexture.hasAlpha = true;
                // let context = dynamicTexture.getContext();

                dynamicTexture.drawText(text, 10, 33, "24px Arial", color, "gray", true);

                let materialLabel = new BABYLON.StandardMaterial("myMaterial", scene);
                materialLabel.diffuseTexture = dynamicTexture;
                materialLabel.backFaceCulling = false;

                let label = BABYLON.MeshBuilder.CreatePlane("", { width: width, height: 0.2 }, scene);
                label.position.z = -0.1;
                label.position.y = -1;
                label.material = materialLabel;

                return label;
            }

            let hideCards = () => {
                data.forEach(function (entry, index) {
                    if (entry.mesh !== undefined)
                        entry.mesh.isVisible = false;
                })
            }

            let renderCards = () => {

                hideCards();

                for (let i = 1; i <= levelsMax; i++) {
                    let radius = 1 + i * 2;

                    const points1 = BABYLON.GreasedLineTools.GetCircleLinePoints(radius, 100)
                    const line1 = BABYLON.CreateGreasedLine(
                        'line-1',
                        {
                            points: points1
                        },
                        {
                            width: 0.1
                        },
                        scene
                    )
                    line1.rotate(BABYLON.Axis.X, Math.PI * 0.5);
                    line1.position.y = -1;
                }


                let p0 = new BABYLON.Vector3.Zero();
                let phi = 1.6;
                let max = 7;
                let levelCounts = {};
                data.forEach(function (entry, index) {

                    if (!(entry.level in levelCounts)) {
                        levelCounts[entry.level] = 0;
                    }
                    if (levelCounts[entry.level] < max) {

                        if (entry.level > levelsMax)
                            return;

                        let radius = 1 + entry.level * 2;

                        if (entry.mesh === undefined) {
                            let matPlane = new BABYLON.StandardMaterial("mat", scene);
                            matPlane.diffuseTexture = new BABYLON.Texture("../media/people/" + entry.name + ".jpg", scene);;
                            matPlane.backFaceCulling = false;

                            // let i = 4 / 3 * Math.PI * levelCounts[entry.level] / max;
                            let i = 2 * Math.PI * levelCounts[entry.level] / max;
                            let plane = BABYLON.MeshBuilder.CreatePlane("", { width: 1, height: 1 * phi }, scene);
                            plane.material = matPlane;
                            plane.position.set(
                                radius * Math.sin(i * 2 * Math.PI / max),
                                0,
                                radius * Math.cos(i * 2 * Math.PI / max));
                            plane.lookAt(p0);
                            plane.rotate(new BABYLON.Vector3(0, 1, 0), Math.PI * 1, BABYLON.Space.LOCAL);
                            plane.custEntry = entry;

                            plane.label = createText(entry.name, 1, "white");
                            plane.label.parent = plane;
                            plane.label.isVisible = false;

                            entry.mesh = plane;
                        }
                        else {
                            let i = 4 / 3 * Math.PI * levelCounts[entry.level] / max;
                            let radius = 1 + entry.level * 2;
                            entry.mesh.position.set(
                                radius * Math.sin(i * 2 * Math.PI / max),
                                0,
                                radius * Math.cos(i * 2 * Math.PI / max));
                            entry.mesh.lookAt(p0);
                            entry.mesh.rotate(new BABYLON.Vector3(0, 1, 0), Math.PI * 1, BABYLON.Space.LOCAL);
                            entry.mesh.isVisible = true;
                        }

                        // console.log(entry.id + "\t" + entry.level + "\t" + entry.name + "\t" + entry.timestamp.toISOString());

                        levelCounts[entry.level]++;
                    }

                });
            }

            renderCards();


            let pickedMesh = undefined;
            scene.onPointerDown = function (evt, pickResult) {
                // evt.button: 0 = left, 1 = middle, 2 = right
                pickedMesh = pickResult.pickedMesh;
                if (pickedMesh) {
                    if (pickedMesh.label !== undefined) {
                        pickedMesh.label.isVisible = true;
                    }
                }
            };


            scene.onKeyboardObservable.add((kbInfo) => {

                switch (kbInfo.type) {
                    case BABYLON.KeyboardEventTypes.KEYDOWN:
                        switch (kbInfo.event.key) {
                            case "y":
                                if (pickedMesh === undefined)
                                    return;
                                if (pickedMesh.custEntry === undefined)
                                    return;

                                pickedMesh.custEntry.timestamp = new Date();
                                pickedMesh.custEntry.level++;
                                pickedMesh.label.isVisible = false;
                                pickedMesh.isVisible = false;
                                break;
                            case "n":
                                if (pickedMesh === undefined)
                                    return;
                                if (pickedMesh.custEntry === undefined)
                                    return;

                                pickedMesh.custEntry.timestamp = new Date();
                                pickedMesh.custEntry.level = 1;

                                pickedMesh.label.isVisible = false;
                                pickedMesh.isVisible = false;
                                break;
                        }

                        renderCards();
                        break;
                }

                pickedMesh = undefined;
            });

            return scene;
        };


        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false });

        createScene().then((scene) => {
            engine.runRenderLoop(function () {
                if (scene) {
                    scene.render();
                }
            });
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>

</body>

</html>