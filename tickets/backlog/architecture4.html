<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>architect</title>



    <!-- DatGUI -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script> -->

    <!-- <script src="/libs/jszip.min.js"></script>
       <script src="/libs/fileSaver.js"></script> -->

    <!-- jQuery -->
    <!-- <script src="https://code.jquery.com/jquery.js"></script> -->
    <!-- <script src="https://rawcdn.githack.com/jeromeetienne/jquery-qrcode/master/jquery.qrcode.min.js"></script> -->


    <!-- 
    <script src="https://preview.babylonjs.com/recast.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    
    <script src="https://preview.babylonjs.com/earcut.min.js"></script> -->

    <!-- Babylon.js -->
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <!-- <script src="https://preview.babylonjs.com/ammo.js"></script> -->
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>

    <!-- <script src="./vendor/require.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.5/dist/tweakpane.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>



    <!-- <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <script src="https://preview.babylonjs.com/nodeEditor/babylon.nodeEditor.js"></script>
    <script src="https://preview.babylonjs.com/guiEditor/babylon.guiEditor.js"></script> -->

    <!-- Extensions -->
    <!-- <script
        src="https://rawcdn.githack.com/BabylonJS/Extensions/f43ab677b4bca0a6ab77132d3f785be300382760/ClonerSystem/src/babylonx.cloner.js">
        </script>
    <script
        src="https://rawcdn.githack.com/BabylonJS/Extensions/785013ec55b210d12263c91f3f0a2ae70cf0bc8a/CompoundShader/src/babylonx.CompoundShader.js">
        </script> -->

    <!-- <script src="https://console3.babylonjs.xyz/console3-playground.js"></script> -->

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #fps {
            position: absolute;
            background-color: black;
            /* border: 2px solid red; */
            text-align: center;
            font-size: 16px;
            color: white;
            top: 15px;
            right: 10px;
            width: 60px;
            height: 20px;
        }
    </style>

</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <div id="fps">0</div>

    <!-- https://stackoverflow.com/questions/19636423/embed-js-console-within-website
    <div>
        <form id="console-form">
            <input type="text" id="command">
            <input type="submit" value="Run Command">
            <button id="clear" type="button">Clear</button>
        </form>
        <hr>
        <pre id="console"></pre>
    </div> -->


    <script>
        let canvas = document.getElementById("renderCanvas");
        let divFps = document.getElementById("fps")

        let desiredFps = 3;
        let interval = 1000 / (10 * desiredFps);
        let manipulator = null;
        let shadowGenerator = null;

        let attachDragBehavior = (mesh) => {
            // let pointerDragBehavior = new BABYLON.PointerDragBehavior({});
            // pointerDragBehavior.useObjectOrientationForDragging = false;
            // mesh.addBehavior(pointerDragBehavior);
        }


        // https://github.com/ShaifArfan/30days30submits/tree/master/day-08


        // class PhotoGallery {
        //     constructor() {
        //         this.API_KEY = '563492ad6f917000010000016320ba7f62f24b3293ce88aeb8996e59';
        //         // this.galleryDIv = document.querySelector('.gallery');
        //         // this.searchForm = document.querySelector('.header form');
        //         // this.loadMore = document.querySelector('.load-more');
        //         // this.logo = document.querySelector('.logo')
        //         this.pageIndex = 1;
        //         this.searchValueGlobal = '';
        //         this.eventHandle();
        //     }
        //     eventHandle() {
        //         // document.addEventListener('DOMContentLoaded', () => {
        //         //     this.getImg(1);
        //         // });
        //         // this.searchForm.addEventListener('submit', (e) => {
        //         //     this.pageIndex = 1;
        //         //     this.getSearchedImages(e);
        //         // });
        //         // this.loadMore.addEventListener('click', (e) => {
        //         //     this.loadMoreImages(e);
        //         // })
        //         // this.logo.addEventListener('click', () => {
        //         //     this.pageIndex = 1;
        //         //     this.galleryDIv.innerHTML = '';
        //         //     this.getImg(this.pageIndex);
        //         // })
        //     }

        //     async getOneImg(index) {
        //         // this.loadMore.setAttribute('data-img', 'curated');
        //         const baseURL = `https://api.pexels.com/v1/curated?page=${index}&per_page=1`;
        //         const data = await this.fetchImages(baseURL);
        //         // this.GenerateHTML(data.photos)
        //         console.log(data.photos[0].src.original)
        //         return data.photos[0].src.original
        //     }


        //     async getImg(index) {
        //         // this.loadMore.setAttribute('data-img', 'curated');
        //         const baseURL = `https://api.pexels.com/v1/curated?page=${index}&per_page=12`;
        //         const data = await this.fetchImages(baseURL);
        //         this.GenerateHTML(data.photos)
        //         console.log(data)
        //     }
        //     async fetchImages(baseURL) {
        //         const response = await fetch(baseURL, {
        //             method: 'GET',
        //             headers: {
        //                 Accept: 'application/json',
        //                 Authorization: this.API_KEY
        //             }
        //         });
        //         const data = await response.json();
        //         // console.log(data);
        //         return data;
        //     }
        //     GenerateHTML(photos) {
        //         photos.forEach(photo => {
        //             const item = document.createElement('div');
        //             item.classList.add('item');
        //             item.innerHTML = `
        //                 <a href='${photo.src.original}' target="_blank">
        //                     <img src="${photo.src.medium}">
        //                     <h3>${photo.photographer}</h3>
        //                 </a>
        //                 `;
        //             // this.galleryDIv.appendChild(item)
        //             console.log(item);
        //         })
        //     }
        //     async getSearchedImages(e) {
        //         this.loadMore.setAttribute('data-img', 'search');
        //         e.preventDefault();
        //         this.galleryDIv.innerHTML = '';
        //         const searchValue = e.target.querySelector('input').value;
        //         this.searchValueGlobal = searchValue;
        //         const baseURL = `https://api.pexels.com/v1/search?query=${searchValue}&page=1&per_page=12`
        //         const data = await this.fetchImages(baseURL);
        //         this.GenerateHTML(data.photos);
        //         e.target.reset();
        //     }
        //     async getMoreSearchedImages(index) {
        //         // console.log(searchValue)
        //         const baseURL = `https://api.pexels.com/v1/search?query=${this.searchValueGlobal}&page=${index}&per_page=12`
        //         const data = await this.fetchImages(baseURL);
        //         console.log(data)
        //         this.GenerateHTML(data.photos);
        //     }
        //     loadMoreImages(e) {
        //         let index = ++this.pageIndex;
        //         const loadMoreData = e.target.getAttribute('data-img');
        //         if (loadMoreData === 'curated') {
        //             // load next page for curated]
        //             this.getImg(index)
        //         } else {
        //             // load next page for search
        //             this.getMoreSearchedImages(index);
        //         }
        //     }
        // }

        // const gallery = new PhotoGallery;
        // // gallery.getOneImg(1);



        /***********Create and Draw Axes**************************************/
        const showAxis = function (scene, size) {
            const makeTextPlane = function (text, color, size) {
                const dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
                dynamicTexture.hasAlpha = true;
                dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color, "transparent", true);
                const plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
                plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
                plane.material.backFaceCulling = false;
                plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
                plane.material.diffuseTexture = dynamicTexture;
                return plane;
            };

            const axisX = BABYLON.Mesh.CreateLines("axisX", [
                new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
                new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
            ], scene);
            axisX.color = new BABYLON.Color3(1, 0, 0);
            const xChar = makeTextPlane("X", "red", size / 10);
            xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);
            const axisY = BABYLON.Mesh.CreateLines("axisY", [
                new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),
                new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)
            ], scene);
            axisY.color = new BABYLON.Color3(0, 1, 0);
            const yChar = makeTextPlane("Y", "green", size / 10);
            yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
            const axisZ = BABYLON.Mesh.CreateLines("axisZ", [
                new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),
                new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)
            ], scene);
            axisZ.color = new BABYLON.Color3(0, 0, 1);
            const zChar = makeTextPlane("Z", "blue", size / 10);
            zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
        };

        // let material_crate = null;
        // let material_fur = null;
        // let material_ground = null;
        // let box_material = null;

        // let cells = [];
        let meshes = [];
        let x = 0;
        let y = 0;
        let z = 0;
        let m = 0;
        let size = 1;
        // let delta = 4;
        let max = 10;
        let cx = 0;
        let cy = 0;
        let cz = 0;

        let rx = 0;
        let ry = 0;
        let rz = 0;

        let sx = 1;
        let sy = 1;
        let sz = 1;

        const NL = 0;   // null, nothing
        const FW = 1;   // forward
        const BW = 2;   // backward
        const LT = 4;   // left
        const RT = 8;   // right
        const UP = 16;  // up
        const DW = 32;  // down
        const CT = 64;  // center
        const AL = FW + BW + LT + RT + UP + DW;

        let ghost = null;
        let camera = null;

        // let box = (x, y, z, size) => {
        //     let box = BABYLON.MeshBuilder.CreateBox("", { size: size }, scene);
        //     box.position.set(x, y, z)
        //     return box;
        // }

        // https://www.w3schools.com/js/js_bitwise.asp

        // let set = (x, y, z, mask) => {
        //     cells[x][y][z].faces = mask
        // }

        // let and = (x, y, z, mask) => {
        //     cells[x][y][z].faces &= mask
        // }

        // let or = (x, y, z, mask) => {
        //     cells[x][y][z].faces |= mask
        // }

        // let xor = (x, y, z, mask) => {
        //     cells[x][y][z].faces ^= mask
        // }

        // let not = (x, y, z, mask) => {
        //     cells[x][y][z].faces = ~mask
        // }


        let xmin = undefined;
        let xmax = undefined;
        let dx = undefined;
        let ymin = undefined;
        let ymax = undefined;
        let dy = undefined;
        let zmin = undefined;
        let zmax = undefined;
        let dz = undefined;

        let init = () => {
            cx = 0;
            cy = 0;
            cz = 0;

            rx = 0;
            ry = 0;
            rz = 0;

            sx = 1;
            sy = 1;
            sz = 1;

            xmin = 0;
            xmax = max - 1;
            dx = 1;
            ymin = 0;
            ymax = max - 1;
            dy = 1;
            zmin = 0;
            zmax = max - 1;
            dz = 1;
            return "ok";
        }

        let clear = () => {
            init();
            pivot(0, 0, 0);
            loop(NL, null);
            return "ok"
        }

        let range = (_xmin, _xmax, _dx, _ymin, _ymax, _dy, _zmin, _zmax, _dz) => {
            xmin = _xmin
            xmax = _xmax
            dx = _dx
            ymin = _ymin
            ymax = _ymax
            dy = _dy
            zmin = _zmin
            zmax = _zmax
            dz = _dz

            return "ok";
        }

        let info = () => {
            console.log("cx = ", cx);
            console.log("cy = ", cy);
            console.log("cz = ", cz);
            console.log("xmin = ", xmin);
            console.log("xmax = ", xmax);
            console.log("dx = ", dx);
            console.log("ymin = ", ymin);
            console.log("ymax = ", ymax);
            console.log("dy = ", dy);
            console.log("zmin = ", zmin);
            console.log("zmax = ", zmax);
            console.log("dz = ", dz);
            return "ok";
        }

        let loop = (faces, material) => {
            if (dx == 0) dx = 1;
            if (dy == 0) dy = 1;
            if (dz == 0) dz = 1;
            for (x = xmin; x <= xmax; x += dx) {
                for (y = ymin; y <= ymax; y += dy) {
                    for (z = zmin; z <= zmax; z += dz) {
                        // cells[x][y][z].material = material;
                        // fn(x, y, z, mask);

                        box({ x: x, y: y, z: z }, faces, material)
                    }
                }
            }
            // view();
            return "ok";
        }

        // let view = () => {

        //     meshes.forEach((mesh) => { mesh.dispose(); })
        //     meshes = [];

        //     for (x = 0; x < max; x += 1) {
        //         for (y = 0; y < max; y += 1) {
        //             for (z = 0; z < max; z += 1) {
        //                 try {
        //                     box(cells[x][y][z])
        //                 } catch (e) {
        //                 }
        //             }
        //         }
        //     }

        //     return "ok";
        // }

        let pivot = (x, y, z) => {
            cx = x;
            cy = y;
            cz = z;
            // ghost.position.set(size * cx + 0.5 * size, size * cy + 0.5 * size, size * cz + 0.5 * size);
            // ghost.position.set(size * cx + 0.5 * size, size * cy + 0.5 * size, size * cz + 0.5 * size);
            ghost.position.set(size * cx, size * cy, size * cz);

            return "ok"
        }

        let rotate = (x, y, z) => {
            rx = x;
            ry = y;
            rz = z;
            ghost.rotation.set(rx, ry, rz);
        }

        let scale = (x, y, z) => {
            sx = x;
            sy = y;
            sz = z;
            ghost.scaling.set(sx, sy, sz);
        }

        // let cam = (a, b) => {
        //     // camera.lookAt(ghost)
        //     if (a == 0) return;
        //     if (b == 0) return;

        //     camera.alpha = Math.PI / a;
        //     camera.beta = Math.PI / b;

        //     return "ok"
        // }

        let instanceId = 0;
        // let box_mother_crate = null;
        // let box_mother_ground = null;
        // let box_mother = null;

        let mesh_plane = null;
        let mesh_box = null;
        let mesh_sphere1 = null;
        let mesh_sphere2 = null;
        let mesh_sphere4 = null;
        let mesh_cylinder1 = null;
        let mesh_cylinder2 = null;
        let mesh_cylinder3 = null;
        let mesh_kegel = null;


        let box = (offset, faces, box_mother) => {
            return create(offset, faces, box_mother);
        }

        let create = (offset, faces, box_mother) => {

            // let pivot = cell.pivot;
            let dim = { x: size, y: size, z: size };
            // let faces = cell.faces;
            // let box_mother = cell.material;

            // let base = new BABYLON.Mesh("custom", scene);
            let base = BABYLON.MeshBuilder.CreateBox("", { size: .25 }, scene);
            // base.position.set(pivot.x + dim.x, pivot.y + dim.y, pivot.z + dim.z);
            base.position.set(cx + offset.x, cy + offset.y, cz + offset.z);
            base.rotation.set(rx, ry, rz);
            base.scaling.set(sx, sy, sz);
            // base.position.set(pivot.x, pivot.y, pivot.z);
            base.isVisible = false;
            attachDragBehavior(base);
            meshes.push(base);

            let plane = null;

            if (faces & CT) {
                // plane = BABYLON.MeshBuilder.CreatePlane("", { width: dim.x, height: dim.y, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
                plane = box_mother.createInstance(instanceId++);
                plane.scaling.x = dim.x;
                plane.scaling.y = dim.y;
                plane.scaling.z = dim.z;
                // plane.position.set(-dim.x * 0.5, -dim.y * 0.5, 0);
                plane.parent = base;
                plane.isVisible = true;
                // plane.receiveShadows = true;
                shadowGenerator.getShadowMap().renderList.push(plane);
                // plane.checkCollisions = true;
                // plane.material = box_material;
                meshes.push(plane);
            }

            if (faces & FW) {
                // plane = BABYLON.MeshBuilder.CreatePlane("", { width: dim.x, height: dim.y, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
                plane = box_mother.createInstance(instanceId++);
                plane.scaling.x = dim.x;
                plane.scaling.y = dim.y;
                plane.position.set(-dim.x * 0.5, -dim.y * 0.5, 0);
                plane.parent = base;
                plane.isVisible = true;
                // plane.receiveShadows = true;
                shadowGenerator.getShadowMap().renderList.push(plane);
                // plane.checkCollisions = true;
                // plane.material = box_material;
                meshes.push(plane);
            }

            if (faces & BW) {
                // plane = BABYLON.MeshBuilder.CreatePlane("", { width: dim.x, height: dim.y, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
                plane = box_mother.createInstance(instanceId++);
                plane.scaling.x = dim.x;
                plane.scaling.y = dim.y;
                plane.position.set(-dim.x * 0.5, -dim.y * 0.5, dim.z);
                plane.parent = base;
                plane.isVisible = true;
                // plane.receiveShadows = true;
                shadowGenerator.getShadowMap().renderList.push(plane);
                // plane.checkCollisions = true;
                // plane.material = box_material;
                meshes.push(plane);
            }

            if (faces & UP) {
                // plane = BABYLON.MeshBuilder.CreatePlane("", { width: dim.x, height: dim.z, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
                plane = box_mother.createInstance(instanceId++);
                plane.scaling.x = dim.x;
                plane.scaling.y = dim.z;
                plane.position.set(-dim.x * 0.5, 0, dim.z * 0.5);
                plane.parent = base;
                plane.isVisible = true;
                plane.rotation.x = 0.5 * Math.PI;
                // plane.receiveShadows = true;
                shadowGenerator.getShadowMap().renderList.push(plane);
                // plane.checkCollisions = true;
                // plane.material = box_material;
                meshes.push(plane);
            }

            if (faces & DW) {
                // plane = BABYLON.MeshBuilder.CreatePlane("", { width: dim.x, height: dim.z, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
                plane = box_mother.createInstance(instanceId++);
                plane.scaling.x = dim.x;
                plane.scaling.y = dim.z;
                plane.position.set(-dim.x * 0.5, -dim.y, dim.z * 0.5);
                plane.parent = base;
                plane.isVisible = true;
                plane.rotation.x = 0.5 * Math.PI;
                // plane.receiveShadows = true;
                shadowGenerator.getShadowMap().renderList.push(plane);
                // plane.checkCollisions = true;
                // plane.material = box_material;
                meshes.push(plane);
            }

            if (faces & RT) {
                // plane = BABYLON.MeshBuilder.CreatePlane("", { width: dim.z, height: dim.y, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
                plane = box_mother.createInstance(instanceId++);
                plane.scaling.x = dim.z;
                plane.scaling.y = dim.y;
                plane.position.set(0, -dim.y * 0.5, dim.z * 0.5);
                plane.parent = base;
                plane.isVisible = true;
                plane.rotation.y = 0.5 * Math.PI;
                // plane.receiveShadows = true;
                shadowGenerator.getShadowMap().renderList.push(plane);
                // plane.checkCollisions = true;
                // plane.material = box_material;
                meshes.push(plane);
            }

            if (faces & LT) {
                // plane = BABYLON.MeshBuilder.CreatePlane("", { width: dim.z, height: dim.y, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
                plane = box_mother.createInstance(instanceId++);
                plane.scaling.x = dim.z;
                plane.scaling.y = dim.y;
                plane.position.set(-dim.x, -dim.y * 0.5, dim.z * 0.5);
                plane.parent = base;
                plane.isVisible = true;
                plane.rotation.y = 0.5 * Math.PI;
                // plane.receiveShadows = true;
                shadowGenerator.getShadowMap().renderList.push(plane);
                // plane.checkCollisions = true;
                // plane.material = box_material;
                meshes.push(plane);
            }

            return base;
        }


        // // https://stackoverflow.com/questions/19636423/embed-js-console-within-website
        // const consoleElm = document.querySelector('#console');
        // const clearButton = document.querySelector('#clear');

        // clearButton.addEventListener('click', (event) => {
        //     consoleElm.innerHTML = '';
        // });

        // const consoleForm = document.querySelector('#console-form');
        // consoleForm.addEventListener('submit', (event) => {
        //     event.preventDefault();
        //     const command = event.target.querySelector('#command').value;
        //     const value = eval(command);
        //     consoleElm.innerHTML += (value === undefined ? 'undefined' : value) + '\n';
        // });


        let createScene = function () {
            let scene = new BABYLON.Scene(engine);
            scene = scene
            scene.enablePhysics(undefined, new BABYLON.OimoJSPlugin());
            let physicsEngine = scene.getPhysicsEngine();
            // physicsEngine.setGravity(new BABYLON.Vector3(0, -.9, 0))
            scene.collisionsEnabled = true;
            scene.gravity = new BABYLON.Vector3(0, -0.9, 0);
            let bgcolor = BABYLON.Color3.FromHexString('#111111');
            scene.clearColor = bgcolor;
            scene.ambientColor = bgcolor;

            camera = new BABYLON.ArcRotateCamera("camera1", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 0, -20));
            camera.attachControl(canvas, true);
            // camera.angularSensibilityX = 2000;
            // camera.angularSensibilityY = 2000;


            // https://doc.babylonjs.com/toolsAndResources/assetLibraries/availableTextures





            // let material_crate = new BABYLON.StandardMaterial("Mat", scene);
            // material_crate.diffuseTexture = new BABYLON.Texture("https://playground.babylonjs.com/textures/crate.png", scene);
            // // material_crate.diffuseTexture = new BABYLON.Texture(gallery.getOneImg(1), scene);
            // // material_crate.diffuseTexture.hasAlpha = true;
            // // material_crate.alpha = 0.5;

            // // material_fur = new BABYLON.StandardMaterial("Mat", scene);
            // // material_fur.diffuseTexture = new BABYLON.Texture("https://playground.babylonjs.com/textures/fur.png", scene);
            // // material_fur.diffuseTexture.hasAlpha = true;
            // // material.alpha = 0.5;

            // let material_ground = new BABYLON.StandardMaterial("Mat", scene);
            // material_ground.diffuseTexture = new BABYLON.Texture("https://playground.babylonjs.com/textures/ground.jpg", scene);
            // // material_ground.diffuseTexture = new BABYLON.Texture(gallery.getOneImg(2), scene);
            // // material_ground.diffuseTexture.hasAlpha = true;

            // box_material = material_crate;

            // box_mother_ground = BABYLON.MeshBuilder.CreatePlane("", { width: .95, height: .95, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
            // box_mother_ground.isVisible = false;
            // box_mother_ground.material = material_ground;



            // https://forum.babylonjs.com/t/how-to-create-a-lantern-animation/19211/2

            // latern: https://www.babylonjs-playground.com/#NWRGQJ#4

            let customProcTextmacadam = new BABYLON.RoadProceduralTexture("customtext", 512, scene);
            let mat_mesh = new BABYLON.StandardMaterial("gmat", scene);
            mat_mesh.diffuseTexture = customProcTextmacadam;
            mat_mesh.diffuseTexture.uScale = 10;
            mat_mesh.diffuseTexture.vScale = 10;
            mat_mesh.specularPower = 1;


            // mesh_plane = BABYLON.MeshBuilder.CreatePlane("", { width: .95, height: .95, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
            mesh_plane = BABYLON.MeshBuilder.CreatePlane("", { width: 1, height: 1, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
            mesh_plane.isVisible = false;
            mesh_plane.material = mat_mesh;
            mesh_plane.receiveShadows = true;

            mesh_box = BABYLON.MeshBuilder.CreateBox("sphere", { size: 1, sideOrientation: BABYLON.Mesh.DOUBLESIDE });
            mesh_box.isVisible = false;
            mesh_box.material = mat_mesh;
            mesh_box.receiveShadows = true;

            mesh_sphere1 = BABYLON.MeshBuilder.CreateSphere("sphere", { slice: 1, arc: 1, sideOrientation: BABYLON.Mesh.DOUBLESIDE });
            mesh_sphere1.isVisible = false;
            mesh_sphere1.material = mat_mesh;
            mesh_sphere1.receiveShadows = true;

            mesh_sphere2 = BABYLON.MeshBuilder.CreateSphere("sphere", { slice: 0.5, arc: 1, sideOrientation: BABYLON.Mesh.DOUBLESIDE });
            mesh_sphere2.isVisible = false;
            mesh_sphere2.material = mat_mesh;
            mesh_sphere2.receiveShadows = true;
            // mesh_half_sphere.material = material_crate;

            mesh_sphere4 = BABYLON.MeshBuilder.CreateSphere("sphere", { slice: 0.5, arc: 0.5, sideOrientation: BABYLON.Mesh.DOUBLESIDE });
            mesh_sphere4.isVisible = false;
            mesh_sphere4.material = mat_mesh;
            mesh_sphere4.receiveShadows = true;

            mesh_cylinder1 = BABYLON.MeshBuilder.CreateCylinder("cylinder", { height: 1, arc: 1, sideOrientation: BABYLON.Mesh.DOUBLESIDE });
            mesh_cylinder1.isVisible = false;
            mesh_cylinder1.material = mat_mesh;
            mesh_cylinder1.receiveShadows = true;

            mesh_cylinder2 = BABYLON.MeshBuilder.CreateCylinder("cylinder", { height: 1, arc: 0.5, sideOrientation: BABYLON.Mesh.DOUBLESIDE });
            mesh_cylinder2.isVisible = false;
            mesh_cylinder2.material = mat_mesh;
            mesh_cylinder2.receiveShadows = true;

            mesh_cylinder3 = BABYLON.MeshBuilder.CreateCylinder("cylinder", { height: 1, tessellation: 3, sideOrientation: BABYLON.Mesh.DOUBLESIDE });
            mesh_cylinder3.isVisible = false;
            mesh_cylinder3.material = mat_mesh;
            mesh_cylinder3.receiveShadows = true;

            mesh_kegel = BABYLON.MeshBuilder.CreateCylinder("cylinder", { height: 1, diameterTop: 0, sideOrientation: BABYLON.Mesh.DOUBLESIDE });
            mesh_kegel.isVisible = false;
            mesh_kegel.material = mat_mesh;
            mesh_kegel.receiveShadows = true;

            /*
            // https://doc.babylonjs.com/divingDeeper/mesh/creation/set/sphere
            // Viertel Sphere
            const sphere1 = BABYLON.MeshBuilder.CreateSphere("sphere", { slice: 0.5, arc: 0.5, sideOrientation: BABYLON.Mesh.DOUBLESIDE });

            // Zylinder dreieck
            const cylinder2 = BABYLON.MeshBuilder.CreateCylinder("cylinder", { tessellation: 3, sideOrientation: BABYLON.Mesh.DOUBLESIDE });

            // Zylinder halbiert
            const cylinder3 = BABYLON.MeshBuilder.CreateCylinder("cylinder", { height: 1, arc: 0.5, sideOrientation: BABYLON.Mesh.DOUBLESIDE });

            // Spitzer Zylinder Hut
            const cylinder4 = BABYLON.MeshBuilder.CreateCylinder("cylinder", { diameterTop: 0, sideOrientation: BABYLON.Mesh.DOUBLESIDE });

            // halbe scheibe
            const disc1 = BABYLON.MeshBuilder.CreateDisc("disc", { arc: 0.5, sideOrientation: BABYLON.Mesh.DOUBLESIDE });

            const torus1 = BABYLON.MeshBuilder.CreateTorus("torus", { diameter: 1, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
            */


            // box_mother = box_mother_crate;





            // Skybox
            // let skybox = BABYLON.Mesh.CreateBox('skyBox', 5000.0, scene)
            // let skyboxMaterial = new BABYLON.StandardMaterial('skyBox', scene)
            // skyboxMaterial.backFaceCulling = false
            // skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture('//www.babylonjs.com/assets/skybox/TropicalSunnyDay', scene)
            // skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE
            // skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0)
            // skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0)
            // skyboxMaterial.disableLighting = true
            // skybox.material = skyboxMaterial


            let skyLight = new BABYLON.HemisphericLight("sky", new BABYLON.Vector3(0, 1.0, 0), scene);
            skyLight.intensity = 0.20;

            // let light1 = new BABYLON.SpotLight("spotLight", new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 1, 0), Math.PI / 3, 2, scene);
            // light1.intensity = 0; // .5;
            // light1.diffuse = BABYLON.Color3.FromHexString('#FF0000');

            // let light2 = new BABYLON.SpotLight("spotLight", new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 1, 0), Math.PI / 3, 2, scene);
            // light2.intensity = 0; // .5;
            // light2.diffuse = BABYLON.Color3.FromHexString('#00FF00');

            // let light3 = new BABYLON.SpotLight("spotLight", new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 1, 0), Math.PI / 3, 2, scene);
            // light3.intensity = 0; // .5;
            // light3.diffuse = BABYLON.Color3.FromHexString('#0000FF');


            // let light0 = new BABYLON.DirectionalLight("", new BABYLON.Vector3(0, 1, 0), scene);
            // light0.intensity = .5;
            // light0.diffuse = BABYLON.Color3.FromHexString('#FFFFFF');
            // light0.position.z = -5;
            // light0.parent = camera;


            let lightSphere = BABYLON.Mesh.CreateSphere("sphere1", 16, 0.1, scene);
            let lightSphereMat = new BABYLON.StandardMaterial("mat", scene);
            lightSphere.material = lightSphereMat;
            lightSphereMat.emissiveColor = BABYLON.Color3.Yellow();
            lightSphereMat.linkEmissiveWithDiffuse = true;
            lightSphere.position.y = -1.0;

            // let light = new BABYLON.SpotLight("", new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 1), Math.PI / 3, 2, scene);
            // light.intensity = .25;
            // light.diffuse = BABYLON.Color3.FromHexString('#999999');
            // light.range = 100;
            // light.angle = Math.PI * 0.25;;
            // // light.radius = Math.PI * 0.5;
            // // light.parent = camera;

            let light = new BABYLON.PointLight("light1", BABYLON.Vector3.Zero(), scene);
            light.intensity = 0.7;
            light.diffuse = BABYLON.Color3.FromHexString('#ff9944');


            let t = 0;
            scene.registerBeforeRender(function () {
                lightSphere.position.x += 0.01 * Math.sin(t);
                lightSphere.position.y += 0.01 * Math.sin(t);
                lightSphere.position.z += 0.01 * Math.cos(t);

                light.position = lightSphere.getAbsolutePosition();
                // light.position.y += 0;
                light.intensity = 0.4 + Math.random() * 0.05;

                t += 0.01;
            });


            // showAxis(scene, 10);


            let pivot = {};
            let dimension = {};
            let base = null;
            let sphere = null;

            shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
            shadowGenerator.setDarkness(0.2);
            //shadowGenerator.usePoissonSampling = true;
            shadowGenerator.useBlurVarianceShadowMap = true;
            // shadowGenerator.blurBoxOffset = 1.0;
            // shadowGenerator.blurScale = 150.0;
            // shadowGenerator.forceBackFacesOnly = true;

            // shadowGenerator.setDarkness(0.2);
            // shadowGenerator.useCloseExponentialShadowMap = true;
            // //shadowGenerator.blurBoxOffset = 1.0;
            // //shadowGenerator.blurScale = 150.0;
            // shadowGenerator.bias = 0.5; // 0.01;


            // for (x = 0; x < max; x++) {
            //     cells[x] = [];
            //     for (y = 0; y < max; y++) {
            //         cells[x][y] = [];
            //         for (z = 0; z < max; z++) {
            //             // let nofaces1 = Math.pow(2, Math.floor(Math.random() * 7));
            //             // let nofaces2 = Math.pow(2, Math.floor(Math.random() * 7));
            //             // let nofaces3 = Math.pow(2, Math.floor(Math.random() * 7));
            //             cells[x][y][z] = {
            //                 faces: 0, // ALL - nofaces1 - nofaces2 - nofaces3,
            //                 dimension: { x: size, y: size, z: size },
            //                 pivot: { x: x * size, y: y * size, z: z * size },
            //                 material: box_mother_ground // x % 2 == 0 ? box_mother_ground : box_mother_crate
            //             };

            //             // plane = box_mother.createInstance(x+max*y+max*max*z);
            //         }
            //     }
            // }

            let mat_grid = new BABYLON.GridMaterial("groundMaterial", scene);
            mat_grid.gridRatio = 0.1;
            mat_grid.mainColor = BABYLON.Color3.Blue();
            mat_grid.opacity = 0.99;




            ghost = BABYLON.MeshBuilder.CreateBox("", { size: size * 0.9 }, scene);
            ghost.material = new BABYLON.StandardMaterial('skyBox', scene);
            ghost.material = mat_grid


            // var groundMesh = BABYLON.Mesh.CreateGround("groundMesh", 460, 460, 2, scene);
            // groundMesh.position.y = -0.1;
            // // groundMesh.position.y = -size * 0.5;
            // groundMesh.material = mat_grid

            /* Nebel:*/
            // fly camera: https://playground.babylonjs.com/#1SLLOJ#1638

            // let mat = new BABYLON.StandardMaterial("mat", scene);
            // mat.disableLighting = true;
            // mat.backFaceCulling = false;
            // let noiseTexture = new BABYLON.NoiseProceduralTexture("perlin", 256, scene);
            // // noiseTexture.hasAlpha = true;
            // noiseTexture.octaves = 7;
            // // noiseTexture.persistence=0.8;
            // noiseTexture.animationSpeedFactor = 1.5;
            // mat.alpha = 0.4;
            // mat.emissiveTexture = noiseTexture;

            // let plane = BABYLON.Mesh.CreateGround("ground", 2048, 2048, 16, scene, false);
            // plane.position.y = - size - .1;
            // // plane.material = mat;
            // plane.receiveShadows = true;
            // let plane_sky = BABYLON.Mesh.CreateGround("ground", 2048, 2048, 16, scene, false);
            // plane_sky.receiveShadows = true;
            // plane_sky.position.y = max + 0.1;
            // plane_sky.material = mat;

            /**/


            // let plane = BABYLON.Mesh.CreateGround("ground", 2048, 2048, 16, scene, false);
            // plane.position.y = -2.5; //  size - .1;
            // // plane.material = mat;
            // plane.receiveShadows = true;

            return scene;
        }






        let engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true
        });
        let scene = createScene();


        /*
        clear();
        // range(0, 9, 1, 0, 0, 1, 0, 9, 1);
        // // loop(set, AL);
        // // loop(not, FW);
        // // loop(not, BW);
        // loop(or, DW);
        // // loop(xor, LT + RT)

        // range(0, 9, 1, 0, 9, 1, 0, 0, 1);
        // loop(or, LT + RT);

        // pivot(0, 0, 0)
        // rotate(0, 0, 0);
        // for (let i = 0; i <= 5; i++) {
        //     range(i, 10 - i, 1, i, i, 1, i, 10 - i, 1);
        //     loop(AL, box_mother_ground)
        //     // box_mother = box_mother_crate;
        //     // loop(xor, DW)
        // }

        // box_mother_crate = null;
        // let box_mother_ground = null;

        // range(1, 8, 1, 1, 1, 1, 1, 8, 1);
        // loop(not, LT + RT)

        // range(4, 5, 1, 5, 9, 1, 4, 5, 1);
        // loop(set, LT + RT + FW + BW)

        // box_mother = box_mother_ground;
        // range(1, 8, 1, 1, 8, 1, 0, 0, 1);
        // rotate(0.5 * Math.PI, 0, 0);
        // loop(FW, box_mother_crate)

        // range(1, 8, 1, 1, 8, 1, 9, 9, 1);
        // rotate(0, 0.5 * Math.PI, 0);
        // loop(BW, box_mother_crate)

        // // box_mother = box_mother_crate;
        // range(1, 9, 1, 1, 9, 1, 1, 1, 1);
        // loop(set, FW, box_mother_ground)

        // pivot(2, 1, 3)
        // for (let i = 0; i <= 4; i++) {
        //     range(i, 9 - i, 1, i, i, 1, i, 9 - i, 1);
        //     loop(xor, DW)
        // }


        let pyramid = () => {
            rotate(0, 0, 0);
            for (let i = 0; i <= 5; i++) {
                range(i, 10 - i, 1, i, i, 1, i, 10 - i, 1);
                loop(AL, box_mother_ground)
            }
        }

        let tower = () => {
            rotate(0, 0, 0);
            range(0, 0, 1, 0, 5, 1, 0, 0, 1);
            loop(DW, box_mother_crate)
        }

        // let terrain = () => {
        //     for (let x = 0; x <= 12; x++) {
        //         for (let y = 0; y <= 6; y++) {
        //             rotate(
        //                 0.25 * Math.PI * (0.5 - Math.random()),
        //                 0.25 * Math.PI * (0.5 - Math.random()),
        //                 0.25 * Math.PI * (0.5 - Math.random()));
        //             range(x, x, 1, 0, 0, 1, y, y, 1);
        //             loop(DW, box_mother_crate);
        //         }
        //     }
        // }


        // pivot(0, 0, 0);
        // terrain();
        // pyramid();

        // pivot(0, 0, 0);
        // tower()

        // pivot(10, 0, 0);
        // tower()

        // pivot(0, 0, 5);
        // tower()

        let delta = 2;
        let demo = () => {
            range(0, 0, 1, 0, 5, 1, 0, 0, 1);
            loop(CT, mesh_plane);
            cx += delta;

            loop(CT, mesh_box);
            cx += delta;

            loop(CT, mesh_sphere1);
            cx += delta;

            loop(CT, mesh_sphere2);
            cx += delta;

            loop(CT, mesh_sphere4);
            cx += delta;

            loop(CT, mesh_cylinder1);
            cx += delta;

            loop(CT, mesh_cylinder2);
            cx += delta;

            loop(CT, mesh_cylinder3);
            cx += delta;

            loop(CT, mesh_kegel);
        }


        // for (let i = 0; i < 4; i++) {
        //     pivot(0, 0, i * delta);
        //     rotate(i * 2 * Math.PI / 4, 0, 0);
        //     demo();
        // }



        let modulA = () => {
            size = 1;

            // range(-5, 5, 1, 7.5, 7.5, 1, -5, 5, 1);
            // loop(CT, mesh_plane);

            range(0, 0, 1, -2, 0, 1, 0, 0, 1);
            rotate(Math.PI / 2, 0, 0);
            loop(CT, mesh_box);
            cy += size;

            range(0, 0, 1, 0, 5, 1, 0, 0, 1);
            rotate(0, 0, 0);
            loop(CT, mesh_cylinder1)
            cy += size * 6;

            range(0, 0, 1, 0, 0, 1, 0, 0, 1);
            rotate(Math.PI / 1, 0, 0);
            loop(CT, mesh_sphere2);
        }


        let floorSizeX = 30
        let floorSizeY = 7
        let floorSizeZ = 5

        // Boden
        range(-floorSizeX, floorSizeX, 1, -2.5, -2.5, 1, -floorSizeZ, floorSizeZ, 1);
        // rotate(Math.PI / 2, 0, 0);
        scale(1, 0.1, 1);
        loop(CT, mesh_box);

        scale(1, 1, 1);

        // Decke
        range(-floorSizeX, floorSizeX, 1, floorSizeY, floorSizeY, 1, -floorSizeZ, floorSizeZ, 1);
        rotate(Math.PI / 2, 0, 0);
        loop(CT, mesh_plane);

        // Gang
        for (let x = -floorSizeX; x <= floorSizeX; x += 4) {
            pivot(x, 0, -floorSizeZ);
            modulA();

            pivot(x, 0, floorSizeZ);
            modulA();
        }


        // pivot(-5, 0, 5);
        // modulA();

        // pivot(5, 0, 5);
        // modulA();

        // pivot(5, 0, -5);
        // modulA();

        // // Kuppel
        // pivot(0, 0, 0);
        // range(0, 0, 1, 7, 7, 1, 0, 0, 1);
        // size = floorSizeX;
        // // scale(1, 1, 2);
        // rotate(0, Math.PI, 0);
        // loop(CT, mesh_sphere2);


        // Brunnen
        pivot(0, 0, 0);
        range(0, 0, 1, 0, 0, 1, 0, 0, 1);
        size = floorSizeX * 0.125;
        // scale(1, 1, 2);
        // rotate(0, 0, Math.PI);
        loop(CT, mesh_sphere2);
        pivot(0, -2, 0)
        scale(0.5, 0.5, 0.5);
        loop(CT, mesh_box);

        pivot(0, 2, 0);
        scale(1, 1, 1);
        size = 1;
        loop(CT, mesh_sphere1);



        // range(0, 10, 1, 0, 0, 1, 0, 0, 1);

        // loop(CT, mesh_box);

        let circle = (r, y, m) => {
            let max = 36 * 6;
            for (let i = 0; i < max; i++) {
                // if (a.includes(i)) continue;
                if (i % m === 1) continue;
                let x = r * Math.sin(i * 2 * Math.PI / max);
                let z = r * Math.cos(i * 2 * Math.PI / max);
                let mesh = box({ x: x, y: 0, z: z }, CT, mesh_plane)
                // let mesh = BABYLON.MeshBuilder.CreateBox("", { size: 1 }, scene);
                mesh.position.set(x, y, z);
                mesh.scaling.set(1, 1, 0.25)
                mesh.receiveShadows = true;
                shadowGenerator.getShadowMap().renderList.push(mesh);

                ghost.position.y = y;
                mesh.lookAt(ghost.position)
            }
        }

        let r = 3 * 15;
        y = -2;
        circle(r, y++, 12);
        circle(r, y++, 0);
        circle(r, y++, 0);

        // let fenster = [];
        // for (let i = 0; i < 36; i += 4) { fenster.push(i) };

        circle(r, y++, 4);
        circle(r, y++, 1);
        circle(r, y++, 1);

        circle(r, y++, 4);
        circle(r, y++, 1);
        circle(r, y++, 1);

        circle(r, y++, 4);
        circle(r, y++, 1);
        circle(r, y++, 1);

        r += 0.1;
        circle(r, y++, 1);

        r += 0.1;
        circle(r, y++, 1);

        // r += 0.1;
        // circle(r, y++, []);

        r += 0.1;
        for (let i = 0; i < 2; i++) {
            circle(r, y++, 0);
        }


        // let zacken = [];
        // for (let i = 0; i < 36; i += 2) { zacken.push(i) };
        circle(r, y++, 2);

        // for (let i = 0; i < 2; i++) {
        //     size = 1 + i;
        //     delta = size + 1
        //     pivot(5, 5, i * delta);
        //     rotate(0, 0, i * 2 * Math.PI / 4);
        //     demo();
        // }

        // syntax von p5 https://p5js.org/examples/3d-sine-cosine-in-3d.html
        // push, pop, translate, sin, cos, ...

        // https://www.mediaevent.de/javascript/array-push-pop.html
        */


        clear();

        init();

        let brunnen = () => {
            for (let i = 0; i < 7; i++) {
                let s = 2 + (4 - i) * 0.2;
                scale(s * 1.6, s * 0.4, s * 1.6);
                rotate(Math.PI, 0, 0);
                create({ x: 0, y: i, z: 0 }, CT, mesh_sphere2)

                scale(0.25, 1, 0.25);
                create({ x: 0, y: i, z: 0 }, CT, mesh_cylinder1)
            }
        }

        pivot(0, 0, 0);
        brunnen();

        // pivot(10, 0, 0);
        // brunnen();

        // pivot(0, 0, 10);
        // brunnen();

        // pivot(0, 0, -10);
        // brunnen();

        // pivot(-10, 0, 0);
        // brunnen();



        let saeule = () => {
            size = 1;

            range(0, 0, 1, 0, 2, 1, 0, 0, 1);
            rotate(Math.PI / 2, 0, 0);
            loop(CT, mesh_box);
            cy += size;

            range(0, 0, 1, 2, 7, 1, 0, 0, 1);
            rotate(0, 0, 0);
            loop(CT, mesh_cylinder1)
            cy += size * 6;

            range(0, 0, 1, 2, 2, 1, 0, 0, 1);
            rotate(Math.PI / 1, 0, 0);
            loop(CT, mesh_sphere2);
        }


        let floorSizeX = 30
        let floorSizeY = 7
        let floorSizeZ = 5


        // Boden
        init();
        range(-floorSizeX, floorSizeX, 1, 0, 0, 1, -floorSizeZ, floorSizeZ, 1);
        // rotate(Math.PI / 2, 0, 0);
        scale(1, 0.1, 1);
        loop(CT, mesh_box);


        // Decke
        init();
        range(-floorSizeX, floorSizeX, 1, floorSizeY, floorSizeY, 1, -floorSizeZ, floorSizeZ, 1);
        rotate(Math.PI / 2, 0, 0);
        loop(CT, mesh_plane);

        // Gang
        for (let x = -floorSizeX; x <= floorSizeX; x += 4) {
            pivot(x, 0, -floorSizeZ);
            saeule();

            pivot(x, 0, floorSizeZ);
            saeule();
        }



        engine.runRenderLoop(function () {
            if (scene) {
                scene.render();
            }
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>

</body>

</html>