(function (Xe, qe) { typeof exports == "object" && typeof module < "u" ? qe(exports, require("@babylonjs/core")) : typeof define == "function" && define.amd ? define(["exports", "@babylonjs/core"], qe) : (Xe = typeof globalThis < "u" ? globalThis : Xe || self, qe(Xe["babylon-htmlmesh"] = {}, Xe.BABYLON)) })(this, function (Xe, qe) {
    "use strict"; var rl = Object.defineProperty; var nl = (Xe, qe, H) => qe in Xe ? rl(Xe, qe, { enumerable: !0, configurable: !0, writable: !0, value: H }) : Xe[qe] = H; var _e = (Xe, qe, H) => (nl(Xe, typeof qe != "symbol" ? qe + "" : qe, H), H); class H { static WithinEpsilon(e, t, i = 1401298e-51) { return Math.abs(e - t) <= i } static ToHex(e) { const t = e.toString(16); return e <= 15 ? ("0" + t).toUpperCase() : t.toUpperCase() } static Sign(e) { return e = +e, e === 0 || isNaN(e) ? e : e > 0 ? 1 : -1 } static Clamp(e, t = 0, i = 1) { return Math.min(i, Math.max(t, e)) } static Log2(e) { return Math.log(e) * Math.LOG2E } static ILog2(e) { if (Math.log2) return Math.floor(Math.log2(e)); if (e < 0) return NaN; if (e === 0) return -1 / 0; let t = 0; if (e < 1) { for (; e < 1;)t++, e = e * 2; t = -t } else if (e > 1) for (; e > 1;)t++, e = Math.floor(e / 2); return t } static Repeat(e, t) { return e - Math.floor(e / t) * t } static Normalize(e, t, i) { return (e - t) / (i - t) } static Denormalize(e, t, i) { return e * (i - t) + t } static DeltaAngle(e, t) { let i = H.Repeat(t - e, 360); return i > 180 && (i -= 360), i } static PingPong(e, t) { const i = H.Repeat(e, t * 2); return t - Math.abs(i - t) } static SmoothStep(e, t, i) { let s = H.Clamp(i); return s = -2 * s * s * s + 3 * s * s, t * s + e * (1 - s) } static MoveTowards(e, t, i) { let s = 0; return Math.abs(t - e) <= i ? s = t : s = e + H.Sign(t - e) * i, s } static MoveTowardsAngle(e, t, i) { const s = H.DeltaAngle(e, t); let r = 0; return -i < s && s < i ? r = t : (t = e + s, r = H.MoveTowards(e, t, i)), r } static Lerp(e, t, i) { return e + (t - e) * i } static LerpAngle(e, t, i) { let s = H.Repeat(t - e, 360); return s > 180 && (s -= 360), e + s * H.Clamp(i) } static InverseLerp(e, t, i) { let s = 0; return e != t ? s = H.Clamp((i - e) / (t - e)) : s = 0, s } static Hermite(e, t, i, s, r) { const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, l = -2 * a + 3 * n, h = a - 2 * n + r, u = a - n; return e * o + i * l + t * h + s * u } static Hermite1stDerivative(e, t, i, s, r) { const n = r * r; return (n - r) * 6 * e + (3 * n - 4 * r + 1) * t + (-n + r) * 6 * i + (3 * n - 2 * r) * s } static RandomRange(e, t) { return e === t ? e : Math.random() * (t - e) + e } static RangeToPercent(e, t, i) { return (e - t) / (i - t) } static PercentToRange(e, t, i) { return (i - t) * e + t } static NormalizeRadians(e) { return e -= H.TwoPi * Math.floor((e + Math.PI) / H.TwoPi), e } static HCF(e, t) { const i = e % t; return i === 0 ? t : H.HCF(t, i) } } H.TwoPi = Math.PI * 2; const ir = 1 / 2.2, sr = 2.2, Ie = .001; class Oe { static BuildArray(e, t) { const i = []; for (let s = 0; s < e; ++s)i.push(t()); return i } static BuildTuple(e, t) { return Oe.BuildArray(e, t) } } function rr(c, e, t) { const i = c[e]; if (typeof i != "function") return null; const s = function () { const r = c.length, n = s.previous.apply(c, arguments); return t(e, r), n }; return i.next = s, s.previous = i, c[e] = s, () => { const r = s.previous; if (!r) return; const n = s.next; n ? (r.next = n, n.previous = r) : (r.next = void 0, c[e] = r), s.next = void 0, s.previous = void 0 } } const nr = ["push", "splice", "pop", "shift", "unshift"]; function ar(c, e) { const t = nr.map(i => rr(c, i, e)); return () => { t.forEach(i => { i == null || i() }) } } const rs = {}; function at(c, e) { rs[c] = e } function Yt(c) { return rs[c] } class Pe { static SetMatrixPrecision(e) { if (Pe.MatrixTrackPrecisionChange = !1, e && !Pe.MatrixUse64Bits && Pe.MatrixTrackedMatrices) for (let t = 0; t < Pe.MatrixTrackedMatrices.length; ++t) { const i = Pe.MatrixTrackedMatrices[t], s = i._m; i._m = new Array(16); for (let r = 0; r < 16; ++r)i._m[r] = s[r] } Pe.MatrixUse64Bits = e, Pe.MatrixCurrentType = Pe.MatrixUse64Bits ? Array : Float32Array, Pe.MatrixTrackedMatrices = null } } Pe.MatrixUse64Bits = !1, Pe.MatrixTrackPrecisionChange = !0, Pe.MatrixCurrentType = Float32Array, Pe.MatrixTrackedMatrices = []; class or { constructor(e, t = !1, i, s) { this.initialize(e, t, i, s) } initialize(e, t = !1, i, s) { return this.mask = e, this.skipNextObservers = t, this.target = i, this.currentTarget = s, this } } class lr { constructor(e, t, i = null) { this.callback = e, this.mask = t, this.scope = i, this._willBeUnregistered = !1, this.unregisterOnNextCall = !1, this._remove = null } remove() { this._remove && this._remove() } } class L { static FromPromise(e, t) { const i = new L; return e.then(s => { i.notifyObservers(s) }).catch(s => { if (t) t.notifyObservers(s); else throw s }), i } get observers() { return this._observers } constructor(e, t = !1) { this.notifyIfTriggered = t, this._observers = new Array, this._numObserversMarkedAsDeleted = 0, this._hasNotified = !1, this._eventState = new or(0), e && (this._onObserverAdded = e) } add(e, t = -1, i = !1, s = null, r = !1) { if (!e) return null; const n = new lr(e, t, s); return n.unregisterOnNextCall = r, i ? this._observers.unshift(n) : this._observers.push(n), this._onObserverAdded && this._onObserverAdded(n), this._hasNotified && this.notifyIfTriggered && this._lastNotifiedValue !== void 0 && this.notifyObserver(n, this._lastNotifiedValue), n._remove = () => { this.remove(n) }, n } addOnce(e) { return this.add(e, void 0, void 0, void 0, !0) } remove(e) { return e ? (e._remove = null, this._observers.indexOf(e) !== -1 ? (this._deferUnregister(e), !0) : !1) : !1 } removeCallback(e, t) { for (let i = 0; i < this._observers.length; i++) { const s = this._observers[i]; if (!s._willBeUnregistered && s.callback === e && (!t || t === s.scope)) return this._deferUnregister(s), !0 } return !1 } _deferUnregister(e) { e._willBeUnregistered || (this._numObserversMarkedAsDeleted++, e.unregisterOnNextCall = !1, e._willBeUnregistered = !0, setTimeout(() => { this._remove(e) }, 0)) } _remove(e, t = !0) { if (!e) return !1; const i = this._observers.indexOf(e); return i !== -1 ? (t && this._numObserversMarkedAsDeleted--, this._observers.splice(i, 1), !0) : !1 } makeObserverTopPriority(e) { this._remove(e, !1), this._observers.unshift(e) } makeObserverBottomPriority(e) { this._remove(e, !1), this._observers.push(e) } notifyObservers(e, t = -1, i, s, r) { if (this.notifyIfTriggered && (this._hasNotified = !0, this._lastNotifiedValue = e), !this._observers.length) return !0; const n = this._eventState; n.mask = t, n.target = i, n.currentTarget = s, n.skipNextObservers = !1, n.lastReturnValue = e, n.userInfo = r; for (const a of this._observers) if (!a._willBeUnregistered && (a.mask & t && (a.unregisterOnNextCall && this._deferUnregister(a), a.scope ? n.lastReturnValue = a.callback.apply(a.scope, [e, n]) : n.lastReturnValue = a.callback(e, n)), n.skipNextObservers)) return !1; return !0 } notifyObserver(e, t, i = -1) { if (this.notifyIfTriggered && (this._hasNotified = !0, this._lastNotifiedValue = t), e._willBeUnregistered) return; const s = this._eventState; s.mask = i, s.skipNextObservers = !1, e.unregisterOnNextCall && this._deferUnregister(e), e.callback(t, s) } hasObservers() { return this._observers.length - this._numObserversMarkedAsDeleted > 0 } clear() { for (; this._observers.length;) { const e = this._observers.pop(); e && (e._remove = null) } this._onObserverAdded = null, this._numObserversMarkedAsDeleted = 0, this.cleanLastNotifiedState() } cleanLastNotifiedState() { this._hasNotified = !1, this._lastNotifiedValue = void 0 } clone() { const e = new L; return e._observers = this._observers.slice(0), e } hasSpecificMask(e = -1) { for (const t of this._observers) if (t.mask & e || t.mask === e) return !0; return !1 } } class ce { static get LastCreatedEngine() { return this.Instances.length === 0 ? null : this.Instances[this.Instances.length - 1] } static get LastCreatedScene() { return this._LastCreatedScene } } ce.Instances = [], ce.OnEnginesDisposedObservable = new L, ce._LastCreatedScene = null, ce.UseFallbackTexture = !0, ce.FallbackTexture = ""; const ze = c => parseInt(c.toString().replace(/\W/g, "")); class ge { constructor(e = 0, t = 0) { this.x = e, this.y = t } toString() { return `{X: ${this.x} Y: ${this.y}}` } getClassName() { return "Vector2" } getHashCode() { const e = ze(this.x), t = ze(this.y); let i = e; return i = i * 397 ^ t, i } toArray(e, t = 0) { return e[t] = this.x, e[t + 1] = this.y, this } fromArray(e, t = 0) { return ge.FromArrayToRef(e, t, this), this } asArray() { const e = []; return this.toArray(e, 0), e } copyFrom(e) { return this.x = e.x, this.y = e.y, this } copyFromFloats(e, t) { return this.x = e, this.y = t, this } set(e, t) { return this.copyFromFloats(e, t) } add(e) { return new this.constructor(this.x + e.x, this.y + e.y) } addToRef(e, t) { return t.x = this.x + e.x, t.y = this.y + e.y, t } addInPlace(e) { return this.x += e.x, this.y += e.y, this } addVector3(e) { return new this.constructor(this.x + e.x, this.y + e.y) } subtract(e) { return new this.constructor(this.x - e.x, this.y - e.y) } subtractToRef(e, t) { return t.x = this.x - e.x, t.y = this.y - e.y, t } subtractInPlace(e) { return this.x -= e.x, this.y -= e.y, this } multiplyInPlace(e) { return this.x *= e.x, this.y *= e.y, this } multiply(e) { return new this.constructor(this.x * e.x, this.y * e.y) } multiplyToRef(e, t) { return t.x = this.x * e.x, t.y = this.y * e.y, t } multiplyByFloats(e, t) { return new this.constructor(this.x * e, this.y * t) } divide(e) { return new this.constructor(this.x / e.x, this.y / e.y) } divideToRef(e, t) { return t.x = this.x / e.x, t.y = this.y / e.y, t } divideInPlace(e) { return this.divideToRef(e, this) } negate() { return new this.constructor(-this.x, -this.y) } negateInPlace() { return this.x *= -1, this.y *= -1, this } negateToRef(e) { return e.copyFromFloats(this.x * -1, this.y * -1) } scaleInPlace(e) { return this.x *= e, this.y *= e, this } scale(e) { const t = new this.constructor(0, 0); return this.scaleToRef(e, t), t } scaleToRef(e, t) { return t.x = this.x * e, t.y = this.y * e, t } scaleAndAddToRef(e, t) { return t.x += this.x * e, t.y += this.y * e, t } equals(e) { return e && this.x === e.x && this.y === e.y } equalsWithEpsilon(e, t = Ie) { return e && H.WithinEpsilon(this.x, e.x, t) && H.WithinEpsilon(this.y, e.y, t) } floor() { return new this.constructor(Math.floor(this.x), Math.floor(this.y)) } fract() { return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y)) } rotateToRef(e, t) { const i = Math.cos(e), s = Math.sin(e), r = i * this.x - s * this.y, n = s * this.x + i * this.y; return t.x = r, t.y = n, t } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } lengthSquared() { return this.x * this.x + this.y * this.y } normalize() { return this.normalizeFromLength(this.length()) } normalizeFromLength(e) { return e === 0 || e === 1 ? this : this.scaleInPlace(1 / e) } normalizeToNew() { const e = new this.constructor(0, 0); return this.normalizeToRef(e), e } normalizeToRef(e) { const t = this.length(); return t === 0 || t === 1 ? e.copyFromFloats(this.x, this.y) : this.scaleToRef(1 / t, e) } clone() { return new this.constructor(this.x, this.y) } dot(e) { return this.x * e.x + this.y * e.y } static Zero() { return new ge(0, 0) } static One() { return new ge(1, 1) } static Random(e = 0, t = 1) { return new ge(H.RandomRange(e, t), H.RandomRange(e, t)) } static get ZeroReadOnly() { return ge._ZeroReadOnly } static FromArray(e, t = 0) { return new ge(e[t], e[t + 1]) } static FromArrayToRef(e, t, i) { return i.x = e[t], i.y = e[t + 1], i } static CatmullRom(e, t, i, s, r) { const n = r * r, a = r * n, o = .5 * (2 * t.x + (-e.x + i.x) * r + (2 * e.x - 5 * t.x + 4 * i.x - s.x) * n + (-e.x + 3 * t.x - 3 * i.x + s.x) * a), l = .5 * (2 * t.y + (-e.y + i.y) * r + (2 * e.y - 5 * t.y + 4 * i.y - s.y) * n + (-e.y + 3 * t.y - 3 * i.y + s.y) * a); return new e.constructor(o, l) } static Clamp(e, t, i) { let s = e.x; s = s > i.x ? i.x : s, s = s < t.x ? t.x : s; let r = e.y; return r = r > i.y ? i.y : r, r = r < t.y ? t.y : r, new e.constructor(s, r) } static Hermite(e, t, i, s, r) { const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, l = -2 * a + 3 * n, h = a - 2 * n + r, u = a - n, f = e.x * o + i.x * l + t.x * h + s.x * u, _ = e.y * o + i.y * l + t.y * h + s.y * u; return new e.constructor(f, _) } static Hermite1stDerivative(e, t, i, s, r) { const n = new e.constructor; return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n } static Hermite1stDerivativeToRef(e, t, i, s, r, n) { const a = r * r; return n.x = (a - r) * 6 * e.x + (3 * a - 4 * r + 1) * t.x + (-a + r) * 6 * i.x + (3 * a - 2 * r) * s.x, n.y = (a - r) * 6 * e.y + (3 * a - 4 * r + 1) * t.y + (-a + r) * 6 * i.y + (3 * a - 2 * r) * s.y, n } static Lerp(e, t, i) { const s = e.x + (t.x - e.x) * i, r = e.y + (t.y - e.y) * i; return new e.constructor(s, r) } static Dot(e, t) { return e.x * t.x + e.y * t.y } static Normalize(e) { const t = new e.constructor; return ge.NormalizeToRef(e, t), t } static NormalizeToRef(e, t) { return e.normalizeToRef(t), t } static Minimize(e, t) { const i = e.x < t.x ? e.x : t.x, s = e.y < t.y ? e.y : t.y; return new e.constructor(i, s) } static Maximize(e, t) { const i = e.x > t.x ? e.x : t.x, s = e.y > t.y ? e.y : t.y; return new e.constructor(i, s) } static Transform(e, t) { const i = new e.constructor; return ge.TransformToRef(e, t, i), i } static TransformToRef(e, t, i) { const s = t.m, r = e.x * s[0] + e.y * s[4] + s[12], n = e.x * s[1] + e.y * s[5] + s[13]; return i.x = r, i.y = n, i } static PointInTriangle(e, t, i, s) { const r = .5 * (-i.y * s.x + t.y * (-i.x + s.x) + t.x * (i.y - s.y) + i.x * s.y), n = r < 0 ? -1 : 1, a = (t.y * s.x - t.x * s.y + (s.y - t.y) * e.x + (t.x - s.x) * e.y) * n, o = (t.x * i.y - t.y * i.x + (t.y - i.y) * e.x + (i.x - t.x) * e.y) * n; return a > 0 && o > 0 && a + o < 2 * r * n } static Distance(e, t) { return Math.sqrt(ge.DistanceSquared(e, t)) } static DistanceSquared(e, t) { const i = e.x - t.x, s = e.y - t.y; return i * i + s * s } static Center(e, t) { const i = new e.constructor; return ge.CenterToRef(e, t, i) } static CenterToRef(e, t, i) { return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2) } static DistanceOfPointFromSegment(e, t, i) { const s = ge.DistanceSquared(t, i); if (s === 0) return ge.Distance(e, t); const r = i.subtract(t), n = Math.max(0, Math.min(1, ge.Dot(e.subtract(t), r) / s)), a = t.add(r.multiplyByFloats(n, n)); return ge.Distance(e, a) } } ge._ZeroReadOnly = ge.Zero(); class g { get x() { return this._x } set x(e) { this._x = e, this._isDirty = !0 } get y() { return this._y } set y(e) { this._y = e, this._isDirty = !0 } get z() { return this._z } set z(e) { this._z = e, this._isDirty = !0 } constructor(e = 0, t = 0, i = 0) { this._isDirty = !0, this._x = e, this._y = t, this._z = i } toString() { return `{X: ${this._x} Y: ${this._y} Z: ${this._z}}` } getClassName() { return "Vector3" } getHashCode() { const e = ze(this._x), t = ze(this._y), i = ze(this._z); let s = e; return s = s * 397 ^ t, s = s * 397 ^ i, s } asArray() { const e = []; return this.toArray(e, 0), e } toArray(e, t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, this } fromArray(e, t = 0) { return g.FromArrayToRef(e, t, this), this } toQuaternion() { return q.RotationYawPitchRoll(this._y, this._x, this._z) } addInPlace(e) { return this.addInPlaceFromFloats(e._x, e._y, e._z) } addInPlaceFromFloats(e, t, i) { return this._x += e, this._y += t, this._z += i, this._isDirty = !0, this } add(e) { return new this.constructor(this._x + e._x, this._y + e._y, this._z + e._z) } addToRef(e, t) { return t.copyFromFloats(this._x + e._x, this._y + e._y, this._z + e._z) } subtractInPlace(e) { return this._x -= e._x, this._y -= e._y, this._z -= e._z, this._isDirty = !0, this } subtract(e) { return new this.constructor(this._x - e._x, this._y - e._y, this._z - e._z) } subtractToRef(e, t) { return this.subtractFromFloatsToRef(e._x, e._y, e._z, t) } subtractFromFloats(e, t, i) { return new this.constructor(this._x - e, this._y - t, this._z - i) } subtractFromFloatsToRef(e, t, i, s) { return s.copyFromFloats(this._x - e, this._y - t, this._z - i) } negate() { return new this.constructor(-this._x, -this._y, -this._z) } negateInPlace() { return this._x *= -1, this._y *= -1, this._z *= -1, this._isDirty = !0, this } negateToRef(e) { return e.copyFromFloats(this._x * -1, this._y * -1, this._z * -1) } scaleInPlace(e) { return this._x *= e, this._y *= e, this._z *= e, this._isDirty = !0, this } scale(e) { return new this.constructor(this._x * e, this._y * e, this._z * e) } scaleToRef(e, t) { return t.copyFromFloats(this._x * e, this._y * e, this._z * e) } getNormalToRef(e) { const t = this.length(); let i = Math.acos(this.y / t); const s = Math.atan2(this.z, this.x); i > Math.PI / 2 ? i -= Math.PI / 2 : i += Math.PI / 2; const r = t * Math.sin(i) * Math.cos(s), n = t * Math.cos(i), a = t * Math.sin(i) * Math.sin(s); return e.set(r, n, a), e } applyRotationQuaternionToRef(e, t) { const i = this._x, s = this._y, r = this._z, n = e._x, a = e._y, o = e._z, l = e._w, h = 2 * (a * r - o * s), u = 2 * (o * i - n * r), f = 2 * (n * s - a * i); return t._x = i + l * h + a * f - o * u, t._y = s + l * u + o * h - n * f, t._z = r + l * f + n * u - a * h, t._isDirty = !0, t } applyRotationQuaternionInPlace(e) { return this.applyRotationQuaternionToRef(e, this) } applyRotationQuaternion(e) { return this.applyRotationQuaternionToRef(e, new this.constructor) } scaleAndAddToRef(e, t) { return t.addInPlaceFromFloats(this._x * e, this._y * e, this._z * e) } projectOnPlane(e, t) { const i = new this.constructor; return this.projectOnPlaneToRef(e, t, i), i } projectOnPlaneToRef(e, t, i) { const s = e.normal, r = e.d, n = B.Vector3[0]; this.subtractToRef(t, n), n.normalize(); const a = g.Dot(n, s); if (Math.abs(a) < 1e-10) i.setAll(1 / 0); else { const o = -(g.Dot(t, s) + r) / a, l = n.scaleInPlace(o); t.addToRef(l, i) } return i } equals(e) { return e && this._x === e._x && this._y === e._y && this._z === e._z } equalsWithEpsilon(e, t = Ie) { return e && H.WithinEpsilon(this._x, e._x, t) && H.WithinEpsilon(this._y, e._y, t) && H.WithinEpsilon(this._z, e._z, t) } equalsToFloats(e, t, i) { return this._x === e && this._y === t && this._z === i } multiplyInPlace(e) { return this._x *= e._x, this._y *= e._y, this._z *= e._z, this._isDirty = !0, this } multiply(e) { return this.multiplyByFloats(e._x, e._y, e._z) } multiplyToRef(e, t) { return t.copyFromFloats(this._x * e._x, this._y * e._y, this._z * e._z) } multiplyByFloats(e, t, i) { return new this.constructor(this._x * e, this._y * t, this._z * i) } divide(e) { return new this.constructor(this._x / e._x, this._y / e._y, this._z / e._z) } divideToRef(e, t) { return t.copyFromFloats(this._x / e._x, this._y / e._y, this._z / e._z) } divideInPlace(e) { return this.divideToRef(e, this) } minimizeInPlace(e) { return this.minimizeInPlaceFromFloats(e._x, e._y, e._z) } maximizeInPlace(e) { return this.maximizeInPlaceFromFloats(e._x, e._y, e._z) } minimizeInPlaceFromFloats(e, t, i) { return e < this._x && (this.x = e), t < this._y && (this.y = t), i < this._z && (this.z = i), this } maximizeInPlaceFromFloats(e, t, i) { return e > this._x && (this.x = e), t > this._y && (this.y = t), i > this._z && (this.z = i), this } isNonUniformWithinEpsilon(e) { const t = Math.abs(this._x), i = Math.abs(this._y); if (!H.WithinEpsilon(t, i, e)) return !0; const s = Math.abs(this._z); return !H.WithinEpsilon(t, s, e) || !H.WithinEpsilon(i, s, e) } get isNonUniform() { const e = Math.abs(this._x), t = Math.abs(this._y); if (e !== t) return !0; const i = Math.abs(this._z); return e !== i } floor() { return new this.constructor(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z)) } fract() { return new this.constructor(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z)) } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z) } lengthSquared() { return this._x * this._x + this._y * this._y + this._z * this._z } get hasAZeroComponent() { return this._x * this._y * this._z === 0 } normalize() { return this.normalizeFromLength(this.length()) } reorderInPlace(e) { if (e = e.toLowerCase(), e === "xyz") return this; const t = B.Vector3[0].copyFrom(this); return this.x = t[e[0]], this.y = t[e[1]], this.z = t[e[2]], this } rotateByQuaternionToRef(e, t) { return e.toRotationMatrix(B.Matrix[0]), g.TransformCoordinatesToRef(this, B.Matrix[0], t), t } rotateByQuaternionAroundPointToRef(e, t, i) { return this.subtractToRef(t, B.Vector3[0]), B.Vector3[0].rotateByQuaternionToRef(e, B.Vector3[0]), t.addToRef(B.Vector3[0], i), i } cross(e) { const t = new this.constructor; return g.CrossToRef(this, e, t) } normalizeFromLength(e) { return e === 0 || e === 1 ? this : this.scaleInPlace(1 / e) } normalizeToNew() { const e = new this.constructor(0, 0, 0); return this.normalizeToRef(e), e } normalizeToRef(e) { const t = this.length(); return t === 0 || t === 1 ? e.copyFromFloats(this._x, this._y, this._z) : this.scaleToRef(1 / t, e) } clone() { return new this.constructor(this._x, this._y, this._z) } copyFrom(e) { return this.copyFromFloats(e._x, e._y, e._z) } copyFromFloats(e, t, i) { return this._x = e, this._y = t, this._z = i, this._isDirty = !0, this } set(e, t, i) { return this.copyFromFloats(e, t, i) } setAll(e) { return this._x = this._y = this._z = e, this._isDirty = !0, this } static GetClipFactor(e, t, i, s) { const r = g.Dot(e, i), n = g.Dot(t, i); return (r - s) / (r - n) } static GetAngleBetweenVectors(e, t, i) { const s = e.normalizeToRef(B.Vector3[1]), r = t.normalizeToRef(B.Vector3[2]); let n = g.Dot(s, r); n = H.Clamp(n, -1, 1); const a = Math.acos(n), o = B.Vector3[3]; return g.CrossToRef(s, r, o), g.Dot(o, i) > 0 ? isNaN(a) ? 0 : a : isNaN(a) ? -Math.PI : -Math.acos(n) } static GetAngleBetweenVectorsOnPlane(e, t, i) { B.Vector3[0].copyFrom(e); const s = B.Vector3[0]; B.Vector3[1].copyFrom(t); const r = B.Vector3[1]; B.Vector3[2].copyFrom(i); const n = B.Vector3[2], a = B.Vector3[3], o = B.Vector3[4]; s.normalize(), r.normalize(), n.normalize(), g.CrossToRef(n, s, a), g.CrossToRef(a, n, o); const l = Math.atan2(g.Dot(r, a), g.Dot(r, o)); return H.NormalizeRadians(l) } static PitchYawRollToMoveBetweenPointsToRef(e, t, i) { const s = D.Vector3[0]; return t.subtractToRef(e, s), i._y = Math.atan2(s.x, s.z) || 0, i._x = Math.atan2(Math.sqrt(s.x ** 2 + s.z ** 2), s.y) || 0, i._z = 0, i._isDirty = !0, i } static PitchYawRollToMoveBetweenPoints(e, t) { const i = g.Zero(); return g.PitchYawRollToMoveBetweenPointsToRef(e, t, i) } static SlerpToRef(e, t, i, s) { i = H.Clamp(i, 0, 1); const r = B.Vector3[0], n = B.Vector3[1]; r.copyFrom(e); const a = r.length(); r.normalizeFromLength(a), n.copyFrom(t); const o = n.length(); n.normalizeFromLength(o); const l = g.Dot(r, n); let h, u; if (l < 1 - Ie) { const f = Math.acos(l), _ = 1 / Math.sin(f); h = Math.sin((1 - i) * f) * _, u = Math.sin(i * f) * _ } else h = 1 - i, u = i; return r.scaleInPlace(h), n.scaleInPlace(u), s.copyFrom(r).addInPlace(n), s.scaleInPlace(H.Lerp(a, o, i)), s } static SmoothToRef(e, t, i, s, r) { return g.SlerpToRef(e, t, s === 0 ? 1 : i / s, r), r } static FromArray(e, t = 0) { return new g(e[t], e[t + 1], e[t + 2]) } static FromFloatArray(e, t) { return g.FromArray(e, t) } static FromArrayToRef(e, t, i) { return i._x = e[t], i._y = e[t + 1], i._z = e[t + 2], i._isDirty = !0, i } static FromFloatArrayToRef(e, t, i) { return g.FromArrayToRef(e, t, i) } static FromFloatsToRef(e, t, i, s) { return s.copyFromFloats(e, t, i), s } static Zero() { return new g(0, 0, 0) } static One() { return new g(1, 1, 1) } static Up() { return new g(0, 1, 0) } static get UpReadOnly() { return g._UpReadOnly } static get DownReadOnly() { return g._DownReadOnly } static get RightReadOnly() { return g._RightReadOnly } static get LeftReadOnly() { return g._LeftReadOnly } static get LeftHandedForwardReadOnly() { return g._LeftHandedForwardReadOnly } static get RightHandedForwardReadOnly() { return g._RightHandedForwardReadOnly } static get LeftHandedBackwardReadOnly() { return g._LeftHandedBackwardReadOnly } static get RightHandedBackwardReadOnly() { return g._RightHandedBackwardReadOnly } static get ZeroReadOnly() { return g._ZeroReadOnly } static get OneReadOnly() { return g._OneReadOnly } static Down() { return new g(0, -1, 0) } static Forward(e = !1) { return new g(0, 0, e ? -1 : 1) } static Backward(e = !1) { return new g(0, 0, e ? 1 : -1) } static Right() { return new g(1, 0, 0) } static Left() { return new g(-1, 0, 0) } static Random(e = 0, t = 1) { return new g(H.RandomRange(e, t), H.RandomRange(e, t), H.RandomRange(e, t)) } static TransformCoordinates(e, t) { const i = g.Zero(); return g.TransformCoordinatesToRef(e, t, i), i } static TransformCoordinatesToRef(e, t, i) { return g.TransformCoordinatesFromFloatsToRef(e._x, e._y, e._z, t, i), i } static TransformCoordinatesFromFloatsToRef(e, t, i, s, r) { const n = s.m, a = e * n[0] + t * n[4] + i * n[8] + n[12], o = e * n[1] + t * n[5] + i * n[9] + n[13], l = e * n[2] + t * n[6] + i * n[10] + n[14], h = 1 / (e * n[3] + t * n[7] + i * n[11] + n[15]); return r._x = a * h, r._y = o * h, r._z = l * h, r._isDirty = !0, r } static TransformNormal(e, t) { const i = g.Zero(); return g.TransformNormalToRef(e, t, i), i } static TransformNormalToRef(e, t, i) { return this.TransformNormalFromFloatsToRef(e._x, e._y, e._z, t, i), i } static TransformNormalFromFloatsToRef(e, t, i, s, r) { const n = s.m; return r._x = e * n[0] + t * n[4] + i * n[8], r._y = e * n[1] + t * n[5] + i * n[9], r._z = e * n[2] + t * n[6] + i * n[10], r._isDirty = !0, r } static CatmullRom(e, t, i, s, r) { const n = r * r, a = r * n, o = .5 * (2 * t._x + (-e._x + i._x) * r + (2 * e._x - 5 * t._x + 4 * i._x - s._x) * n + (-e._x + 3 * t._x - 3 * i._x + s._x) * a), l = .5 * (2 * t._y + (-e._y + i._y) * r + (2 * e._y - 5 * t._y + 4 * i._y - s._y) * n + (-e._y + 3 * t._y - 3 * i._y + s._y) * a), h = .5 * (2 * t._z + (-e._z + i._z) * r + (2 * e._z - 5 * t._z + 4 * i._z - s._z) * n + (-e._z + 3 * t._z - 3 * i._z + s._z) * a); return new e.constructor(o, l, h) } static Clamp(e, t, i) { const s = new e.constructor; return g.ClampToRef(e, t, i, s), s } static ClampToRef(e, t, i, s) { let r = e._x; r = r > i._x ? i._x : r, r = r < t._x ? t._x : r; let n = e._y; n = n > i._y ? i._y : n, n = n < t._y ? t._y : n; let a = e._z; return a = a > i._z ? i._z : a, a = a < t._z ? t._z : a, s.copyFromFloats(r, n, a), s } static CheckExtends(e, t, i) { t.minimizeInPlace(e), i.maximizeInPlace(e) } static Hermite(e, t, i, s, r) { const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, l = -2 * a + 3 * n, h = a - 2 * n + r, u = a - n, f = e._x * o + i._x * l + t._x * h + s._x * u, _ = e._y * o + i._y * l + t._y * h + s._y * u, p = e._z * o + i._z * l + t._z * h + s._z * u; return new e.constructor(f, _, p) } static Hermite1stDerivative(e, t, i, s, r) { const n = new e.constructor; return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n } static Hermite1stDerivativeToRef(e, t, i, s, r, n) { const a = r * r; return n._x = (a - r) * 6 * e._x + (3 * a - 4 * r + 1) * t._x + (-a + r) * 6 * i._x + (3 * a - 2 * r) * s._x, n._y = (a - r) * 6 * e._y + (3 * a - 4 * r + 1) * t._y + (-a + r) * 6 * i._y + (3 * a - 2 * r) * s._y, n._z = (a - r) * 6 * e._z + (3 * a - 4 * r + 1) * t._z + (-a + r) * 6 * i._z + (3 * a - 2 * r) * s._z, n._isDirty = !0, n } static Lerp(e, t, i) { const s = new e.constructor(0, 0, 0); return g.LerpToRef(e, t, i, s), s } static LerpToRef(e, t, i, s) { return s._x = e._x + (t._x - e._x) * i, s._y = e._y + (t._y - e._y) * i, s._z = e._z + (t._z - e._z) * i, s._isDirty = !0, s } static Dot(e, t) { return e._x * t._x + e._y * t._y + e._z * t._z } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z } static Cross(e, t) { const i = new e.constructor; return g.CrossToRef(e, t, i), i } static CrossToRef(e, t, i) { const s = e._y * t._z - e._z * t._y, r = e._z * t._x - e._x * t._z, n = e._x * t._y - e._y * t._x; return i.copyFromFloats(s, r, n), i } static Normalize(e) { const t = g.Zero(); return g.NormalizeToRef(e, t), t } static NormalizeToRef(e, t) { return e.normalizeToRef(t), t } static Project(e, t, i, s) { const r = new e.constructor; return g.ProjectToRef(e, t, i, s, r), r } static ProjectToRef(e, t, i, s, r) { const n = s.width, a = s.height, o = s.x, l = s.y, h = B.Matrix[1]; A.FromValuesToRef(n / 2, 0, 0, 0, 0, -a / 2, 0, 0, 0, 0, .5, 0, o + n / 2, a / 2 + l, .5, 1, h); const u = B.Matrix[0]; return t.multiplyToRef(i, u), u.multiplyToRef(h, u), g.TransformCoordinatesToRef(e, u, r), r } static Reflect(e, t) { return this.ReflectToRef(e, t, new g) } static ReflectToRef(e, t, i) { const s = D.Vector3[0]; return s.copyFrom(t).scaleInPlace(2 * g.Dot(e, t)), i.copyFrom(e).subtractInPlace(s) } static _UnprojectFromInvertedMatrixToRef(e, t, i) { g.TransformCoordinatesToRef(e, t, i); const s = t.m, r = e._x * s[3] + e._y * s[7] + e._z * s[11] + s[15]; return H.WithinEpsilon(r, 1) && i.scaleInPlace(1 / r), i } static UnprojectFromTransform(e, t, i, s, r) { return this.Unproject(e, t, i, s, r, A.IdentityReadOnly) } static Unproject(e, t, i, s, r, n) { const a = new e.constructor; return g.UnprojectToRef(e, t, i, s, r, n, a), a } static UnprojectToRef(e, t, i, s, r, n, a) { return g.UnprojectFloatsToRef(e._x, e._y, e._z, t, i, s, r, n, a), a } static UnprojectFloatsToRef(e, t, i, s, r, n, a, o, l) { var h; const u = B.Matrix[0]; n.multiplyToRef(a, u), u.multiplyToRef(o, u), u.invert(); const f = B.Vector3[0]; return f.x = e / s * 2 - 1, f.y = -(t / r * 2 - 1), !((h = ce.LastCreatedEngine) === null || h === void 0) && h.isNDCHalfZRange ? f.z = i : f.z = 2 * i - 1, g._UnprojectFromInvertedMatrixToRef(f, u, l), l } static Minimize(e, t) { const i = new e.constructor; return i.copyFrom(e), i.minimizeInPlace(t), i } static Maximize(e, t) { const i = new e.constructor; return i.copyFrom(e), i.maximizeInPlace(t), i } static Distance(e, t) { return Math.sqrt(g.DistanceSquared(e, t)) } static DistanceSquared(e, t) { const i = e._x - t._x, s = e._y - t._y, r = e._z - t._z; return i * i + s * s + r * r } static ProjectOnTriangleToRef(e, t, i, s, r) { const n = B.Vector3[0], a = B.Vector3[1], o = B.Vector3[2], l = B.Vector3[3], h = B.Vector3[4]; i.subtractToRef(t, n), s.subtractToRef(t, a), s.subtractToRef(i, o); const u = n.length(), f = a.length(), _ = o.length(); if (u < Ie || f < Ie || _ < Ie) return r.copyFrom(t), g.Distance(e, t); e.subtractToRef(t, h), g.CrossToRef(n, a, l); const p = l.length(); if (p < Ie) return r.copyFrom(t), g.Distance(e, t); l.normalizeFromLength(p); let v = h.length(); if (v < Ie) return r.copyFrom(t), 0; h.normalizeFromLength(v); const E = g.Dot(l, h), m = B.Vector3[5], x = B.Vector3[6]; m.copyFrom(l).scaleInPlace(-v * E), x.copyFrom(e).addInPlace(m); const C = B.Vector3[4], S = B.Vector3[5], y = B.Vector3[7], b = B.Vector3[8]; C.copyFrom(n).scaleInPlace(1 / u), b.copyFrom(a).scaleInPlace(1 / f), C.addInPlace(b).scaleInPlace(-1), S.copyFrom(n).scaleInPlace(-1 / u), b.copyFrom(o).scaleInPlace(1 / _), S.addInPlace(b).scaleInPlace(-1), y.copyFrom(o).scaleInPlace(-1 / _), b.copyFrom(a).scaleInPlace(-1 / f), y.addInPlace(b).scaleInPlace(-1); const R = B.Vector3[9]; let w; R.copyFrom(x).subtractInPlace(t), g.CrossToRef(C, R, b), w = g.Dot(b, l); const N = w; R.copyFrom(x).subtractInPlace(i), g.CrossToRef(S, R, b), w = g.Dot(b, l); const X = w; R.copyFrom(x).subtractInPlace(s), g.CrossToRef(y, R, b), w = g.Dot(b, l); const fe = w, J = B.Vector3[10]; let ae, ee; N > 0 && X < 0 ? (J.copyFrom(n), ae = t, ee = i) : X > 0 && fe < 0 ? (J.copyFrom(o), ae = i, ee = s) : (J.copyFrom(a).scaleInPlace(-1), ae = s, ee = t); const Me = B.Vector3[9], Ae = B.Vector3[4]; if (ae.subtractToRef(x, b), ee.subtractToRef(x, Me), g.CrossToRef(b, Me, Ae), !(g.Dot(Ae, l) < 0)) return r.copyFrom(x), Math.abs(v * E); const xe = B.Vector3[5]; g.CrossToRef(J, Ae, xe), xe.normalize(); const Re = B.Vector3[9]; Re.copyFrom(ae).subtractInPlace(x); const tt = Re.length(); if (tt < Ie) return r.copyFrom(ae), g.Distance(e, ae); Re.normalizeFromLength(tt); const Ze = g.Dot(xe, Re), ft = B.Vector3[7]; ft.copyFrom(x).addInPlace(xe.scaleInPlace(tt * Ze)), b.copyFrom(ft).subtractInPlace(ae), v = J.length(), J.normalizeFromLength(v); let It = g.Dot(b, J) / Math.max(v, Ie); return It = H.Clamp(It, 0, 1), ft.copyFrom(ae).addInPlace(J.scaleInPlace(It * v)), r.copyFrom(ft), g.Distance(e, ft) } static Center(e, t) { return g.CenterToRef(e, t, g.Zero()) } static CenterToRef(e, t, i) { return i.copyFromFloats((e._x + t._x) / 2, (e._y + t._y) / 2, (e._z + t._z) / 2) } static RotationFromAxis(e, t, i) { const s = new e.constructor; return g.RotationFromAxisToRef(e, t, i, s), s } static RotationFromAxisToRef(e, t, i, s) { const r = B.Quaternion[0]; return q.RotationQuaternionFromAxisToRef(e, t, i, r), r.toEulerAnglesToRef(s), s } } g._UpReadOnly = g.Up(), g._DownReadOnly = g.Down(), g._LeftHandedForwardReadOnly = g.Forward(!1), g._RightHandedForwardReadOnly = g.Forward(!0), g._LeftHandedBackwardReadOnly = g.Backward(!1), g._RightHandedBackwardReadOnly = g.Backward(!0), g._RightReadOnly = g.Right(), g._LeftReadOnly = g.Left(), g._ZeroReadOnly = g.Zero(), g._OneReadOnly = g.One(); class ve { constructor(e = 0, t = 0, i = 0, s = 0) { this.x = e, this.y = t, this.z = i, this.w = s } toString() { return `{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}` } getClassName() { return "Vector4" } getHashCode() { const e = ze(this.x), t = ze(this.y), i = ze(this.z), s = ze(this.w); let r = e; return r = r * 397 ^ t, r = r * 397 ^ i, r = r * 397 ^ s, r } asArray() { const e = []; return this.toArray(e, 0), e } toArray(e, t) { return t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, this } fromArray(e, t = 0) { return ve.FromArrayToRef(e, t, this), this } addInPlace(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } add(e) { return new this.constructor(this.x + e.x, this.y + e.y, this.z + e.z, this.w + e.w) } addToRef(e, t) { return t.x = this.x + e.x, t.y = this.y + e.y, t.z = this.z + e.z, t.w = this.w + e.w, t } subtractInPlace(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subtract(e) { return new this.constructor(this.x - e.x, this.y - e.y, this.z - e.z, this.w - e.w) } subtractToRef(e, t) { return t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z, t.w = this.w - e.w, t } subtractFromFloats(e, t, i, s) { return new this.constructor(this.x - e, this.y - t, this.z - i, this.w - s) } subtractFromFloatsToRef(e, t, i, s, r) { return r.x = this.x - e, r.y = this.y - t, r.z = this.z - i, r.w = this.w - s, r } negate() { return new this.constructor(-this.x, -this.y, -this.z, -this.w) } negateInPlace() { return this.x *= -1, this.y *= -1, this.z *= -1, this.w *= -1, this } negateToRef(e) { return e.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1) } scaleInPlace(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } scale(e) { return new this.constructor(this.x * e, this.y * e, this.z * e, this.w * e) } scaleToRef(e, t) { return t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e, t } scaleAndAddToRef(e, t) { return t.x += this.x * e, t.y += this.y * e, t.z += this.z * e, t.w += this.w * e, t } equals(e) { return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w } equalsWithEpsilon(e, t = Ie) { return e && H.WithinEpsilon(this.x, e.x, t) && H.WithinEpsilon(this.y, e.y, t) && H.WithinEpsilon(this.z, e.z, t) && H.WithinEpsilon(this.w, e.w, t) } equalsToFloats(e, t, i, s) { return this.x === e && this.y === t && this.z === i && this.w === s } multiplyInPlace(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiply(e) { return new this.constructor(this.x * e.x, this.y * e.y, this.z * e.z, this.w * e.w) } multiplyToRef(e, t) { return t.x = this.x * e.x, t.y = this.y * e.y, t.z = this.z * e.z, t.w = this.w * e.w, t } multiplyByFloats(e, t, i, s) { return new this.constructor(this.x * e, this.y * t, this.z * i, this.w * s) } divide(e) { return new this.constructor(this.x / e.x, this.y / e.y, this.z / e.z, this.w / e.w) } divideToRef(e, t) { return t.x = this.x / e.x, t.y = this.y / e.y, t.z = this.z / e.z, t.w = this.w / e.w, t } divideInPlace(e) { return this.divideToRef(e, this) } minimizeInPlace(e) { return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), e.z < this.z && (this.z = e.z), e.w < this.w && (this.w = e.w), this } maximizeInPlace(e) { return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), e.z > this.z && (this.z = e.z), e.w > this.w && (this.w = e.w), this } floor() { return new this.constructor(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w)) } fract() { return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w)) } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } lengthSquared() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } normalize() { return this.normalizeFromLength(this.length()) } normalizeFromLength(e) { return e === 0 || e === 1 ? this : this.scaleInPlace(1 / e) } normalizeToNew() { const e = new this.constructor(0, 0, 0, 0); return this.normalizeToRef(e), e } normalizeToRef(e) { const t = this.length(); return t === 0 || t === 1 ? e.copyFromFloats(this.x, this.y, this.z, this.w) : this.scaleToRef(1 / t, e) } toVector3() { return new g(this.x, this.y, this.z) } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copyFrom(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this } copyFromFloats(e, t, i, s) { return this.x = e, this.y = t, this.z = i, this.w = s, this } set(e, t, i, s) { return this.copyFromFloats(e, t, i, s) } setAll(e) { return this.x = this.y = this.z = this.w = e, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } static FromArray(e, t) { return t || (t = 0), new ve(e[t], e[t + 1], e[t + 2], e[t + 3]) } static FromArrayToRef(e, t, i) { return i.x = e[t], i.y = e[t + 1], i.z = e[t + 2], i.w = e[t + 3], i } static FromFloatArrayToRef(e, t, i) { return ve.FromArrayToRef(e, t, i), i } static FromFloatsToRef(e, t, i, s, r) { return r.x = e, r.y = t, r.z = i, r.w = s, r } static Zero() { return new ve(0, 0, 0, 0) } static One() { return new ve(1, 1, 1, 1) } static Random(e = 0, t = 1) { return new ve(H.RandomRange(e, t), H.RandomRange(e, t), H.RandomRange(e, t), H.RandomRange(e, t)) } static get ZeroReadOnly() { return ve._ZeroReadOnly } static Normalize(e) { const t = ve.Zero(); return ve.NormalizeToRef(e, t), t } static NormalizeToRef(e, t) { return e.normalizeToRef(t), t } static Minimize(e, t) { const i = new e.constructor; return i.copyFrom(e), i.minimizeInPlace(t), i } static Maximize(e, t) { const i = new e.constructor; return i.copyFrom(e), i.maximizeInPlace(t), i } static Distance(e, t) { return Math.sqrt(ve.DistanceSquared(e, t)) } static DistanceSquared(e, t) { const i = e.x - t.x, s = e.y - t.y, r = e.z - t.z, n = e.w - t.w; return i * i + s * s + r * r + n * n } static Center(e, t) { return ve.CenterToRef(e, t, ve.Zero()) } static CenterToRef(e, t, i) { return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2, (e.z + t.z) / 2, (e.w + t.w) / 2) } static TransformCoordinates(e, t) { const i = ve.Zero(); return ve.TransformCoordinatesToRef(e, t, i), i } static TransformCoordinatesToRef(e, t, i) { return ve.TransformCoordinatesFromFloatsToRef(e._x, e._y, e._z, t, i), i } static TransformCoordinatesFromFloatsToRef(e, t, i, s, r) { const n = s.m, a = e * n[0] + t * n[4] + i * n[8] + n[12], o = e * n[1] + t * n[5] + i * n[9] + n[13], l = e * n[2] + t * n[6] + i * n[10] + n[14], h = e * n[3] + t * n[7] + i * n[11] + n[15]; return r.x = a, r.y = o, r.z = l, r.w = h, r } static TransformNormal(e, t) { const i = new e.constructor; return ve.TransformNormalToRef(e, t, i), i } static TransformNormalToRef(e, t, i) { const s = t.m, r = e.x * s[0] + e.y * s[4] + e.z * s[8], n = e.x * s[1] + e.y * s[5] + e.z * s[9], a = e.x * s[2] + e.y * s[6] + e.z * s[10]; return i.x = r, i.y = n, i.z = a, i.w = e.w, i } static TransformNormalFromFloatsToRef(e, t, i, s, r, n) { const a = r.m; return n.x = e * a[0] + t * a[4] + i * a[8], n.y = e * a[1] + t * a[5] + i * a[9], n.z = e * a[2] + t * a[6] + i * a[10], n.w = s, n } static FromVector3(e, t = 0) { return new ve(e._x, e._y, e._z, t) } static Dot(e, t) { return e.dot(t) } } ve._ZeroReadOnly = ve.Zero(); class q { get x() { return this._x } set x(e) { this._x = e, this._isDirty = !0 } get y() { return this._y } set y(e) { this._y = e, this._isDirty = !0 } get z() { return this._z } set z(e) { this._z = e, this._isDirty = !0 } get w() { return this._w } set w(e) { this._w = e, this._isDirty = !0 } constructor(e = 0, t = 0, i = 0, s = 1) { this._isDirty = !0, this._x = e, this._y = t, this._z = i, this._w = s } toString() { return `{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}` } getClassName() { return "Quaternion" } getHashCode() { const e = ze(this._x), t = ze(this._y), i = ze(this._z), s = ze(this._w); let r = e; return r = r * 397 ^ t, r = r * 397 ^ i, r = r * 397 ^ s, r } asArray() { return [this._x, this._y, this._z, this._w] } toArray(e, t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, this } equals(e) { return e && this._x === e._x && this._y === e._y && this._z === e._z && this._w === e._w } equalsWithEpsilon(e, t = Ie) { return e && H.WithinEpsilon(this._x, e._x, t) && H.WithinEpsilon(this._y, e._y, t) && H.WithinEpsilon(this._z, e._z, t) && H.WithinEpsilon(this._w, e._w, t) } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copyFrom(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._w = e._w, this._isDirty = !0, this } copyFromFloats(e, t, i, s) { return this._x = e, this._y = t, this._z = i, this._w = s, this._isDirty = !0, this } set(e, t, i, s) { return this.copyFromFloats(e, t, i, s) } add(e) { return new this.constructor(this._x + e._x, this._y + e._y, this._z + e._z, this._w + e._w) } addInPlace(e) { return this._x += e._x, this._y += e._y, this._z += e._z, this._w += e._w, this._isDirty = !0, this } subtract(e) { return new this.constructor(this._x - e._x, this._y - e._y, this._z - e._z, this._w - e._w) } subtractInPlace(e) { return this._x -= e._x, this._y -= e._y, this._z -= e._z, this._w -= e._w, this._isDirty = !0, this } scale(e) { return new this.constructor(this._x * e, this._y * e, this._z * e, this._w * e) } scaleToRef(e, t) { return t._x = this._x * e, t._y = this._y * e, t._z = this._z * e, t._w = this._w * e, t._isDirty = !0, t } scaleInPlace(e) { return this._x *= e, this._y *= e, this._z *= e, this._w *= e, this._isDirty = !0, this } scaleAndAddToRef(e, t) { return t._x += this._x * e, t._y += this._y * e, t._z += this._z * e, t._w += this._w * e, t._isDirty = !0, t } multiply(e) { const t = new this.constructor(0, 0, 0, 1); return this.multiplyToRef(e, t), t } multiplyToRef(e, t) { const i = this._x * e._w + this._y * e._z - this._z * e._y + this._w * e._x, s = -this._x * e._z + this._y * e._w + this._z * e._x + this._w * e._y, r = this._x * e._y - this._y * e._x + this._z * e._w + this._w * e._z, n = -this._x * e._x - this._y * e._y - this._z * e._z + this._w * e._w; return t.copyFromFloats(i, s, r, n), t } multiplyInPlace(e) { return this.multiplyToRef(e, this), this } conjugateToRef(e) { return e.copyFromFloats(-this._x, -this._y, -this._z, this._w), e } conjugateInPlace() { return this._x *= -1, this._y *= -1, this._z *= -1, this._isDirty = !0, this } conjugate() { return new this.constructor(-this._x, -this._y, -this._z, this._w) } invert() { const e = this.conjugate(), t = this.lengthSquared(); return t == 0 || t == 1 || e.scaleInPlace(1 / t), e } invertInPlace() { this.conjugateInPlace(); const e = this.lengthSquared(); return e == 0 || e == 1 ? this : (this.scaleInPlace(1 / e), this) } lengthSquared() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this.lengthSquared()) } normalize() { return this.normalizeFromLength(this.length()) } normalizeFromLength(e) { return e === 0 || e === 1 ? this : this.scaleInPlace(1 / e) } normalizeToNew() { const e = new this.constructor(0, 0, 0, 1); return this.normalizeToRef(e), e } normalizeToRef(e) { const t = this.length(); return t === 0 || t === 1 ? e.copyFromFloats(this._x, this._y, this._z, this._w) : this.scaleToRef(1 / t, e) } toEulerAngles() { const e = g.Zero(); return this.toEulerAnglesToRef(e), e } toEulerAnglesToRef(e) { const t = this._z, i = this._x, s = this._y, r = this._w, n = s * t - i * r, a = .4999999; if (n < -a) e._y = 2 * Math.atan2(s, r), e._x = Math.PI / 2, e._z = 0, e._isDirty = !0; else if (n > a) e._y = 2 * Math.atan2(s, r), e._x = -Math.PI / 2, e._z = 0, e._isDirty = !0; else { const o = r * r, l = t * t, h = i * i, u = s * s; e._z = Math.atan2(2 * (i * s + t * r), -l - h + u + o), e._x = Math.asin(-2 * n), e._y = Math.atan2(2 * (t * i + s * r), l - h - u + o), e._isDirty = !0 } return e } toRotationMatrix(e) { return A.FromQuaternionToRef(this, e), e } fromRotationMatrix(e) { return q.FromRotationMatrixToRef(e, this), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } static FromRotationMatrix(e) { const t = new q; return q.FromRotationMatrixToRef(e, t), t } static FromRotationMatrixToRef(e, t) { const i = e.m, s = i[0], r = i[4], n = i[8], a = i[1], o = i[5], l = i[9], h = i[2], u = i[6], f = i[10], _ = s + o + f; let p; return _ > 0 ? (p = .5 / Math.sqrt(_ + 1), t._w = .25 / p, t._x = (u - l) * p, t._y = (n - h) * p, t._z = (a - r) * p, t._isDirty = !0) : s > o && s > f ? (p = 2 * Math.sqrt(1 + s - o - f), t._w = (u - l) / p, t._x = .25 * p, t._y = (r + a) / p, t._z = (n + h) / p, t._isDirty = !0) : o > f ? (p = 2 * Math.sqrt(1 + o - s - f), t._w = (n - h) / p, t._x = (r + a) / p, t._y = .25 * p, t._z = (l + u) / p, t._isDirty = !0) : (p = 2 * Math.sqrt(1 + f - s - o), t._w = (a - r) / p, t._x = (n + h) / p, t._y = (l + u) / p, t._z = .25 * p, t._isDirty = !0), t } static Dot(e, t) { return e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w } static AreClose(e, t, i = .1) { const s = q.Dot(e, t); return 1 - s * s <= i } static SmoothToRef(e, t, i, s, r) { let n = s === 0 ? 1 : i / s; return n = H.Clamp(n, 0, 1), q.SlerpToRef(e, t, n, r), r } static Zero() { return new q(0, 0, 0, 0) } static Inverse(e) { return new e.constructor(-e._x, -e._y, -e._z, e._w) } static InverseToRef(e, t) { return t.set(-e._x, -e._y, -e._z, e._w), t } static Identity() { return new q(0, 0, 0, 1) } static IsIdentity(e) { return e && e._x === 0 && e._y === 0 && e._z === 0 && e._w === 1 } static RotationAxis(e, t) { return q.RotationAxisToRef(e, t, new q) } static RotationAxisToRef(e, t, i) { const s = Math.sin(t / 2); return e.normalize(), i._w = Math.cos(t / 2), i._x = e._x * s, i._y = e._y * s, i._z = e._z * s, i._isDirty = !0, i } static FromArray(e, t) { return t || (t = 0), new q(e[t], e[t + 1], e[t + 2], e[t + 3]) } static FromArrayToRef(e, t, i) { return i._x = e[t], i._y = e[t + 1], i._z = e[t + 2], i._w = e[t + 3], i._isDirty = !0, i } static FromEulerAngles(e, t, i) { const s = new q; return q.RotationYawPitchRollToRef(t, e, i, s), s } static FromEulerAnglesToRef(e, t, i, s) { return q.RotationYawPitchRollToRef(t, e, i, s), s } static FromEulerVector(e) { const t = new q; return q.RotationYawPitchRollToRef(e._y, e._x, e._z, t), t } static FromEulerVectorToRef(e, t) { return q.RotationYawPitchRollToRef(e._y, e._x, e._z, t), t } static FromUnitVectorsToRef(e, t, i, s = Ie) { const r = g.Dot(e, t) + 1; return r < s ? Math.abs(e.x) > Math.abs(e.z) ? i.set(-e.y, e.x, 0, 0) : i.set(0, -e.z, e.y, 0) : (g.CrossToRef(e, t, D.Vector3[0]), i.set(D.Vector3[0].x, D.Vector3[0].y, D.Vector3[0].z, r)), i.normalize() } static RotationYawPitchRoll(e, t, i) { const s = new q; return q.RotationYawPitchRollToRef(e, t, i, s), s } static RotationYawPitchRollToRef(e, t, i, s) { const r = i * .5, n = t * .5, a = e * .5, o = Math.sin(r), l = Math.cos(r), h = Math.sin(n), u = Math.cos(n), f = Math.sin(a), _ = Math.cos(a); return s._x = _ * h * l + f * u * o, s._y = f * u * l - _ * h * o, s._z = _ * u * o - f * h * l, s._w = _ * u * l + f * h * o, s._isDirty = !0, s } static RotationAlphaBetaGamma(e, t, i) { const s = new q; return q.RotationAlphaBetaGammaToRef(e, t, i, s), s } static RotationAlphaBetaGammaToRef(e, t, i, s) { const r = (i + e) * .5, n = (i - e) * .5, a = t * .5; return s._x = Math.cos(n) * Math.sin(a), s._y = Math.sin(n) * Math.sin(a), s._z = Math.sin(r) * Math.cos(a), s._w = Math.cos(r) * Math.cos(a), s._isDirty = !0, s } static RotationQuaternionFromAxis(e, t, i) { const s = new q(0, 0, 0, 0); return q.RotationQuaternionFromAxisToRef(e, t, i, s), s } static RotationQuaternionFromAxisToRef(e, t, i, s) { const r = B.Matrix[0]; return A.FromXYZAxesToRef(e.normalize(), t.normalize(), i.normalize(), r), q.FromRotationMatrixToRef(r, s), s } static FromLookDirectionLH(e, t) { const i = new q; return q.FromLookDirectionLHToRef(e, t, i), i } static FromLookDirectionLHToRef(e, t, i) { const s = B.Matrix[0]; return A.LookDirectionLHToRef(e, t, s), q.FromRotationMatrixToRef(s, i), i } static FromLookDirectionRH(e, t) { const i = new q; return q.FromLookDirectionRHToRef(e, t, i), i } static FromLookDirectionRHToRef(e, t, i) { const s = B.Matrix[0]; return A.LookDirectionRHToRef(e, t, s), q.FromRotationMatrixToRef(s, i) } static Slerp(e, t, i) { const s = q.Identity(); return q.SlerpToRef(e, t, i, s), s } static SlerpToRef(e, t, i, s) { let r, n, a = e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w, o = !1; if (a < 0 && (o = !0, a = -a), a > .999999) n = 1 - i, r = o ? -i : i; else { const l = Math.acos(a), h = 1 / Math.sin(l); n = Math.sin((1 - i) * l) * h, r = o ? -Math.sin(i * l) * h : Math.sin(i * l) * h } return s._x = n * e._x + r * t._x, s._y = n * e._y + r * t._y, s._z = n * e._z + r * t._z, s._w = n * e._w + r * t._w, s._isDirty = !0, s } static Hermite(e, t, i, s, r) { const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, l = -2 * a + 3 * n, h = a - 2 * n + r, u = a - n, f = e._x * o + i._x * l + t._x * h + s._x * u, _ = e._y * o + i._y * l + t._y * h + s._y * u, p = e._z * o + i._z * l + t._z * h + s._z * u, v = e._w * o + i._w * l + t._w * h + s._w * u; return new e.constructor(f, _, p, v) } static Hermite1stDerivative(e, t, i, s, r) { const n = new e.constructor; return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n } static Hermite1stDerivativeToRef(e, t, i, s, r, n) { const a = r * r; return n._x = (a - r) * 6 * e._x + (3 * a - 4 * r + 1) * t._x + (-a + r) * 6 * i._x + (3 * a - 2 * r) * s._x, n._y = (a - r) * 6 * e._y + (3 * a - 4 * r + 1) * t._y + (-a + r) * 6 * i._y + (3 * a - 2 * r) * s._y, n._z = (a - r) * 6 * e._z + (3 * a - 4 * r + 1) * t._z + (-a + r) * 6 * i._z + (3 * a - 2 * r) * s._z, n._w = (a - r) * 6 * e._w + (3 * a - 4 * r + 1) * t._w + (-a + r) * 6 * i._w + (3 * a - 2 * r) * s._w, n._isDirty = !0, n } static Normalize(e) { const t = q.Zero(); return q.NormalizeToRef(e, t), t } static NormalizeToRef(e, t) { return e.normalizeToRef(t), t } } class A {
        static get Use64Bits() { return Pe.MatrixUse64Bits } get m() { return this._m } markAsUpdated() { this.updateFlag = A._UpdateFlagSeed++, this._isIdentity = !1, this._isIdentity3x2 = !1, this._isIdentityDirty = !0, this._isIdentity3x2Dirty = !0 } _updateIdentityStatus(e, t = !1, i = !1, s = !0) { this._isIdentity = e, this._isIdentity3x2 = e || i, this._isIdentityDirty = this._isIdentity ? !1 : t, this._isIdentity3x2Dirty = this._isIdentity3x2 ? !1 : s } constructor() { this._isIdentity = !1, this._isIdentityDirty = !0, this._isIdentity3x2 = !0, this._isIdentity3x2Dirty = !0, this.updateFlag = -1, Pe.MatrixTrackPrecisionChange && Pe.MatrixTrackedMatrices.push(this), this._m = new Pe.MatrixCurrentType(16), this.markAsUpdated() } isIdentity() { if (this._isIdentityDirty) { this._isIdentityDirty = !1; const e = this._m; this._isIdentity = e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 0 && e[4] === 0 && e[5] === 1 && e[6] === 0 && e[7] === 0 && e[8] === 0 && e[9] === 0 && e[10] === 1 && e[11] === 0 && e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1 } return this._isIdentity } isIdentityAs3x2() { return this._isIdentity3x2Dirty && (this._isIdentity3x2Dirty = !1, this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1 ? this._isIdentity3x2 = !1 : this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0 ? this._isIdentity3x2 = !1 : this._isIdentity3x2 = !0), this._isIdentity3x2 } determinant() { if (this._isIdentity === !0) return 1; const e = this._m, t = e[0], i = e[1], s = e[2], r = e[3], n = e[4], a = e[5], o = e[6], l = e[7], h = e[8], u = e[9], f = e[10], _ = e[11], p = e[12], v = e[13], E = e[14], m = e[15], x = f * m - E * _, C = u * m - v * _, S = u * E - v * f, y = h * m - p * _, b = h * E - f * p, R = h * v - p * u, w = +(a * x - o * C + l * S), N = -(n * x - o * y + l * b), X = +(n * C - a * y + l * R), fe = -(n * S - a * b + o * R); return t * w + i * N + s * X + r * fe } toString() {
            return `{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}
${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}
${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}
${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`
        } toArray() { return this._m } asArray() { return this._m } invert() { return this.invertToRef(this), this } reset() { return A.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this), this._updateIdentityStatus(!1), this } add(e) { const t = new this.constructor; return this.addToRef(e, t), t } addToRef(e, t) { const i = this._m, s = t._m, r = e.m; for (let n = 0; n < 16; n++)s[n] = i[n] + r[n]; return t.markAsUpdated(), t } addToSelf(e) { const t = this._m, i = e.m; for (let s = 0; s < 16; s++)t[s] += i[s]; return this.markAsUpdated(), this } invertToRef(e) { if (this._isIdentity === !0) return A.IdentityToRef(e), e; const t = this._m, i = t[0], s = t[1], r = t[2], n = t[3], a = t[4], o = t[5], l = t[6], h = t[7], u = t[8], f = t[9], _ = t[10], p = t[11], v = t[12], E = t[13], m = t[14], x = t[15], C = _ * x - m * p, S = f * x - E * p, y = f * m - E * _, b = u * x - v * p, R = u * m - _ * v, w = u * E - v * f, N = +(o * C - l * S + h * y), X = -(a * C - l * b + h * R), fe = +(a * S - o * b + h * w), J = -(a * y - o * R + l * w), ae = i * N + s * X + r * fe + n * J; if (ae === 0) return e.copyFrom(this), e; const ee = 1 / ae, Me = l * x - m * h, Ae = o * x - E * h, Se = o * m - E * l, xe = a * x - v * h, Re = a * m - v * l, tt = a * E - v * o, Ze = l * p - _ * h, ft = o * p - f * h, It = o * _ - f * l, Ii = a * p - u * h, Pi = a * _ - u * l, Di = a * f - u * o, Qi = -(s * C - r * S + n * y), Ji = +(i * C - r * b + n * R), es = -(i * S - s * b + n * w), ts = +(i * y - s * R + r * w), is = +(s * Me - r * Ae + n * Se), ss = -(i * Me - r * xe + n * Re), Et = +(i * Ae - s * xe + n * tt), bt = -(i * Se - s * Re + r * tt), Tt = -(s * Ze - r * ft + n * It), xt = +(i * Ze - r * Ii + n * Pi), il = -(i * ft - s * Ii + n * Di), sl = +(i * It - s * Pi + r * Di); return A.FromValuesToRef(N * ee, Qi * ee, is * ee, Tt * ee, X * ee, Ji * ee, ss * ee, xt * ee, fe * ee, es * ee, Et * ee, il * ee, J * ee, ts * ee, bt * ee, sl * ee, e), e } addAtIndex(e, t) { return this._m[e] += t, this.markAsUpdated(), this } multiplyAtIndex(e, t) { return this._m[e] *= t, this.markAsUpdated(), this } setTranslationFromFloats(e, t, i) { return this._m[12] = e, this._m[13] = t, this._m[14] = i, this.markAsUpdated(), this } addTranslationFromFloats(e, t, i) { return this._m[12] += e, this._m[13] += t, this._m[14] += i, this.markAsUpdated(), this } setTranslation(e) { return this.setTranslationFromFloats(e._x, e._y, e._z) } getTranslation() { return new g(this._m[12], this._m[13], this._m[14]) } getTranslationToRef(e) { return e.x = this._m[12], e.y = this._m[13], e.z = this._m[14], e } removeRotationAndScaling() { const e = this.m; return A.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e[12], e[13], e[14], e[15], this), this._updateIdentityStatus(e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1), this } multiply(e) { const t = new this.constructor; return this.multiplyToRef(e, t), t } copyFrom(e) { e.copyToArray(this._m); const t = e; return this.updateFlag = t.updateFlag, this._updateIdentityStatus(t._isIdentity, t._isIdentityDirty, t._isIdentity3x2, t._isIdentity3x2Dirty), this } copyToArray(e, t = 0) { const i = this._m; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], this } multiplyToRef(e, t) { return this._isIdentity ? (t.copyFrom(e), t) : e._isIdentity ? (t.copyFrom(this), t) : (this.multiplyToArray(e, t._m, 0), t.markAsUpdated(), t) } multiplyToArray(e, t, i) { const s = this._m, r = e.m, n = s[0], a = s[1], o = s[2], l = s[3], h = s[4], u = s[5], f = s[6], _ = s[7], p = s[8], v = s[9], E = s[10], m = s[11], x = s[12], C = s[13], S = s[14], y = s[15], b = r[0], R = r[1], w = r[2], N = r[3], X = r[4], fe = r[5], J = r[6], ae = r[7], ee = r[8], Me = r[9], Ae = r[10], Se = r[11], xe = r[12], Re = r[13], tt = r[14], Ze = r[15]; return t[i] = n * b + a * X + o * ee + l * xe, t[i + 1] = n * R + a * fe + o * Me + l * Re, t[i + 2] = n * w + a * J + o * Ae + l * tt, t[i + 3] = n * N + a * ae + o * Se + l * Ze, t[i + 4] = h * b + u * X + f * ee + _ * xe, t[i + 5] = h * R + u * fe + f * Me + _ * Re, t[i + 6] = h * w + u * J + f * Ae + _ * tt, t[i + 7] = h * N + u * ae + f * Se + _ * Ze, t[i + 8] = p * b + v * X + E * ee + m * xe, t[i + 9] = p * R + v * fe + E * Me + m * Re, t[i + 10] = p * w + v * J + E * Ae + m * tt, t[i + 11] = p * N + v * ae + E * Se + m * Ze, t[i + 12] = x * b + C * X + S * ee + y * xe, t[i + 13] = x * R + C * fe + S * Me + y * Re, t[i + 14] = x * w + C * J + S * Ae + y * tt, t[i + 15] = x * N + C * ae + S * Se + y * Ze, this } equals(e) { const t = e; if (!t) return !1; if ((this._isIdentity || t._isIdentity) && !this._isIdentityDirty && !t._isIdentityDirty) return this._isIdentity && t._isIdentity; const i = this.m, s = t.m; return i[0] === s[0] && i[1] === s[1] && i[2] === s[2] && i[3] === s[3] && i[4] === s[4] && i[5] === s[5] && i[6] === s[6] && i[7] === s[7] && i[8] === s[8] && i[9] === s[9] && i[10] === s[10] && i[11] === s[11] && i[12] === s[12] && i[13] === s[13] && i[14] === s[14] && i[15] === s[15] } clone() { const e = new this.constructor; return e.copyFrom(this), e } getClassName() { return "Matrix" } getHashCode() { let e = ze(this._m[0]); for (let t = 1; t < 16; t++)e = e * 397 ^ ze(this._m[t]); return e } decomposeToTransformNode(e) { return e.rotationQuaternion = e.rotationQuaternion || new q, this.decompose(e.scaling, e.rotationQuaternion, e.position) } decompose(e, t, i, s, r = !0) { if (this._isIdentity) return i && i.setAll(0), e && e.setAll(1), t && t.copyFromFloats(0, 0, 0, 1), !0; const n = this._m; if (i && i.copyFromFloats(n[12], n[13], n[14]), e = e || B.Vector3[0], e.x = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]), e.y = Math.sqrt(n[4] * n[4] + n[5] * n[5] + n[6] * n[6]), e.z = Math.sqrt(n[8] * n[8] + n[9] * n[9] + n[10] * n[10]), s) { const a = (r ? s.absoluteScaling.x : s.scaling.x) < 0 ? -1 : 1, o = (r ? s.absoluteScaling.y : s.scaling.y) < 0 ? -1 : 1, l = (r ? s.absoluteScaling.z : s.scaling.z) < 0 ? -1 : 1; e.x *= a, e.y *= o, e.z *= l } else this.determinant() <= 0 && (e.y *= -1); if (e._x === 0 || e._y === 0 || e._z === 0) return t && t.copyFromFloats(0, 0, 0, 1), !1; if (t) { const a = 1 / e._x, o = 1 / e._y, l = 1 / e._z; A.FromValuesToRef(n[0] * a, n[1] * a, n[2] * a, 0, n[4] * o, n[5] * o, n[6] * o, 0, n[8] * l, n[9] * l, n[10] * l, 0, 0, 0, 0, 1, B.Matrix[0]), q.FromRotationMatrixToRef(B.Matrix[0], t) } return !0 } getRow(e) { if (e < 0 || e > 3) return null; const t = e * 4; return new ve(this._m[t + 0], this._m[t + 1], this._m[t + 2], this._m[t + 3]) } getRowToRef(e, t) { if (e >= 0 && e <= 3) { const i = e * 4; t.x = this._m[i + 0], t.y = this._m[i + 1], t.z = this._m[i + 2], t.w = this._m[i + 3] } return t } setRow(e, t) { return this.setRowFromFloats(e, t.x, t.y, t.z, t.w) } transpose() { const e = new this.constructor; return A.TransposeToRef(this, e), e } transposeToRef(e) { return A.TransposeToRef(this, e), e } setRowFromFloats(e, t, i, s, r) { if (e < 0 || e > 3) return this; const n = e * 4; return this._m[n + 0] = t, this._m[n + 1] = i, this._m[n + 2] = s, this._m[n + 3] = r, this.markAsUpdated(), this } scale(e) { const t = new this.constructor; return this.scaleToRef(e, t), t } scaleToRef(e, t) { for (let i = 0; i < 16; i++)t._m[i] = this._m[i] * e; return t.markAsUpdated(), t } scaleAndAddToRef(e, t) { for (let i = 0; i < 16; i++)t._m[i] += this._m[i] * e; return t.markAsUpdated(), t } toNormalMatrix(e) { const t = B.Matrix[0]; this.invertToRef(t), t.transposeToRef(e); const i = e._m; return A.FromValuesToRef(i[0], i[1], i[2], 0, i[4], i[5], i[6], 0, i[8], i[9], i[10], 0, 0, 0, 0, 1, e), e } getRotationMatrix() { const e = new this.constructor; return this.getRotationMatrixToRef(e), e } getRotationMatrixToRef(e) { const t = B.Vector3[0]; if (!this.decompose(t)) return A.IdentityToRef(e), e; const i = this._m, s = 1 / t._x, r = 1 / t._y, n = 1 / t._z; return A.FromValuesToRef(i[0] * s, i[1] * s, i[2] * s, 0, i[4] * r, i[5] * r, i[6] * r, 0, i[8] * n, i[9] * n, i[10] * n, 0, 0, 0, 0, 1, e), e } toggleModelMatrixHandInPlace() { const e = this._m; return e[2] *= -1, e[6] *= -1, e[8] *= -1, e[9] *= -1, e[14] *= -1, this.markAsUpdated(), this } toggleProjectionMatrixHandInPlace() { const e = this._m; return e[8] *= -1, e[9] *= -1, e[10] *= -1, e[11] *= -1, this.markAsUpdated(), this } static FromArray(e, t = 0) { const i = new A; return A.FromArrayToRef(e, t, i), i } static FromArrayToRef(e, t, i) { for (let s = 0; s < 16; s++)i._m[s] = e[s + t]; return i.markAsUpdated(), i } static FromFloat32ArrayToRefScaled(e, t, i, s) { for (let r = 0; r < 16; r++)s._m[r] = e[r + t] * i; return s.markAsUpdated(), s } static get IdentityReadOnly() { return A._IdentityReadOnly } static FromValuesToRef(e, t, i, s, r, n, a, o, l, h, u, f, _, p, v, E, m) { const x = m._m; x[0] = e, x[1] = t, x[2] = i, x[3] = s, x[4] = r, x[5] = n, x[6] = a, x[7] = o, x[8] = l, x[9] = h, x[10] = u, x[11] = f, x[12] = _, x[13] = p, x[14] = v, x[15] = E, m.markAsUpdated() } static FromValues(e, t, i, s, r, n, a, o, l, h, u, f, _, p, v, E) { const m = new A, x = m._m; return x[0] = e, x[1] = t, x[2] = i, x[3] = s, x[4] = r, x[5] = n, x[6] = a, x[7] = o, x[8] = l, x[9] = h, x[10] = u, x[11] = f, x[12] = _, x[13] = p, x[14] = v, x[15] = E, m.markAsUpdated(), m } static Compose(e, t, i) { const s = new A; return A.ComposeToRef(e, t, i, s), s } static ComposeToRef(e, t, i, s) { const r = s._m, n = t._x, a = t._y, o = t._z, l = t._w, h = n + n, u = a + a, f = o + o, _ = n * h, p = n * u, v = n * f, E = a * u, m = a * f, x = o * f, C = l * h, S = l * u, y = l * f, b = e._x, R = e._y, w = e._z; return r[0] = (1 - (E + x)) * b, r[1] = (p + y) * b, r[2] = (v - S) * b, r[3] = 0, r[4] = (p - y) * R, r[5] = (1 - (_ + x)) * R, r[6] = (m + C) * R, r[7] = 0, r[8] = (v + S) * w, r[9] = (m - C) * w, r[10] = (1 - (_ + E)) * w, r[11] = 0, r[12] = i._x, r[13] = i._y, r[14] = i._z, r[15] = 1, s.markAsUpdated(), s } static Identity() { const e = A.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return e._updateIdentityStatus(!0), e } static IdentityToRef(e) { return A.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, e), e._updateIdentityStatus(!0), e } static Zero() { const e = A.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); return e._updateIdentityStatus(!1), e } static RotationX(e) { const t = new A; return A.RotationXToRef(e, t), t } static Invert(e) { const t = new e.constructor; return e.invertToRef(t), t } static RotationXToRef(e, t) { const i = Math.sin(e), s = Math.cos(e); return A.FromValuesToRef(1, 0, 0, 0, 0, s, i, 0, 0, -i, s, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(s === 1 && i === 0), t } static RotationY(e) { const t = new A; return A.RotationYToRef(e, t), t } static RotationYToRef(e, t) { const i = Math.sin(e), s = Math.cos(e); return A.FromValuesToRef(s, 0, -i, 0, 0, 1, 0, 0, i, 0, s, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(s === 1 && i === 0), t } static RotationZ(e) { const t = new A; return A.RotationZToRef(e, t), t } static RotationZToRef(e, t) { const i = Math.sin(e), s = Math.cos(e); return A.FromValuesToRef(s, i, 0, 0, -i, s, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(s === 1 && i === 0), t } static RotationAxis(e, t) { const i = new A; return A.RotationAxisToRef(e, t, i), i } static RotationAxisToRef(e, t, i) { const s = Math.sin(-t), r = Math.cos(-t), n = 1 - r; e.normalize(); const a = i._m; return a[0] = e._x * e._x * n + r, a[1] = e._x * e._y * n - e._z * s, a[2] = e._x * e._z * n + e._y * s, a[3] = 0, a[4] = e._y * e._x * n + e._z * s, a[5] = e._y * e._y * n + r, a[6] = e._y * e._z * n - e._x * s, a[7] = 0, a[8] = e._z * e._x * n - e._y * s, a[9] = e._z * e._y * n + e._x * s, a[10] = e._z * e._z * n + r, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, i.markAsUpdated(), i } static RotationAlignToRef(e, t, i, s = !1) { const r = g.Dot(t, e), n = i._m; if (r < -1 + Ie) n[0] = -1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = s ? 1 : -1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = s ? -1 : 1, n[11] = 0; else { const a = g.Cross(t, e), o = 1 / (1 + r); n[0] = a._x * a._x * o + r, n[1] = a._y * a._x * o - a._z, n[2] = a._z * a._x * o + a._y, n[3] = 0, n[4] = a._x * a._y * o + a._z, n[5] = a._y * a._y * o + r, n[6] = a._z * a._y * o - a._x, n[7] = 0, n[8] = a._x * a._z * o - a._y, n[9] = a._y * a._z * o + a._x, n[10] = a._z * a._z * o + r, n[11] = 0 } return n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, i.markAsUpdated(), i } static RotationYawPitchRoll(e, t, i) { const s = new A; return A.RotationYawPitchRollToRef(e, t, i, s), s } static RotationYawPitchRollToRef(e, t, i, s) { return q.RotationYawPitchRollToRef(e, t, i, B.Quaternion[0]), B.Quaternion[0].toRotationMatrix(s), s } static Scaling(e, t, i) { const s = new A; return A.ScalingToRef(e, t, i, s), s } static ScalingToRef(e, t, i, s) { return A.FromValuesToRef(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1, s), s._updateIdentityStatus(e === 1 && t === 1 && i === 1), s } static Translation(e, t, i) { const s = new A; return A.TranslationToRef(e, t, i, s), s } static TranslationToRef(e, t, i, s) { return A.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, i, 1, s), s._updateIdentityStatus(e === 0 && t === 0 && i === 0), s } static Lerp(e, t, i) { const s = new e.constructor; return A.LerpToRef(e, t, i, s), s } static LerpToRef(e, t, i, s) { const r = s._m, n = e.m, a = t.m; for (let o = 0; o < 16; o++)r[o] = n[o] * (1 - i) + a[o] * i; return s.markAsUpdated(), s } static DecomposeLerp(e, t, i) { const s = new e.constructor; return A.DecomposeLerpToRef(e, t, i, s), s } static DecomposeLerpToRef(e, t, i, s) { const r = B.Vector3[0], n = B.Quaternion[0], a = B.Vector3[1]; e.decompose(r, n, a); const o = B.Vector3[2], l = B.Quaternion[1], h = B.Vector3[3]; t.decompose(o, l, h); const u = B.Vector3[4]; g.LerpToRef(r, o, i, u); const f = B.Quaternion[2]; q.SlerpToRef(n, l, i, f); const _ = B.Vector3[5]; return g.LerpToRef(a, h, i, _), A.ComposeToRef(u, f, _, s), s } static LookAtLH(e, t, i) { const s = new A; return A.LookAtLHToRef(e, t, i, s), s } static LookAtLHToRef(e, t, i, s) { const r = B.Vector3[0], n = B.Vector3[1], a = B.Vector3[2]; t.subtractToRef(e, a), a.normalize(), g.CrossToRef(i, a, r); const o = r.lengthSquared(); o === 0 ? r.x = 1 : r.normalizeFromLength(Math.sqrt(o)), g.CrossToRef(a, r, n), n.normalize(); const l = -g.Dot(r, e), h = -g.Dot(n, e), u = -g.Dot(a, e); return A.FromValuesToRef(r._x, n._x, a._x, 0, r._y, n._y, a._y, 0, r._z, n._z, a._z, 0, l, h, u, 1, s), s } static LookAtRH(e, t, i) { const s = new A; return A.LookAtRHToRef(e, t, i, s), s } static LookAtRHToRef(e, t, i, s) { const r = B.Vector3[0], n = B.Vector3[1], a = B.Vector3[2]; e.subtractToRef(t, a), a.normalize(), g.CrossToRef(i, a, r); const o = r.lengthSquared(); o === 0 ? r.x = 1 : r.normalizeFromLength(Math.sqrt(o)), g.CrossToRef(a, r, n), n.normalize(); const l = -g.Dot(r, e), h = -g.Dot(n, e), u = -g.Dot(a, e); return A.FromValuesToRef(r._x, n._x, a._x, 0, r._y, n._y, a._y, 0, r._z, n._z, a._z, 0, l, h, u, 1, s), s } static LookDirectionLH(e, t) { const i = new A; return A.LookDirectionLHToRef(e, t, i), i } static LookDirectionLHToRef(e, t, i) { const s = B.Vector3[0]; s.copyFrom(e), s.scaleInPlace(-1); const r = B.Vector3[1]; return g.CrossToRef(t, s, r), A.FromValuesToRef(r._x, r._y, r._z, 0, t._x, t._y, t._z, 0, s._x, s._y, s._z, 0, 0, 0, 0, 1, i), i } static LookDirectionRH(e, t) { const i = new A; return A.LookDirectionRHToRef(e, t, i), i } static LookDirectionRHToRef(e, t, i) { const s = B.Vector3[2]; return g.CrossToRef(t, e, s), A.FromValuesToRef(s._x, s._y, s._z, 0, t._x, t._y, t._z, 0, e._x, e._y, e._z, 0, 0, 0, 0, 1, i), i } static OrthoLH(e, t, i, s, r) { const n = new A; return A.OrthoLHToRef(e, t, i, s, n, r), n } static OrthoLHToRef(e, t, i, s, r, n) { const a = i, o = s, l = 2 / e, h = 2 / t, u = 2 / (o - a), f = -(o + a) / (o - a); return A.FromValuesToRef(l, 0, 0, 0, 0, h, 0, 0, 0, 0, u, 0, 0, 0, f, 1, r), n && r.multiplyToRef(Pt, r), r._updateIdentityStatus(l === 1 && h === 1 && u === 1 && f === 0), r } static OrthoOffCenterLH(e, t, i, s, r, n, a) { const o = new A; return A.OrthoOffCenterLHToRef(e, t, i, s, r, n, o, a), o } static OrthoOffCenterLHToRef(e, t, i, s, r, n, a, o) { const l = r, h = n, u = 2 / (t - e), f = 2 / (s - i), _ = 2 / (h - l), p = -(h + l) / (h - l), v = (e + t) / (e - t), E = (s + i) / (i - s); return A.FromValuesToRef(u, 0, 0, 0, 0, f, 0, 0, 0, 0, _, 0, v, E, p, 1, a), o && a.multiplyToRef(Pt, a), a.markAsUpdated(), a } static ObliqueOffCenterLHToRef(e, t, i, s, r, n, a, o, l, h, u) { const f = -a * Math.cos(o), _ = -a * Math.sin(o); return A.TranslationToRef(0, 0, -l, B.Matrix[1]), A.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, f, _, 1, 0, 0, 0, 0, 1, B.Matrix[0]), B.Matrix[1].multiplyToRef(B.Matrix[0], B.Matrix[0]), A.TranslationToRef(0, 0, l, B.Matrix[1]), B.Matrix[0].multiplyToRef(B.Matrix[1], B.Matrix[0]), A.OrthoOffCenterLHToRef(e, t, i, s, r, n, h, u), B.Matrix[0].multiplyToRef(h, h), h } static OrthoOffCenterRH(e, t, i, s, r, n, a) { const o = new A; return A.OrthoOffCenterRHToRef(e, t, i, s, r, n, o, a), o } static OrthoOffCenterRHToRef(e, t, i, s, r, n, a, o) { return A.OrthoOffCenterLHToRef(e, t, i, s, r, n, a, o), a._m[10] *= -1, a } static ObliqueOffCenterRHToRef(e, t, i, s, r, n, a, o, l, h, u) { const f = a * Math.cos(o), _ = a * Math.sin(o); return A.TranslationToRef(0, 0, l, B.Matrix[1]), A.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, f, _, 1, 0, 0, 0, 0, 1, B.Matrix[0]), B.Matrix[1].multiplyToRef(B.Matrix[0], B.Matrix[0]), A.TranslationToRef(0, 0, -l, B.Matrix[1]), B.Matrix[0].multiplyToRef(B.Matrix[1], B.Matrix[0]), A.OrthoOffCenterRHToRef(e, t, i, s, r, n, h, u), B.Matrix[0].multiplyToRef(h, h), h } static PerspectiveLH(e, t, i, s, r, n = 0) { const a = new A, o = i, l = s, h = 2 * o / e, u = 2 * o / t, f = (l + o) / (l - o), _ = -2 * l * o / (l - o), p = Math.tan(n); return A.FromValuesToRef(h, 0, 0, 0, 0, u, 0, p, 0, 0, f, 1, 0, 0, _, 0, a), r && a.multiplyToRef(Pt, a), a._updateIdentityStatus(!1), a } static PerspectiveFovLH(e, t, i, s, r, n = 0, a = !1) { const o = new A; return A.PerspectiveFovLHToRef(e, t, i, s, o, !0, r, n, a), o } static PerspectiveFovLHToRef(e, t, i, s, r, n = !0, a, o = 0, l = !1) { const h = i, u = s, f = 1 / Math.tan(e * .5), _ = n ? f / t : f, p = n ? f : f * t, v = l && h === 0 ? -1 : u !== 0 ? (u + h) / (u - h) : 1, E = l && h === 0 ? 2 * u : u !== 0 ? -2 * u * h / (u - h) : -2 * h, m = Math.tan(o); return A.FromValuesToRef(_, 0, 0, 0, 0, p, 0, m, 0, 0, v, 1, 0, 0, E, 0, r), a && r.multiplyToRef(Pt, r), r._updateIdentityStatus(!1), r } static PerspectiveFovReverseLHToRef(e, t, i, s, r, n = !0, a, o = 0) { const l = 1 / Math.tan(e * .5), h = n ? l / t : l, u = n ? l : l * t, f = Math.tan(o); return A.FromValuesToRef(h, 0, 0, 0, 0, u, 0, f, 0, 0, -i, 1, 0, 0, 1, 0, r), a && r.multiplyToRef(Pt, r), r._updateIdentityStatus(!1), r } static PerspectiveFovRH(e, t, i, s, r, n = 0, a = !1) { const o = new A; return A.PerspectiveFovRHToRef(e, t, i, s, o, !0, r, n, a), o } static PerspectiveFovRHToRef(e, t, i, s, r, n = !0, a, o = 0, l = !1) { const h = i, u = s, f = 1 / Math.tan(e * .5), _ = n ? f / t : f, p = n ? f : f * t, v = l && h === 0 ? 1 : u !== 0 ? -(u + h) / (u - h) : -1, E = l && h === 0 ? 2 * u : u !== 0 ? -2 * u * h / (u - h) : -2 * h, m = Math.tan(o); return A.FromValuesToRef(_, 0, 0, 0, 0, p, 0, m, 0, 0, v, -1, 0, 0, E, 0, r), a && r.multiplyToRef(Pt, r), r._updateIdentityStatus(!1), r } static PerspectiveFovReverseRHToRef(e, t, i, s, r, n = !0, a, o = 0) { const l = 1 / Math.tan(e * .5), h = n ? l / t : l, u = n ? l : l * t, f = Math.tan(o); return A.FromValuesToRef(h, 0, 0, 0, 0, u, 0, f, 0, 0, -i, -1, 0, 0, -1, 0, r), a && r.multiplyToRef(Pt, r), r._updateIdentityStatus(!1), r } static GetFinalMatrix(e, t, i, s, r, n) { const a = e.width, o = e.height, l = e.x, h = e.y, u = A.FromValues(a / 2, 0, 0, 0, 0, -o / 2, 0, 0, 0, 0, n - r, 0, l + a / 2, o / 2 + h, r, 1), f = new t.constructor; return t.multiplyToRef(i, f), f.multiplyToRef(s, f), f.multiplyToRef(u, f) } static GetAsMatrix2x2(e) { const t = e.m, i = [t[0], t[1], t[4], t[5]]; return Pe.MatrixUse64Bits ? i : new Float32Array(i) } static GetAsMatrix3x3(e) { const t = e.m, i = [t[0], t[1], t[2], t[4], t[5], t[6], t[8], t[9], t[10]]; return Pe.MatrixUse64Bits ? i : new Float32Array(i) } static Transpose(e) { const t = new e.constructor; return A.TransposeToRef(e, t), t } static TransposeToRef(e, t) { const i = e.m, s = i[0], r = i[4], n = i[8], a = i[12], o = i[1], l = i[5], h = i[9], u = i[13], f = i[2], _ = i[6], p = i[10], v = i[14], E = i[3], m = i[7], x = i[11], C = i[15], S = t._m; return S[0] = s, S[1] = r, S[2] = n, S[3] = a, S[4] = o, S[5] = l, S[6] = h, S[7] = u, S[8] = f, S[9] = _, S[10] = p, S[11] = v, S[12] = E, S[13] = m, S[14] = x, S[15] = C, t.markAsUpdated(), t._updateIdentityStatus(e._isIdentity, e._isIdentityDirty), t } static Reflection(e) { const t = new A; return A.ReflectionToRef(e, t), t } static ReflectionToRef(e, t) { e.normalize(); const i = e.normal.x, s = e.normal.y, r = e.normal.z, n = -2 * i, a = -2 * s, o = -2 * r; return A.FromValuesToRef(n * i + 1, a * i, o * i, 0, n * s, a * s + 1, o * s, 0, n * r, a * r, o * r + 1, 0, n * e.d, a * e.d, o * e.d, 1, t), t } static FromXYZAxesToRef(e, t, i, s) { return A.FromValuesToRef(e._x, e._y, e._z, 0, t._x, t._y, t._z, 0, i._x, i._y, i._z, 0, 0, 0, 0, 1, s), s } static FromQuaternionToRef(e, t) { const i = e._x * e._x, s = e._y * e._y, r = e._z * e._z, n = e._x * e._y, a = e._z * e._w, o = e._z * e._x, l = e._y * e._w, h = e._y * e._z, u = e._x * e._w; return t._m[0] = 1 - 2 * (s + r), t._m[1] = 2 * (n + a), t._m[2] = 2 * (o - l), t._m[3] = 0, t._m[4] = 2 * (n - a), t._m[5] = 1 - 2 * (r + i), t._m[6] = 2 * (h + u), t._m[7] = 0, t._m[8] = 2 * (o + l), t._m[9] = 2 * (h - u), t._m[10] = 1 - 2 * (s + i), t._m[11] = 0, t._m[12] = 0, t._m[13] = 0, t._m[14] = 0, t._m[15] = 1, t.markAsUpdated(), t }
    } A._UpdateFlagSeed = 0, A._IdentityReadOnly = A.Identity(); class B { } B.Vector3 = Oe.BuildTuple(11, g.Zero), B.Matrix = Oe.BuildTuple(2, A.Identity), B.Quaternion = Oe.BuildTuple(3, q.Zero); class D { } D.Vector2 = Oe.BuildTuple(3, ge.Zero), D.Vector3 = Oe.BuildTuple(13, g.Zero), D.Vector4 = Oe.BuildTuple(3, ve.Zero), D.Quaternion = Oe.BuildTuple(2, q.Zero), D.Matrix = Oe.BuildTuple(8, A.Identity), at("BABYLON.Vector2", ge), at("BABYLON.Vector3", g), at("BABYLON.Vector4", ve), at("BABYLON.Matrix", A); const Pt = A.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1); var dt; (function (c) { c[c.LOCAL = 0] = "LOCAL", c[c.WORLD = 1] = "WORLD", c[c.BONE = 2] = "BONE" })(dt || (dt = {})); class ui { } ui.X = new g(1, 0, 0), ui.Y = new g(0, 1, 0), ui.Z = new g(0, 0, 1); var ns; (function (c) { c[c.X = 0] = "X", c[c.Y = 1] = "Y", c[c.Z = 2] = "Z" })(ns || (ns = {})); function kt(c) { return Math.pow(c, sr) } function Vt(c) { return c <= .04045 ? .0773993808 * c : Math.pow(.947867299 * (c + .055), 2.4) } function Wt(c) { return Math.pow(c, ir) } function Gt(c) { return c <= .0031308 ? 12.92 * c : 1.055 * Math.pow(c, .41666) - .055 } class te { constructor(e = 0, t = 0, i = 0) { this.r = e, this.g = t, this.b = i } toString() { return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}" } getClassName() { return "Color3" } getHashCode() { let e = this.r * 255 | 0; return e = e * 397 ^ (this.g * 255 | 0), e = e * 397 ^ (this.b * 255 | 0), e } toArray(e, t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, this } fromArray(e, t = 0) { return te.FromArrayToRef(e, t, this), this } toColor4(e = 1) { return new de(this.r, this.g, this.b, e) } asArray() { return [this.r, this.g, this.b] } toLuminance() { return this.r * .3 + this.g * .59 + this.b * .11 } multiply(e) { return new te(this.r * e.r, this.g * e.g, this.b * e.b) } multiplyToRef(e, t) { return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, this } equals(e) { return e && this.r === e.r && this.g === e.g && this.b === e.b } equalsFloats(e, t, i) { return this.r === e && this.g === t && this.b === i } scale(e) { return new te(this.r * e, this.g * e, this.b * e) } scaleInPlace(e) { return this.r *= e, this.g *= e, this.b *= e, this } scaleToRef(e, t) { return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, this } scaleAndAddToRef(e, t) { return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, this } clampToRef(e = 0, t = 1, i) { return i.r = H.Clamp(this.r, e, t), i.g = H.Clamp(this.g, e, t), i.b = H.Clamp(this.b, e, t), this } add(e) { return new te(this.r + e.r, this.g + e.g, this.b + e.b) } addToRef(e, t) { return t.r = this.r + e.r, t.g = this.g + e.g, t.b = this.b + e.b, this } subtract(e) { return new te(this.r - e.r, this.g - e.g, this.b - e.b) } subtractToRef(e, t) { return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, this } clone() { return new te(this.r, this.g, this.b) } copyFrom(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copyFromFloats(e, t, i) { return this.r = e, this.g = t, this.b = i, this } set(e, t, i) { return this.copyFromFloats(e, t, i) } toHexString() { const e = Math.round(this.r * 255), t = Math.round(this.g * 255), i = Math.round(this.b * 255); return "#" + H.ToHex(e) + H.ToHex(t) + H.ToHex(i) } toHSV() { const e = new te; return this.toHSVToRef(e), e } toHSVToRef(e) { const t = this.r, i = this.g, s = this.b, r = Math.max(t, i, s), n = Math.min(t, i, s); let a = 0, o = 0; const l = r, h = r - n; r !== 0 && (o = h / r), r != n && (r == t ? (a = (i - s) / h, i < s && (a += 6)) : r == i ? a = (s - t) / h + 2 : r == s && (a = (t - i) / h + 4), a *= 60), e.r = a, e.g = o, e.b = l } toLinearSpace(e = !1) { const t = new te; return this.toLinearSpaceToRef(t, e), t } toLinearSpaceToRef(e, t = !1) { return t ? (e.r = Vt(this.r), e.g = Vt(this.g), e.b = Vt(this.b)) : (e.r = kt(this.r), e.g = kt(this.g), e.b = kt(this.b)), this } toGammaSpace(e = !1) { const t = new te; return this.toGammaSpaceToRef(t, e), t } toGammaSpaceToRef(e, t = !1) { return t ? (e.r = Gt(this.r), e.g = Gt(this.g), e.b = Gt(this.b)) : (e.r = Wt(this.r), e.g = Wt(this.g), e.b = Wt(this.b)), this } static HSVtoRGBToRef(e, t, i, s) { const r = i * t, n = e / 60, a = r * (1 - Math.abs(n % 2 - 1)); let o = 0, l = 0, h = 0; n >= 0 && n <= 1 ? (o = r, l = a) : n >= 1 && n <= 2 ? (o = a, l = r) : n >= 2 && n <= 3 ? (l = r, h = a) : n >= 3 && n <= 4 ? (l = a, h = r) : n >= 4 && n <= 5 ? (o = a, h = r) : n >= 5 && n <= 6 && (o = r, h = a); const u = i - r; s.set(o + u, l + u, h + u) } static FromHSV(e, t, i) { const s = new te(0, 0, 0); return te.HSVtoRGBToRef(e, t, i, s), s } static FromHexString(e) { if (e.substring(0, 1) !== "#" || e.length !== 7) return new te(0, 0, 0); const t = parseInt(e.substring(1, 3), 16), i = parseInt(e.substring(3, 5), 16), s = parseInt(e.substring(5, 7), 16); return te.FromInts(t, i, s) } static FromArray(e, t = 0) { return new te(e[t], e[t + 1], e[t + 2]) } static FromArrayToRef(e, t = 0, i) { i.r = e[t], i.g = e[t + 1], i.b = e[t + 2] } static FromInts(e, t, i) { return new te(e / 255, t / 255, i / 255) } static Lerp(e, t, i) { const s = new te(0, 0, 0); return te.LerpToRef(e, t, i, s), s } static LerpToRef(e, t, i, s) { s.r = e.r + (t.r - e.r) * i, s.g = e.g + (t.g - e.g) * i, s.b = e.b + (t.b - e.b) * i } static Hermite(e, t, i, s, r) { const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, l = -2 * a + 3 * n, h = a - 2 * n + r, u = a - n, f = e.r * o + i.r * l + t.r * h + s.r * u, _ = e.g * o + i.g * l + t.g * h + s.g * u, p = e.b * o + i.b * l + t.b * h + s.b * u; return new te(f, _, p) } static Hermite1stDerivative(e, t, i, s, r) { const n = te.Black(); return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n } static Hermite1stDerivativeToRef(e, t, i, s, r, n) { const a = r * r; n.r = (a - r) * 6 * e.r + (3 * a - 4 * r + 1) * t.r + (-a + r) * 6 * i.r + (3 * a - 2 * r) * s.r, n.g = (a - r) * 6 * e.g + (3 * a - 4 * r + 1) * t.g + (-a + r) * 6 * i.g + (3 * a - 2 * r) * s.g, n.b = (a - r) * 6 * e.b + (3 * a - 4 * r + 1) * t.b + (-a + r) * 6 * i.b + (3 * a - 2 * r) * s.b } static Red() { return new te(1, 0, 0) } static Green() { return new te(0, 1, 0) } static Blue() { return new te(0, 0, 1) } static Black() { return new te(0, 0, 0) } static get BlackReadOnly() { return te._BlackReadOnly } static White() { return new te(1, 1, 1) } static Purple() { return new te(.5, 0, .5) } static Magenta() { return new te(1, 0, 1) } static Yellow() { return new te(1, 1, 0) } static Gray() { return new te(.5, .5, .5) } static Teal() { return new te(0, 1, 1) } static Random() { return new te(Math.random(), Math.random(), Math.random()) } } te._BlackReadOnly = te.Black(); class de { constructor(e = 0, t = 0, i = 0, s = 1) { this.r = e, this.g = t, this.b = i, this.a = s } addInPlace(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this.a += e.a, this } asArray() { return [this.r, this.g, this.b, this.a] } toArray(e, t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e[t + 3] = this.a, this } fromArray(e, t = 0) { return de.FromArrayToRef(e, t, this), this } equals(e) { return e && this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a } add(e) { return new de(this.r + e.r, this.g + e.g, this.b + e.b, this.a + e.a) } subtract(e) { return new de(this.r - e.r, this.g - e.g, this.b - e.b, this.a - e.a) } subtractToRef(e, t) { return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, t.a = this.a - e.a, this } scale(e) { return new de(this.r * e, this.g * e, this.b * e, this.a * e) } scaleInPlace(e) { return this.r *= e, this.g *= e, this.b *= e, this.a *= e, this } scaleToRef(e, t) { return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, t.a = this.a * e, this } scaleAndAddToRef(e, t) { return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, t.a += this.a * e, this } clampToRef(e = 0, t = 1, i) { return i.r = H.Clamp(this.r, e, t), i.g = H.Clamp(this.g, e, t), i.b = H.Clamp(this.b, e, t), i.a = H.Clamp(this.a, e, t), this } multiply(e) { return new de(this.r * e.r, this.g * e.g, this.b * e.b, this.a * e.a) } multiplyToRef(e, t) { return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, t.a = this.a * e.a, t } toString() { return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}" } getClassName() { return "Color4" } getHashCode() { let e = this.r * 255 | 0; return e = e * 397 ^ (this.g * 255 | 0), e = e * 397 ^ (this.b * 255 | 0), e = e * 397 ^ (this.a * 255 | 0), e } clone() { return new de(this.r, this.g, this.b, this.a) } copyFrom(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this } copyFromFloats(e, t, i, s) { return this.r = e, this.g = t, this.b = i, this.a = s, this } set(e, t, i, s) { return this.copyFromFloats(e, t, i, s) } toHexString(e = !1) { const t = Math.round(this.r * 255), i = Math.round(this.g * 255), s = Math.round(this.b * 255); if (e) return "#" + H.ToHex(t) + H.ToHex(i) + H.ToHex(s); const r = Math.round(this.a * 255); return "#" + H.ToHex(t) + H.ToHex(i) + H.ToHex(s) + H.ToHex(r) } toLinearSpace(e = !1) { const t = new de; return this.toLinearSpaceToRef(t, e), t } toLinearSpaceToRef(e, t = !1) { return t ? (e.r = Vt(this.r), e.g = Vt(this.g), e.b = Vt(this.b)) : (e.r = kt(this.r), e.g = kt(this.g), e.b = kt(this.b)), e.a = this.a, this } toGammaSpace(e = !1) { const t = new de; return this.toGammaSpaceToRef(t, e), t } toGammaSpaceToRef(e, t = !1) { return t ? (e.r = Gt(this.r), e.g = Gt(this.g), e.b = Gt(this.b)) : (e.r = Wt(this.r), e.g = Wt(this.g), e.b = Wt(this.b)), e.a = this.a, this } static FromHexString(e) { if (e.substring(0, 1) !== "#" || e.length !== 9 && e.length !== 7) return new de(0, 0, 0, 0); const t = parseInt(e.substring(1, 3), 16), i = parseInt(e.substring(3, 5), 16), s = parseInt(e.substring(5, 7), 16), r = e.length === 9 ? parseInt(e.substring(7, 9), 16) : 255; return de.FromInts(t, i, s, r) } static Lerp(e, t, i) { const s = new de(0, 0, 0, 0); return de.LerpToRef(e, t, i, s), s } static LerpToRef(e, t, i, s) { s.r = e.r + (t.r - e.r) * i, s.g = e.g + (t.g - e.g) * i, s.b = e.b + (t.b - e.b) * i, s.a = e.a + (t.a - e.a) * i } static Hermite(e, t, i, s, r) { const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, l = -2 * a + 3 * n, h = a - 2 * n + r, u = a - n, f = e.r * o + i.r * l + t.r * h + s.r * u, _ = e.g * o + i.g * l + t.g * h + s.g * u, p = e.b * o + i.b * l + t.b * h + s.b * u, v = e.a * o + i.a * l + t.a * h + s.a * u; return new de(f, _, p, v) } static Hermite1stDerivative(e, t, i, s, r) { const n = new de; return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n } static Hermite1stDerivativeToRef(e, t, i, s, r, n) { const a = r * r; n.r = (a - r) * 6 * e.r + (3 * a - 4 * r + 1) * t.r + (-a + r) * 6 * i.r + (3 * a - 2 * r) * s.r, n.g = (a - r) * 6 * e.g + (3 * a - 4 * r + 1) * t.g + (-a + r) * 6 * i.g + (3 * a - 2 * r) * s.g, n.b = (a - r) * 6 * e.b + (3 * a - 4 * r + 1) * t.b + (-a + r) * 6 * i.b + (3 * a - 2 * r) * s.b, n.a = (a - r) * 6 * e.a + (3 * a - 4 * r + 1) * t.a + (-a + r) * 6 * i.a + (3 * a - 2 * r) * s.a } static FromColor3(e, t = 1) { return new de(e.r, e.g, e.b, t) } static FromArray(e, t = 0) { return new de(e[t], e[t + 1], e[t + 2], e[t + 3]) } static FromArrayToRef(e, t = 0, i) { i.r = e[t], i.g = e[t + 1], i.b = e[t + 2], i.a = e[t + 3] } static FromInts(e, t, i, s) { return new de(e / 255, t / 255, i / 255, s / 255) } static CheckColors4(e, t) { if (e.length === t * 3) { const i = []; for (let s = 0; s < e.length; s += 3) { const r = s / 3 * 4; i[r] = e[s], i[r + 1] = e[s + 1], i[r + 2] = e[s + 2], i[r + 3] = 1 } return i } return e } } Oe.BuildArray(3, te.Black), Oe.BuildArray(3, () => new de(0, 0, 0, 0)), at("BABYLON.Color3", te), at("BABYLON.Color4", de); class ot { constructor(e, t, i, s) { this.normal = new g(e, t, i), this.d = s } asArray() { return [this.normal.x, this.normal.y, this.normal.z, this.d] } clone() { return new ot(this.normal.x, this.normal.y, this.normal.z, this.d) } getClassName() { return "Plane" } getHashCode() { let e = this.normal.getHashCode(); return e = e * 397 ^ (this.d | 0), e } normalize() { const e = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z); let t = 0; return e !== 0 && (t = 1 / e), this.normal.x *= t, this.normal.y *= t, this.normal.z *= t, this.d *= t, this } transform(e) { const t = ot._TmpMatrix; e.invertToRef(t); const i = t.m, s = this.normal.x, r = this.normal.y, n = this.normal.z, a = this.d, o = s * i[0] + r * i[1] + n * i[2] + a * i[3], l = s * i[4] + r * i[5] + n * i[6] + a * i[7], h = s * i[8] + r * i[9] + n * i[10] + a * i[11], u = s * i[12] + r * i[13] + n * i[14] + a * i[15]; return new ot(o, l, h, u) } dotCoordinate(e) { return this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z + this.d } copyFromPoints(e, t, i) { const s = t.x - e.x, r = t.y - e.y, n = t.z - e.z, a = i.x - e.x, o = i.y - e.y, l = i.z - e.z, h = r * l - n * o, u = n * a - s * l, f = s * o - r * a, _ = Math.sqrt(h * h + u * u + f * f); let p; return _ !== 0 ? p = 1 / _ : p = 0, this.normal.x = h * p, this.normal.y = u * p, this.normal.z = f * p, this.d = -(this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z), this } isFrontFacingTo(e, t) { return g.Dot(this.normal, e) <= t } signedDistanceTo(e) { return g.Dot(e, this.normal) + this.d } static FromArray(e) { return new ot(e[0], e[1], e[2], e[3]) } static FromPoints(e, t, i) { const s = new ot(0, 0, 0, 0); return s.copyFromPoints(e, t, i), s } static FromPositionAndNormal(e, t) { const i = new ot(0, 0, 0, 0); return this.FromPositionAndNormalToRef(e, t, i) } static FromPositionAndNormalToRef(e, t, i) { return i.normal.copyFrom(t), i.normal.normalize(), i.d = -e.dot(i.normal), i } static SignedDistanceToPlaneFromPositionAndNormal(e, t, i) { const s = -(t.x * e.x + t.y * e.y + t.z * e.z); return g.Dot(i, t) + s } } ot._TmpMatrix = A.Identity(); class it { static GetPlanes(e) { const t = []; for (let i = 0; i < 6; i++)t.push(new ot(0, 0, 0, 0)); return it.GetPlanesToRef(e, t), t } static GetNearPlaneToRef(e, t) { const i = e.m; t.normal.x = i[3] + i[2], t.normal.y = i[7] + i[6], t.normal.z = i[11] + i[10], t.d = i[15] + i[14], t.normalize() } static GetFarPlaneToRef(e, t) { const i = e.m; t.normal.x = i[3] - i[2], t.normal.y = i[7] - i[6], t.normal.z = i[11] - i[10], t.d = i[15] - i[14], t.normalize() } static GetLeftPlaneToRef(e, t) { const i = e.m; t.normal.x = i[3] + i[0], t.normal.y = i[7] + i[4], t.normal.z = i[11] + i[8], t.d = i[15] + i[12], t.normalize() } static GetRightPlaneToRef(e, t) { const i = e.m; t.normal.x = i[3] - i[0], t.normal.y = i[7] - i[4], t.normal.z = i[11] - i[8], t.d = i[15] - i[12], t.normalize() } static GetTopPlaneToRef(e, t) { const i = e.m; t.normal.x = i[3] - i[1], t.normal.y = i[7] - i[5], t.normal.z = i[11] - i[9], t.d = i[15] - i[13], t.normalize() } static GetBottomPlaneToRef(e, t) { const i = e.m; t.normal.x = i[3] + i[1], t.normal.y = i[7] + i[5], t.normal.z = i[11] + i[9], t.d = i[15] + i[13], t.normalize() } static GetPlanesToRef(e, t) { it.GetNearPlaneToRef(e, t[0]), it.GetFarPlaneToRef(e, t[1]), it.GetLeftPlaneToRef(e, t[2]), it.GetRightPlaneToRef(e, t[3]), it.GetTopPlaneToRef(e, t[4]), it.GetBottomPlaneToRef(e, t[5]) } static IsPointInFrustum(e, t) { for (let i = 0; i < 6; i++)if (t[i].dotCoordinate(e) < 0) return !1; return !0 } } var as; (function (c) { c[c.CW = 0] = "CW", c[c.CCW = 1] = "CCW" })(as || (as = {})); class lt { constructor(e, t) { this.width = e, this.height = t } toString() { return `{W: ${this.width}, H: ${this.height}}` } getClassName() { return "Size" } getHashCode() { let e = this.width | 0; return e = e * 397 ^ (this.height | 0), e } copyFrom(e) { this.width = e.width, this.height = e.height } copyFromFloats(e, t) { return this.width = e, this.height = t, this } set(e, t) { return this.copyFromFloats(e, t) } multiplyByFloats(e, t) { return new lt(this.width * e, this.height * t) } clone() { return new lt(this.width, this.height) } equals(e) { return e ? this.width === e.width && this.height === e.height : !1 } get surface() { return this.width * this.height } static Zero() { return new lt(0, 0) } add(e) { return new lt(this.width + e.width, this.height + e.height) } subtract(e) { return new lt(this.width - e.width, this.height - e.height) } scale(e) { return new lt(this.width * e, this.height * e) } static Lerp(e, t, i) { const s = e.width + (t.width - e.width) * i, r = e.height + (t.height - e.height) * i; return new lt(s, r) } } class qt { constructor(e, t, i, s) { this.x = e, this.y = t, this.width = i, this.height = s } toGlobal(e, t) { return new qt(this.x * e, this.y * t, this.width * e, this.height * t) } toGlobalToRef(e, t, i) { return i.x = this.x * e, i.y = this.y * t, i.width = this.width * e, i.height = this.height * t, this } clone() { return new qt(this.x, this.y, this.width, this.height) } } function T(c, e, t, i) { var s = arguments.length, r = s < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, n; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") r = Reflect.decorate(c, e, t, i); else for (var a = c.length - 1; a >= 0; a--)(n = c[a]) && (r = (s < 3 ? n(r) : s > 3 ? n(e, t, r) : n(e, t)) || r); return s > 3 && r && Object.defineProperty(e, t, r), r } class Dt { static Eval(e, t) { return e.match(/\([^()]*\)/g) ? e = e.replace(/\([^()]*\)/g, i => (i = i.slice(1, i.length - 1), Dt._HandleParenthesisContent(i, t))) : e = Dt._HandleParenthesisContent(e, t), e === "true" ? !0 : e === "false" ? !1 : Dt.Eval(e, t) } static _HandleParenthesisContent(e, t) { t = t || (r => r === "true"); let i; const s = e.split("||"); for (const r in s) if (Object.prototype.hasOwnProperty.call(s, r)) { let n = Dt._SimplifyNegation(s[r].trim()); const a = n.split("&&"); if (a.length > 1) for (let o = 0; o < a.length; ++o) { const l = Dt._SimplifyNegation(a[o].trim()); if (l !== "true" && l !== "false" ? l[0] === "!" ? i = !t(l.substring(1)) : i = t(l) : i = l === "true", !i) { n = "false"; break } } if (i || n === "true") { i = !0; break } n !== "true" && n !== "false" ? n[0] === "!" ? i = !t(n.substring(1)) : i = t(n) : i = n === "true" } return i ? "true" : "false" } static _SimplifyNegation(e) { return e = e.replace(/^[\s!]+/, t => (t = t.replace(/[\s]/g, () => ""), t.length % 2 ? "!" : "")), e = e.trim(), e === "!true" ? e = "false" : e === "!false" && (e = "true"), e } } class ne { static EnableFor(e) { e._tags = e._tags || {}, e.hasTags = () => ne.HasTags(e), e.addTags = t => ne.AddTagsTo(e, t), e.removeTags = t => ne.RemoveTagsFrom(e, t), e.matchesTagsQuery = t => ne.MatchesQuery(e, t) } static DisableFor(e) { delete e._tags, delete e.hasTags, delete e.addTags, delete e.removeTags, delete e.matchesTagsQuery } static HasTags(e) { if (!e._tags) return !1; const t = e._tags; for (const i in t) if (Object.prototype.hasOwnProperty.call(t, i)) return !0; return !1 } static GetTags(e, t = !0) { if (!e._tags) return null; if (t) { const i = []; for (const s in e._tags) Object.prototype.hasOwnProperty.call(e._tags, s) && e._tags[s] === !0 && i.push(s); return i.join(" ") } else return e._tags } static AddTagsTo(e, t) { if (!t || typeof t != "string") return; t.split(" ").forEach(function (s) { ne._AddTagTo(e, s) }) } static _AddTagTo(e, t) { t = t.trim(), !(t === "" || t === "true" || t === "false") && (t.match(/[\s]/) || t.match(/^([!]|([|]|[&]){2})/) || (ne.EnableFor(e), e._tags[t] = !0)) } static RemoveTagsFrom(e, t) { if (!ne.HasTags(e)) return; const i = t.split(" "); for (const s in i) ne._RemoveTagFrom(e, i[s]) } static _RemoveTagFrom(e, t) { delete e._tags[t] } static MatchesQuery(e, t) { return t === void 0 ? !0 : t === "" ? ne.HasTags(e) : Dt.Eval(t, i => ne.HasTags(e) && e._tags[i]) } } const os = {}; function K(c, e = !1) { if (!(e && os[c])) return os[c] = !0, `${c} needs to be imported before as it contains a side-effect required by your code.` } const fi = {}, di = {}, ls = function (c, e, t, i = {}) { const s = c(); ne && ne.HasTags(e) && ne.AddTagsTo(s, ne.GetTags(e, !0)); const r = Fi(s), n = {}; for (const a in r) { const o = r[a], l = e[a], h = o.type; if (l != null && (a !== "uniqueId" || re.AllowLoadingUniqueId)) switch (h) { case 0: case 6: case 11: s[a] = l; break; case 1: i.cloneTexturesOnlyOnce && n[l.uniqueId] ? s[a] = n[l.uniqueId] : (s[a] = t || l.isRenderTarget ? l : l.clone(), n[l.uniqueId] = s[a]); break; case 2: case 3: case 4: case 5: case 7: case 10: case 12: s[a] = t ? l : l.clone(); break } } return s }; function hr(c) { const e = c.getClassName(); return fi[e] || (fi[e] = {}), fi[e] } function Fi(c) { const e = c.getClassName(); if (di[e]) return di[e]; di[e] = {}; const t = di[e]; let i = c, s = e; for (; s;) { const r = fi[s]; for (const o in r) t[o] = r[o]; let n, a = !1; do { if (n = Object.getPrototypeOf(i), !n.getClassName) { a = !0; break } if (n.getClassName() !== s) break; i = n } while (n); if (a) break; s = n.getClassName(), i = n } return t } function At(c, e) { return (t, i) => { const s = hr(t); s[i] || (s[i] = { type: c, sourceName: e }) } } function cr(c, e = null) { return (t, i) => { const s = e || "_" + i; Object.defineProperty(t, i, { get: function () { return this[s] }, set: function (r) { typeof this.equals == "function" && this.equals(r) || this[s] !== r && (this[s] = r, t[c].apply(this)) }, enumerable: !0, configurable: !0 }) } } function ue(c, e = null) { return cr(c, e) } function M(c) { return At(0, c) } function st(c) { return At(1, c) } function _i(c) { return At(2, c) } function jt(c) { return At(3, c) } function Zt(c) { return At(5, c) } function ur(c) { return At(7, c) } function fr(c) { return At(8, c) } function dr(c) { return At(10, c) } class re { static AppendSerializedAnimations(e, t) { if (e.animations) { t.animations = []; for (let i = 0; i < e.animations.length; i++) { const s = e.animations[i]; t.animations.push(s.serialize()) } } } static Serialize(e, t) { t || (t = {}), ne && (t.tags = ne.GetTags(e)); const i = Fi(e); for (const s in i) { const r = i[s], n = r.sourceName || s, a = r.type, o = e[s]; if (o != null && (s !== "uniqueId" || re.AllowLoadingUniqueId)) switch (a) { case 0: t[n] = o; break; case 1: t[n] = o.serialize(); break; case 2: t[n] = o.asArray(); break; case 3: t[n] = o.serialize(); break; case 4: t[n] = o.asArray(); break; case 5: t[n] = o.asArray(); break; case 6: t[n] = o.id; break; case 7: t[n] = o.serialize(); break; case 8: t[n] = o.asArray(); break; case 9: t[n] = o.serialize(); break; case 10: t[n] = o.asArray(); break; case 11: t[n] = o.id; break; case 12: t[n] = o.asArray(); break } } return t } static ParseProperties(e, t, i, s) { s || (s = ""); const r = Fi(t); for (const n in r) { const a = r[n], o = e[a.sourceName || n], l = a.type; if (o != null && (n !== "uniqueId" || re.AllowLoadingUniqueId)) { const h = t; switch (l) { case 0: h[n] = o; break; case 1: i && (h[n] = re._TextureParser(o, i, s)); break; case 2: h[n] = te.FromArray(o); break; case 3: h[n] = re._FresnelParametersParser(o); break; case 4: h[n] = ge.FromArray(o); break; case 5: h[n] = g.FromArray(o); break; case 6: i && (h[n] = i.getLastMeshById(o)); break; case 7: h[n] = re._ColorCurvesParser(o); break; case 8: h[n] = de.FromArray(o); break; case 9: h[n] = re._ImageProcessingConfigurationParser(o); break; case 10: h[n] = q.FromArray(o); break; case 11: i && (h[n] = i.getCameraById(o)); break; case 12: h[n] = A.FromArray(o); break } } } } static Parse(e, t, i, s = null) { const r = e(); return ne && ne.AddTagsTo(r, t.tags), re.ParseProperties(t, r, i, s), r } static Clone(e, t, i = {}) { return ls(e, t, !1, i) } static Instanciate(e, t) { return ls(e, t, !0) } } re.AllowLoadingUniqueId = !1, re._ImageProcessingConfigurationParser = c => { throw K("ImageProcessingConfiguration") }, re._FresnelParametersParser = c => { throw K("FresnelParameters") }, re._ColorCurvesParser = c => { throw K("ColorCurves") }, re._TextureParser = (c, e, t) => { throw K("Texture") }; function St(c, e, t, i) { const s = t.value; t.value = (...r) => { let n = s; if (typeof _native < "u" && _native[e]) { const a = _native[e]; i ? n = (...o) => i(...o) ? a(...o) : s(...o) : n = a } return c[e] = n, n(...r) } } St.filter = function (c) { return (e, t, i) => St(e, t, i, c) }; class He { constructor(e) { this.length = 0, this.data = new Array(e), this._id = He._GlobalId++ } push(e) { this.data[this.length++] = e, this.length > this.data.length && (this.data.length *= 2) } forEach(e) { for (let t = 0; t < this.length; t++)e(this.data[t]) } sort(e) { this.data.sort(e) } reset() { this.length = 0 } dispose() { this.reset(), this.data && (this.data.length = 0) } concat(e) { if (e.length !== 0) { this.length + e.length > this.data.length && (this.data.length = (this.length + e.length) * 2); for (let t = 0; t < e.length; t++)this.data[this.length++] = (e.data || e)[t] } } indexOf(e) { const t = this.data.indexOf(e); return t >= this.length ? -1 : t } contains(e) { return this.indexOf(e) !== -1 } } He._GlobalId = 0; class Ft extends He { constructor() { super(...arguments), this._duplicateId = 0 } push(e) { super.push(e), e.__smartArrayFlags || (e.__smartArrayFlags = {}), e.__smartArrayFlags[this._id] = this._duplicateId } pushNoDuplicate(e) { return e.__smartArrayFlags && e.__smartArrayFlags[this._id] === this._duplicateId ? !1 : (this.push(e), !0) } reset() { super.reset(), this._duplicateId++ } concatWithNoDuplicate(e) { if (e.length !== 0) { this.length + e.length > this.data.length && (this.data.length = (this.length + e.length) * 2); for (let t = 0; t < e.length; t++) { const i = (e.data || e)[t]; this.pushNoDuplicate(i) } } } } function Fe() { return typeof window < "u" } function $t() { return typeof navigator < "u" } function Qt() { return typeof document < "u" } function hs(c) { let e = "", t = c.firstChild; for (; t;)t.nodeType === 3 && (e += t.textContent), t = t.nextSibling; return e } class O { static _CheckLimit(e, t) { let i = O._LogLimitOutputs[e]; return i ? i.current++ : (i = { limit: t, current: 1 }, O._LogLimitOutputs[e] = i), i.current <= i.limit } static _GenerateLimitMessage(e, t = 1) { var i; const s = O._LogLimitOutputs[e]; if (!s || !O.MessageLimitReached) return; const r = this._Levels[t]; s.current === s.limit && O[r.name](O.MessageLimitReached.replace(/%LIMIT%/g, "" + s.limit).replace(/%TYPE%/g, (i = r.name) !== null && i !== void 0 ? i : "")) } static _AddLogEntry(e) { O._LogCache = e + O._LogCache, O.OnNewCacheEntry && O.OnNewCacheEntry(e) } static _FormatMessage(e) { const t = s => s < 10 ? "0" + s : "" + s, i = new Date; return "[" + t(i.getHours()) + ":" + t(i.getMinutes()) + ":" + t(i.getSeconds()) + "]: " + e } static _LogDisabled(e, t) { } static _LogEnabled(e = 1, t, i) { if (i !== void 0 && !O._CheckLimit(t, i)) return; const s = O._FormatMessage(t), r = this._Levels[e]; r.logFunc && r.logFunc("BJS - " + s); const n = `<div style='color:${r.color}'>${s}</div><br>`; O._AddLogEntry(n), O._GenerateLimitMessage(t, e) } static get LogCache() { return O._LogCache } static ClearLogCache() { O._LogCache = "", O._LogLimitOutputs = {}, O.errorsCount = 0 } static set LogLevels(e) { O.Log = O._LogDisabled, O.Warn = O._LogDisabled, O.Error = O._LogDisabled, [O.MessageLogLevel, O.WarningLogLevel, O.ErrorLogLevel].forEach(t => { if ((e & t) === t) { const i = this._Levels[t]; O[i.name] = O._LogEnabled.bind(O, t) } }) } } O.NoneLogLevel = 0, O.MessageLogLevel = 1, O.WarningLogLevel = 2, O.ErrorLogLevel = 4, O.AllLogLevel = 7, O.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.", O._LogCache = "", O._LogLimitOutputs = {}, O._Levels = [{}, { color: "white", logFunc: console.log, name: "Log" }, { color: "orange", logFunc: console.warn, name: "Warn" }, {}, { color: "red", logFunc: console.error, name: "Error" }], O.errorsCount = 0, O.Log = O._LogEnabled.bind(O, O.MessageLogLevel), O.Warn = O._LogEnabled.bind(O, O.WarningLogLevel), O.Error = O._LogEnabled.bind(O, O.ErrorLogLevel); const cs = (c, e, t) => !c || c.getClassName && c.getClassName() === "Mesh" ? null : c.getClassName && (c.getClassName() === "SubMesh" || c.getClassName() === "PhysicsBody") ? c.clone(e) : c.clone ? c.clone() : Array.isArray(c) ? c.slice() : t && typeof c == "object" ? Object.assign({}, c) : null; function _r(c) { const e = []; do Object.getOwnPropertyNames(c).forEach(function (t) { e.indexOf(t) === -1 && e.push(t) }); while (c = Object.getPrototypeOf(c)); return e } class us { static DeepCopy(e, t, i, s, r = !1) { const n = _r(e); for (const a of n) { if (a[0] === "_" && (!s || s.indexOf(a) === -1) || a.endsWith("Observable") || i && i.indexOf(a) !== -1) continue; const o = e[a], l = typeof o; if (l !== "function") try { if (l === "object") if (o instanceof Uint8Array) t[a] = Uint8Array.from(o); else if (o instanceof Array) { if (t[a] = [], o.length > 0) if (typeof o[0] == "object") for (let h = 0; h < o.length; h++) { const u = cs(o[h], t, r); t[a].indexOf(u) === -1 && t[a].push(u) } else t[a] = o.slice(0) } else t[a] = cs(o, t, r); else t[a] = o } catch (h) { O.Warn(h.message) } } } } class wt { static get Now() { return Fe() && window.performance && window.performance.now ? window.performance.now() : Date.now() } } function gr() { return typeof _native < "u" && _native.XMLHttpRequest ? new _native.XMLHttpRequest : new XMLHttpRequest } class ke { constructor() { this._xhr = gr(), this._requestURL = "" } static get IsCustomRequestAvailable() { return Object.keys(ke.CustomRequestHeaders).length > 0 || ke.CustomRequestModifiers.length > 0 } _injectCustomRequestHeaders() { if (!this._shouldSkipRequestModifications(this._requestURL)) for (const e in ke.CustomRequestHeaders) { const t = ke.CustomRequestHeaders[e]; t && this._xhr.setRequestHeader(e, t) } } _shouldSkipRequestModifications(e) { return ke.SkipRequestModificationForBabylonCDN && (e.includes("preview.babylonjs.com") || e.includes("cdn.babylonjs.com")) } get onprogress() { return this._xhr.onprogress } set onprogress(e) { this._xhr.onprogress = e } get readyState() { return this._xhr.readyState } get status() { return this._xhr.status } get statusText() { return this._xhr.statusText } get response() { return this._xhr.response } get responseURL() { return this._xhr.responseURL } get responseText() { return this._xhr.responseText } get responseType() { return this._xhr.responseType } set responseType(e) { this._xhr.responseType = e } get timeout() { return this._xhr.timeout } set timeout(e) { this._xhr.timeout = e } addEventListener(e, t, i) { this._xhr.addEventListener(e, t, i) } removeEventListener(e, t, i) { this._xhr.removeEventListener(e, t, i) } abort() { this._xhr.abort() } send(e) { ke.CustomRequestHeaders && this._injectCustomRequestHeaders(), this._xhr.send(e) } open(e, t) { for (const i of ke.CustomRequestModifiers) { if (this._shouldSkipRequestModifications(t)) return; i(this._xhr, t) } return t = t.replace("file:http:", "http:"), t = t.replace("file:https:", "https:"), this._requestURL = t, this._xhr.open(e, t, !0) } setRequestHeader(e, t) { this._xhr.setRequestHeader(e, t) } getResponseHeader(e) { return this._xhr.getResponseHeader(e) } } ke.CustomRequestHeaders = {}, ke.CustomRequestModifiers = new Array, ke.SkipRequestModificationForBabylonCDN = !0; class Jt { } Jt.FilesToLoad = {}; class mr { static ExponentialBackoff(e = 3, t = 500) { return (i, s, r) => s.status !== 0 || r >= e || i.indexOf("file:") !== -1 ? -1 : Math.pow(2, r) * t } } class Xt extends Error { } Xt._setPrototypeOf = Object.setPrototypeOf || ((c, e) => (c.__proto__ = e, c)); const gi = { MeshInvalidPositionsError: 0, UnsupportedTextureError: 1e3, GLTFLoaderUnexpectedMagicError: 2e3, SceneLoaderError: 3e3, LoadFileError: 4e3, RequestFileError: 4001, ReadFileError: 4002 }; class zt extends Xt { constructor(e, t, i) { super(e), this.errorCode = t, this.innerError = i, this.name = "RuntimeError", Xt._setPrototypeOf(this, zt.prototype) } } const fs = c => { const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; let t = "", i, s, r, n, a, o, l, h = 0; const u = ArrayBuffer.isView(c) ? new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : new Uint8Array(c); for (; h < u.length;)i = u[h++], s = h < u.length ? u[h++] : Number.NaN, r = h < u.length ? u[h++] : Number.NaN, n = i >> 2, a = (i & 3) << 4 | s >> 4, o = (s & 15) << 2 | r >> 6, l = r & 63, isNaN(s) ? o = l = 64 : isNaN(r) && (l = 64), t += e.charAt(n) + e.charAt(a) + e.charAt(o) + e.charAt(l); return t }, ds = c => atob(c), pr = c => { const e = ds(c), t = e.length, i = new Uint8Array(new ArrayBuffer(t)); for (let s = 0; s < t; s++)i[s] = e.charCodeAt(s); return i.buffer }, vr = "attribute", Er = "varying"; class ei {
        constructor() { this.children = [] } isValid(e) { return !0 } process(e, t) {
            var i, s, r, n, a, o, l; let h = ""; if (this.line) {
                let u = this.line; const f = t.processor; if (f) { f.lineProcessor && (u = f.lineProcessor(u, t.isFragment, t.processingContext)); const _ = (s = (i = t.processor) === null || i === void 0 ? void 0 : i.attributeKeywordName) !== null && s !== void 0 ? s : vr, p = t.isFragment && (!((r = t.processor) === null || r === void 0) && r.varyingFragmentKeywordName) ? (n = t.processor) === null || n === void 0 ? void 0 : n.varyingFragmentKeywordName : !t.isFragment && (!((a = t.processor) === null || a === void 0) && a.varyingVertexKeywordName) ? (o = t.processor) === null || o === void 0 ? void 0 : o.varyingVertexKeywordName : Er; !t.isFragment && f.attributeProcessor && this.line.startsWith(_) ? u = f.attributeProcessor(this.line, e, t.processingContext) : f.varyingProcessor && (!((l = f.varyingCheck) === null || l === void 0) && l.call(f, this.line, t.isFragment) || !f.varyingCheck && this.line.startsWith(p)) ? u = f.varyingProcessor(this.line, t.isFragment, e, t.processingContext) : f.uniformProcessor && f.uniformRegexp && f.uniformRegexp.test(this.line) ? t.lookForClosingBracketForUniformBuffer || (u = f.uniformProcessor(this.line, t.isFragment, e, t.processingContext)) : f.uniformBufferProcessor && f.uniformBufferRegexp && f.uniformBufferRegexp.test(this.line) ? t.lookForClosingBracketForUniformBuffer || (u = f.uniformBufferProcessor(this.line, t.isFragment, t.processingContext), t.lookForClosingBracketForUniformBuffer = !0) : f.textureProcessor && f.textureRegexp && f.textureRegexp.test(this.line) ? u = f.textureProcessor(this.line, t.isFragment, e, t.processingContext) : (f.uniformProcessor || f.uniformBufferProcessor) && this.line.startsWith("uniform") && !t.lookForClosingBracketForUniformBuffer && (/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line) ? f.uniformProcessor && (u = f.uniformProcessor(this.line, t.isFragment, e, t.processingContext)) : f.uniformBufferProcessor && (u = f.uniformBufferProcessor(this.line, t.isFragment, t.processingContext), t.lookForClosingBracketForUniformBuffer = !0)), t.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1 && (t.lookForClosingBracketForUniformBuffer = !1, f.endOfUniformBufferProcessor && (u = f.endOfUniformBufferProcessor(this.line, t.isFragment, t.processingContext))) } h += u + `
`} return this.children.forEach(u => { h += u.process(e, t) }), this.additionalDefineKey && (e[this.additionalDefineKey] = this.additionalDefineValue || "true"), h
        }
    } class br { constructor() { this._lines = [] } get currentLine() { return this._lines[this.lineIndex] } get canRead() { return this.lineIndex < this._lines.length - 1 } set lines(e) { this._lines.length = 0; for (const t of e) { if (!t || t === "\r") continue; if (t[0] === "#") { this._lines.push(t); continue } const i = t.trim(); if (!i) continue; if (i.startsWith("//")) { this._lines.push(t); continue } const s = i.indexOf(";"); if (s === -1) this._lines.push(i); else if (s === i.length - 1) i.length > 1 && this._lines.push(i); else { const r = t.split(";"); for (let n = 0; n < r.length; n++) { let a = r[n]; a && (a = a.trim(), a && this._lines.push(a + (n !== r.length - 1 ? ";" : ""))) } } } } } class wi extends ei { process(e, t) { for (let i = 0; i < this.children.length; i++) { const s = this.children[i]; if (s.isValid(e)) return s.process(e, t) } return "" } } class Tr extends ei { isValid(e) { return this.testExpression.isTrue(e) } } class Ee { isTrue(e) { return !0 } static postfixToInfix(e) { const t = []; for (const i of e) if (Ee._OperatorPriority[i] === void 0) t.push(i); else { const s = t[t.length - 1], r = t[t.length - 2]; t.length -= 2, t.push(`(${r}${i}${s})`) } return t[t.length - 1] } static infixToPostfix(e) { const t = Ee._InfixToPostfixCache.get(e); if (t) return t.accessTime = Date.now(), t.result; if (!e.includes("&&") && !e.includes("||") && !e.includes(")") && !e.includes("(")) return [e]; const i = []; let s = -1; const r = () => { h = h.trim(), h !== "" && (i.push(h), h = "") }, n = u => { s < Ee._Stack.length - 1 && (Ee._Stack[++s] = u) }, a = () => Ee._Stack[s], o = () => s === -1 ? "!!INVALID EXPRESSION!!" : Ee._Stack[s--]; let l = 0, h = ""; for (; l < e.length;) { const u = e.charAt(l), f = l < e.length - 1 ? e.substr(l, 2) : ""; if (u === "(") h = "", n(u); else if (u === ")") { for (r(); s !== -1 && a() !== "(";)i.push(o()); o() } else if (Ee._OperatorPriority[f] > 1) { for (r(); s !== -1 && Ee._OperatorPriority[a()] >= Ee._OperatorPriority[f];)i.push(o()); n(f), l++ } else h += u; l++ } for (r(); s !== -1;)a() === "(" ? o() : i.push(o()); return Ee._InfixToPostfixCache.size >= Ee.InfixToPostfixCacheLimitSize && Ee.ClearCache(), Ee._InfixToPostfixCache.set(e, { result: i, accessTime: Date.now() }), i } static ClearCache() { const e = Array.from(Ee._InfixToPostfixCache.entries()).sort((t, i) => t[1].accessTime - i[1].accessTime); for (let t = 0; t < Ee.InfixToPostfixCacheCleanupSize; t++)Ee._InfixToPostfixCache.delete(e[t][0]) } } Ee.InfixToPostfixCacheLimitSize = 5e4, Ee.InfixToPostfixCacheCleanupSize = 25e3, Ee._InfixToPostfixCache = new Map, Ee._OperatorPriority = { ")": 0, "(": 1, "||": 2, "&&": 3 }, Ee._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]; class mi extends Ee { constructor(e, t = !1) { super(), this.define = e, this.not = t } isTrue(e) { let t = e[this.define] !== void 0; return this.not && (t = !t), t } } class xr extends Ee { isTrue(e) { return this.leftOperand.isTrue(e) || this.rightOperand.isTrue(e) } } class Ar extends Ee { isTrue(e) { return this.leftOperand.isTrue(e) && this.rightOperand.isTrue(e) } } class Sr extends Ee { constructor(e, t, i) { super(), this.define = e, this.operand = t, this.testValue = i } isTrue(e) { let t = e[this.define]; t === void 0 && (t = this.define); let i = !1; const s = parseInt(t), r = parseInt(this.testValue); switch (this.operand) { case ">": i = s > r; break; case "<": i = s < r; break; case "<=": i = s <= r; break; case ">=": i = s >= r; break; case "==": i = s === r; break; case "!=": i = s !== r; break }return i } } var we; (function (c) { c[c.GLSL = 0] = "GLSL", c[c.WGSL = 1] = "WGSL" })(we || (we = {})); const Rr = /defined\s*?\((.+?)\)/g, Oi = /defined\s*?\[(.+?)\]/g, yr = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g, Mr = /__decl__/, _s = /light\{X\}.(\w*)/g, gs = /\{X\}/g, pi = []; class ht {
        static Initialize(e) { e.processor && e.processor.initializeShaders && e.processor.initializeShaders(e.processingContext) } static Process(e, t, i, s) { var r; !((r = t.processor) === null || r === void 0) && r.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)), this._ProcessIncludes(e, t, n => { t.processCodeAfterIncludes && (n = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", n)); const a = this._ProcessShaderConversion(n, t, s); i(a, n) }) } static PreProcess(e, t, i, s) { var r; !((r = t.processor) === null || r === void 0) && r.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)), this._ProcessIncludes(e, t, n => { t.processCodeAfterIncludes && (n = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", n)); const a = this._ApplyPreProcessing(n, t, s); i(a, n) }) } static Finalize(e, t, i) { return !i.processor || !i.processor.finalizeShaders ? { vertexCode: e, fragmentCode: t } : i.processor.finalizeShaders(e, t, i.processingContext) } static _ProcessPrecision(e, t) {
            var i; if (!((i = t.processor) === null || i === void 0) && i.noPrecision) return e; const s = t.shouldUseHighPrecisionShader; return e.indexOf("precision highp float") === -1 ? s ? e = `precision highp float;
`+ e : e = `precision mediump float;
`+ e : s || (e = e.replace("precision highp float", "precision mediump float")), e
        } static _ExtractOperation(e) { const i = /defined\((.+)\)/.exec(e); if (i && i.length) return new mi(i[1].trim(), e[0] === "!"); const s = ["==", "!=", ">=", "<=", "<", ">"]; let r = "", n = 0; for (r of s) if (n = e.indexOf(r), n > -1) break; if (n === -1) return new mi(e); const a = e.substring(0, n).trim(), o = e.substring(n + r.length).trim(); return new Sr(a, r, o) } static _BuildSubExpression(e) { e = e.replace(Rr, "defined[$1]"); const t = Ee.infixToPostfix(e), i = []; for (const r of t) if (r !== "||" && r !== "&&") i.push(r); else if (i.length >= 2) { let n = i[i.length - 1], a = i[i.length - 2]; i.length -= 2; const o = r == "&&" ? new Ar : new xr; typeof n == "string" && (n = n.replace(Oi, "defined($1)")), typeof a == "string" && (a = a.replace(Oi, "defined($1)")), o.leftOperand = typeof a == "string" ? this._ExtractOperation(a) : a, o.rightOperand = typeof n == "string" ? this._ExtractOperation(n) : n, i.push(o) } let s = i[i.length - 1]; return typeof s == "string" && (s = s.replace(Oi, "defined($1)")), typeof s == "string" ? this._ExtractOperation(s) : s } static _BuildExpression(e, t) { const i = new Tr, s = e.substring(0, t); let r = e.substring(t); return r = r.substring(0, (r.indexOf("//") + 1 || r.length + 1) - 1).trim(), s === "#ifdef" ? i.testExpression = new mi(r) : s === "#ifndef" ? i.testExpression = new mi(r, !0) : i.testExpression = this._BuildSubExpression(r), i } static _MoveCursorWithinIf(e, t, i) { let s = e.currentLine; for (; this._MoveCursor(e, i);) { s = e.currentLine; const r = s.substring(0, 5).toLowerCase(); if (r === "#else") { const n = new ei; t.children.push(n), this._MoveCursor(e, n); return } else if (r === "#elif") { const n = this._BuildExpression(s, 5); t.children.push(n), i = n } } } static _MoveCursor(e, t) { for (; e.canRead;) { e.lineIndex++; const i = e.currentLine; if (i.indexOf("#") >= 0) { const r = ht._MoveCursorRegex.exec(i); if (r && r.length) { switch (r[0]) { case "#ifdef": { const a = new wi; t.children.push(a); const o = this._BuildExpression(i, 6); a.children.push(o), this._MoveCursorWithinIf(e, a, o); break } case "#else": case "#elif": return !0; case "#endif": return !1; case "#ifndef": { const a = new wi; t.children.push(a); const o = this._BuildExpression(i, 7); a.children.push(o), this._MoveCursorWithinIf(e, a, o); break } case "#if": { const a = new wi, o = this._BuildExpression(i, 3); t.children.push(a), a.children.push(o), this._MoveCursorWithinIf(e, a, o); break } }continue } } const s = new ei; if (s.line = i, t.children.push(s), i[0] === "#" && i[1] === "d") { const r = i.replace(";", "").split(" "); s.additionalDefineKey = r[1], r.length === 3 && (s.additionalDefineValue = r[2]) } } return !1 } static _EvaluatePreProcessors(e, t, i) {
            const s = new ei, r = new br; return r.lineIndex = -1, r.lines = e.split(`
`), this._MoveCursor(r, s), s.process(t, i)
        } static _PreparePreProcessors(e, t) { var i; const s = e.defines, r = {}; for (const n of s) { const o = n.replace("#define", "").replace(";", "").trim().split(" "); r[o[0]] = o.length > 1 ? o[1] : "" } return ((i = e.processor) === null || i === void 0 ? void 0 : i.shaderLanguage) === we.GLSL && (r.GL_ES = "true"), r.__VERSION__ = e.version, r[e.platformName] = "true", t._getGlobalDefines(r), r } static _ProcessShaderConversion(e, t, i) { let s = this._ProcessPrecision(e, t); if (!t.processor || t.processor.shaderLanguage === we.GLSL && s.indexOf("#version 3") !== -1 && (s = s.replace("#version 300 es", ""), !t.processor.parseGLES3)) return s; const r = t.defines, n = this._PreparePreProcessors(t, i); return t.processor.preProcessor && (s = t.processor.preProcessor(s, r, t.isFragment, t.processingContext)), s = this._EvaluatePreProcessors(s, n, t), t.processor.postProcessor && (s = t.processor.postProcessor(s, r, t.isFragment, t.processingContext, i)), i._features.needShaderCodeInlining && (s = i.inlineShaderCode(s)), s } static _ApplyPreProcessing(e, t, i) { var s, r; let n = e; const a = t.defines, o = this._PreparePreProcessors(t, i); return !((s = t.processor) === null || s === void 0) && s.preProcessor && (n = t.processor.preProcessor(n, a, t.isFragment, t.processingContext)), n = this._EvaluatePreProcessors(n, o, t), !((r = t.processor) === null || r === void 0) && r.postProcessor && (n = t.processor.postProcessor(n, a, t.isFragment, t.processingContext, i)), i._features.needShaderCodeInlining && (n = i.inlineShaderCode(n)), n } static _ProcessIncludes(e, t, i) {
            pi.length = 0; let s; for (; (s = yr.exec(e)) !== null;)pi.push(s); let r = String(e), n = [e], a = !1; for (const o of pi) {
                let l = o[1]; if (l.indexOf("__decl__") !== -1 && (l = l.replace(Mr, ""), t.supportsUniformBuffers && (l = l.replace("Vertex", "Ubo").replace("Fragment", "Ubo")), l = l + "Declaration"), t.includesShadersStore[l]) {
                    let h = t.includesShadersStore[l]; if (o[2]) { const f = o[3].split(","); for (let _ = 0; _ < f.length; _ += 2) { const p = new RegExp(f[_], "g"), v = f[_ + 1]; h = h.replace(p, v) } } if (o[4]) {
                        const f = o[5]; if (f.indexOf("..") !== -1) {
                            const _ = f.split(".."), p = parseInt(_[0]); let v = parseInt(_[1]), E = h.slice(0); h = "", isNaN(v) && (v = t.indexParameters[_[1]]); for (let m = p; m < v; m++)t.supportsUniformBuffers || (E = E.replace(_s, (x, C) => C + "{X}")), h += E.replace(gs, m.toString()) + `
`} else t.supportsUniformBuffers || (h = h.replace(_s, (_, p) => p + "{X}")), h = h.replace(gs, f)
                    } const u = []; for (const f of n) { const _ = f.split(o[0]); for (let p = 0; p < _.length - 1; p++)u.push(_[p]), u.push(h); u.push(_[_.length - 1]) } n = u, a = a || h.indexOf("#include<") >= 0 || h.indexOf("#include <") >= 0
                } else { const h = t.shadersRepository + "ShadersInclude/" + l + ".fx"; ht._FileToolsLoadFile(h, u => { t.includesShadersStore[l] = u, this._ProcessIncludes(n.join(""), t, i) }); return }
            } pi.length = 0, r = n.join(""), a ? this._ProcessIncludes(r.toString(), t, i) : i(r)
        } static _FileToolsLoadFile(e, t, i, s, r, n) { throw K("FileTools") }
    } ht._MoveCursorRegex = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/; class k { static GetShadersRepository(e = we.GLSL) { return e === we.GLSL ? k.ShadersRepository : k.ShadersRepositoryWGSL } static GetShadersStore(e = we.GLSL) { return e === we.GLSL ? k.ShadersStore : k.ShadersStoreWGSL } static GetIncludesShadersStore(e = we.GLSL) { return e === we.GLSL ? k.IncludesShadersStore : k.IncludesShadersStoreWGSL } } k.ShadersRepository = "src/Shaders/", k.ShadersStore = {}, k.IncludesShadersStore = {}, k.ShadersRepositoryWGSL = "src/ShadersWGSL/", k.ShadersStoreWGSL = {}, k.IncludesShadersStoreWGSL = {}; class Ve {
        static get ShadersRepository() { return k.ShadersRepository } static set ShadersRepository(e) { k.ShadersRepository = e } get onBindObservable() { return this._onBindObservable || (this._onBindObservable = new L), this._onBindObservable } constructor(e, t, i, s = null, r, n = null, a = null, o = null, l = null, h, u = "", f = we.GLSL) { var _, p, v; if (this.name = null, this.defines = "", this.onCompiled = null, this.onError = null, this.onBind = null, this.uniqueId = 0, this.onCompileObservable = new L, this.onErrorObservable = new L, this._onBindObservable = null, this._wasPreviouslyReady = !1, this._forceRebindOnNextCall = !1, this._wasPreviouslyUsingInstances = null, this._isDisposed = !1, this._bonesComputationForcedToCPU = !1, this._uniformBuffersNames = {}, this._multiTarget = !1, this._samplers = {}, this._isReady = !1, this._compilationError = "", this._allFallbacksProcessed = !1, this._uniforms = {}, this._key = "", this._fallbacks = null, this._vertexSourceCodeOverride = "", this._fragmentSourceCodeOverride = "", this._transformFeedbackVaryings = null, this._pipelineContext = null, this._vertexSourceCode = "", this._fragmentSourceCode = "", this._vertexSourceCodeBeforeMigration = "", this._fragmentSourceCodeBeforeMigration = "", this._rawVertexSourceCode = "", this._rawFragmentSourceCode = "", this._processCodeAfterIncludes = void 0, this._processFinalCode = null, this.name = e, this._key = u, t.attributes) { const E = t; if (this._engine = i, this._attributesNames = E.attributes, this._uniformsNames = E.uniformsNames.concat(E.samplers), this._samplerList = E.samplers.slice(), this.defines = E.defines, this.onError = E.onError, this.onCompiled = E.onCompiled, this._fallbacks = E.fallbacks, this._indexParameters = E.indexParameters, this._transformFeedbackVaryings = E.transformFeedbackVaryings || null, this._multiTarget = !!E.multiTarget, this._shaderLanguage = (_ = E.shaderLanguage) !== null && _ !== void 0 ? _ : we.GLSL, E.uniformBuffersNames) { this._uniformBuffersNamesList = E.uniformBuffersNames.slice(); for (let m = 0; m < E.uniformBuffersNames.length; m++)this._uniformBuffersNames[E.uniformBuffersNames[m]] = m } this._processFinalCode = (p = E.processFinalCode) !== null && p !== void 0 ? p : null, this._processCodeAfterIncludes = (v = E.processCodeAfterIncludes) !== null && v !== void 0 ? v : void 0 } else this._engine = r, this.defines = n ?? "", this._uniformsNames = i.concat(s), this._samplerList = s ? s.slice() : [], this._attributesNames = t, this._uniformBuffersNamesList = [], this._shaderLanguage = f, this.onError = l, this.onCompiled = o, this._indexParameters = h, this._fallbacks = a; this._attributeLocationByName = {}, this.uniqueId = Ve._UniqueIdSeed++, this._processShaderCode() } _processShaderCode(e = null, t = !1) {
            let i, s; const r = this.name, n = Fe() ? this._engine.getHostDocument() : null; r.vertexSource ? i = "source:" + r.vertexSource : r.vertexElement ? (i = n ? n.getElementById(r.vertexElement) : null, i || (i = r.vertexElement)) : i = r.vertex || r, r.fragmentSource ? s = "source:" + r.fragmentSource : r.fragmentElement ? (s = n ? n.getElementById(r.fragmentElement) : null, s || (s = r.fragmentElement)) : s = r.fragment || r, this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage); let a = {
                defines: this.defines.split(`
`), indexParameters: this._indexParameters, isFragment: !1, shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader, processor: e ?? this._engine._getShaderProcessor(this._shaderLanguage), supportsUniformBuffers: this._engine.supportsUniformBuffers, shadersRepository: k.GetShadersRepository(this._shaderLanguage), includesShadersStore: k.GetIncludesShadersStore(this._shaderLanguage), version: (this._engine.version * 100).toString(), platformName: this._engine.shaderPlatformName, processingContext: this._processingContext, isNDCHalfZRange: this._engine.isNDCHalfZRange, useReverseDepthBuffer: this._engine.useReverseDepthBuffer, processCodeAfterIncludes: this._processCodeAfterIncludes
            }; const o = [void 0, void 0], l = () => { if (o[0] && o[1]) { a.isFragment = !0; const [h, u] = o; ht.Process(u, a, (f, _) => { this._fragmentSourceCodeBeforeMigration = _, this._processFinalCode && (f = this._processFinalCode("fragment", f)); const p = ht.Finalize(h, f, a); a = null, this._useFinalCode(p.vertexCode, p.fragmentCode, r, t) }, this._engine) } }; this._loadShader(i, "Vertex", "", h => { ht.Initialize(a), ht.Process(h, a, (u, f) => { this._rawVertexSourceCode = h, this._vertexSourceCodeBeforeMigration = f, this._processFinalCode && (u = this._processFinalCode("vertex", u)), o[0] = u, l() }, this._engine) }), this._loadShader(s, "Fragment", "Pixel", h => { this._rawFragmentSourceCode = h, o[1] = h, l() })
        } _useFinalCode(e, t, i, s = !1) {
            if (i) {
                const r = i.vertexElement || i.vertex || i.spectorName || i, n = i.fragmentElement || i.fragment || i.spectorName || i; this._vertexSourceCode = (this._shaderLanguage === we.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + r + `
`+ e, this._fragmentSourceCode = (this._shaderLanguage === we.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + n + `
`+ t
            } else this._vertexSourceCode = e, this._fragmentSourceCode = t; this._prepareEffect(s)
        } get key() { return this._key } isReady() { try { return this._isReadyInternal() } catch { return !1 } } _isReadyInternal() { return this._isReady ? !0 : this._pipelineContext ? this._pipelineContext.isReady : !1 } getEngine() { return this._engine } getPipelineContext() { return this._pipelineContext } getAttributesNames() { return this._attributesNames } getAttributeLocation(e) { return this._attributes[e] } getAttributeLocationByName(e) { return this._attributeLocationByName[e] } getAttributesCount() { return this._attributes.length } getUniformIndex(e) { return this._uniformsNames.indexOf(e) } getUniform(e) { return this._uniforms[e] } getSamplers() { return this._samplerList } getUniformNames() { return this._uniformsNames } getUniformBuffersNames() { return this._uniformBuffersNamesList } getIndexParameters() { return this._indexParameters } getCompilationError() { return this._compilationError } allFallbacksProcessed() { return this._allFallbacksProcessed } executeWhenCompiled(e) { if (this.isReady()) { e(this); return } this.onCompileObservable.add(t => { e(t) }), (!this._pipelineContext || this._pipelineContext.isAsync) && setTimeout(() => { this._checkIsReady(null) }, 16) } _checkIsReady(e) { try { if (this._isReadyInternal()) return } catch (t) { this._processCompilationErrors(t, e); return } this._isDisposed || setTimeout(() => { this._checkIsReady(e) }, 16) } _loadShader(e, t, i, s) { if (typeof HTMLElement < "u" && e instanceof HTMLElement) { const a = hs(e); s(a); return } if (e.substr(0, 7) === "source:") { s(e.substr(7)); return } if (e.substr(0, 7) === "base64:") { const a = window.atob(e.substr(7)); s(a); return } const r = k.GetShadersStore(this._shaderLanguage); if (r[e + t + "Shader"]) { s(r[e + t + "Shader"]); return } if (i && r[e + i + "Shader"]) { s(r[e + i + "Shader"]); return } let n; e[0] === "." || e[0] === "/" || e.indexOf("http") > -1 ? n = e : n = k.GetShadersRepository(this._shaderLanguage) + e, this._engine._loadFile(n + "." + t.toLowerCase() + ".fx", s) } get vertexSourceCode() { var e, t; return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (t = (e = this._pipelineContext) === null || e === void 0 ? void 0 : e._getVertexShaderCode()) !== null && t !== void 0 ? t : this._vertexSourceCode } get fragmentSourceCode() { var e, t; return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (t = (e = this._pipelineContext) === null || e === void 0 ? void 0 : e._getFragmentShaderCode()) !== null && t !== void 0 ? t : this._fragmentSourceCode } get vertexSourceCodeBeforeMigration() { return this._vertexSourceCodeBeforeMigration } get fragmentSourceCodeBeforeMigration() { return this._fragmentSourceCodeBeforeMigration } get rawVertexSourceCode() { return this._rawVertexSourceCode } get rawFragmentSourceCode() { return this._rawFragmentSourceCode } _rebuildProgram(e, t, i, s) { this._isReady = !1, this._vertexSourceCodeOverride = e, this._fragmentSourceCodeOverride = t, this.onError = (r, n) => { s && s(n) }, this.onCompiled = () => { const r = this.getEngine().scenes; if (r) for (let n = 0; n < r.length; n++)r[n].markAllMaterialsAsDirty(63); this._pipelineContext._handlesSpectorRebuildCallback(i) }, this._fallbacks = null, this._prepareEffect() } _prepareEffect(e = !1) { var t; const i = this._attributesNames, s = this.defines, r = this._pipelineContext; this._isReady = !1; try { const n = this._engine; this._pipelineContext = (t = e ? r : void 0) !== null && t !== void 0 ? t : n.createPipelineContext(this._processingContext), this._pipelineContext._name = this._key.replace(/\r/g, "").replace(/\n/g, "|"); const a = (o, l, h, u) => this._rebuildProgram(o, l, h, u); this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? n._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, !0, this._rawVertexSourceCode, this._rawFragmentSourceCode, a, null, this._transformFeedbackVaryings, this._key) : n._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, !1, this._rawVertexSourceCode, this._rawFragmentSourceCode, a, s, this._transformFeedbackVaryings, this._key), n._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => { if (this._attributes = [], this._pipelineContext._fillEffectInformation(this, this._uniformBuffersNames, this._uniformsNames, this._uniforms, this._samplerList, this._samplers, i, this._attributes), i) for (let o = 0; o < i.length; o++) { const l = i[o]; this._attributeLocationByName[l] = this._attributes[o] } n.bindSamplers(this), this._compilationError = "", this._isReady = !0, this.onCompiled && this.onCompiled(this), this.onCompileObservable.notifyObservers(this), this.onCompileObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh(), r && !e && this.getEngine()._deletePipelineContext(r) }), this._pipelineContext.isAsync && this._checkIsReady(r) } catch (n) { this._processCompilationErrors(n, r) } } _getShaderCodeAndErrorLine(e, t, i) {
            const s = i ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/; let r = null; if (t && e) {
                const n = t.match(s); if (n && n.length === 2) {
                    const a = parseInt(n[1]), o = e.split(`
`, -1); o.length >= a && (r = `Offending line [${a}] in ${i ? "fragment" : "vertex"} code: ${o[a - 1]}`)
                }
            } return [e, r]
        } _processCompilationErrors(e, t = null) {
            var i, s, r; this._compilationError = e.message; const n = this._attributesNames, a = this._fallbacks; if (O.Error("Unable to compile effect:"), O.Error("Uniforms: " + this._uniformsNames.map(function (l) { return " " + l })), O.Error("Attributes: " + n.map(function (l) { return " " + l })), O.Error(`Defines:
`+ this.defines), Ve.LogShaderCodeOnCompilationError) { let l = null, h = null, u = null; !((i = this._pipelineContext) === null || i === void 0) && i._getVertexShaderCode() && ([u, l] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, !1), u && (O.Error("Vertex code:"), O.Error(u))), !((s = this._pipelineContext) === null || s === void 0) && s._getFragmentShaderCode() && ([u, h] = this._getShaderCodeAndErrorLine((r = this._pipelineContext) === null || r === void 0 ? void 0 : r._getFragmentShaderCode(), this._compilationError, !0), u && (O.Error("Fragment code:"), O.Error(u))), l && O.Error(l), h && O.Error(h) } O.Error("Error: " + this._compilationError); const o = () => { this.onError && this.onError(this, this._compilationError), this.onErrorObservable.notifyObservers(this) }; t && (this._pipelineContext = t, this._isReady = !0, o()), a ? (this._pipelineContext = null, a.hasMoreFallbacks ? (this._allFallbacksProcessed = !1, O.Error("Trying next fallback."), this.defines = a.reduce(this.defines, this), this._prepareEffect()) : (this._allFallbacksProcessed = !0, o(), this.onErrorObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh())) : (this._allFallbacksProcessed = !0, t || o())
        } get isSupported() { return this._compilationError === "" } _bindTexture(e, t) { this._engine._bindTexture(this._samplers[e], t, e) } setTexture(e, t) { this._engine.setTexture(this._samplers[e], this._uniforms[e], t, e) } setDepthStencilTexture(e, t) { this._engine.setDepthStencilTexture(this._samplers[e], this._uniforms[e], t, e) } setTextureArray(e, t) { const i = e + "Ex"; if (this._samplerList.indexOf(i + "0") === -1) { const s = this._samplerList.indexOf(e); for (let n = 1; n < t.length; n++) { const a = i + (n - 1).toString(); this._samplerList.splice(s + n, 0, a) } let r = 0; for (const n of this._samplerList) this._samplers[n] = r, r += 1 } this._engine.setTextureArray(this._samplers[e], this._uniforms[e], t, e) } setTextureFromPostProcess(e, t) { this._engine.setTextureFromPostProcess(this._samplers[e], t, e) } setTextureFromPostProcessOutput(e, t) { this._engine.setTextureFromPostProcessOutput(this._samplers[e], t, e) } bindUniformBuffer(e, t) { const i = this._uniformBuffersNames[t]; i === void 0 || Ve._BaseCache[i] === e && this._engine._features.useUBOBindingCache || (Ve._BaseCache[i] = e, this._engine.bindUniformBufferBase(e, i, t)) } bindUniformBlock(e, t) { this._engine.bindUniformBlock(this._pipelineContext, e, t) } setInt(e, t) { return this._pipelineContext.setInt(e, t), this } setInt2(e, t, i) { return this._pipelineContext.setInt2(e, t, i), this } setInt3(e, t, i, s) { return this._pipelineContext.setInt3(e, t, i, s), this } setInt4(e, t, i, s, r) { return this._pipelineContext.setInt4(e, t, i, s, r), this } setIntArray(e, t) { return this._pipelineContext.setIntArray(e, t), this } setIntArray2(e, t) { return this._pipelineContext.setIntArray2(e, t), this } setIntArray3(e, t) { return this._pipelineContext.setIntArray3(e, t), this } setIntArray4(e, t) { return this._pipelineContext.setIntArray4(e, t), this } setUInt(e, t) { return this._pipelineContext.setUInt(e, t), this } setUInt2(e, t, i) { return this._pipelineContext.setUInt2(e, t, i), this } setUInt3(e, t, i, s) { return this._pipelineContext.setUInt3(e, t, i, s), this } setUInt4(e, t, i, s, r) { return this._pipelineContext.setUInt4(e, t, i, s, r), this } setUIntArray(e, t) { return this._pipelineContext.setUIntArray(e, t), this } setUIntArray2(e, t) { return this._pipelineContext.setUIntArray2(e, t), this } setUIntArray3(e, t) { return this._pipelineContext.setUIntArray3(e, t), this } setUIntArray4(e, t) { return this._pipelineContext.setUIntArray4(e, t), this } setFloatArray(e, t) { return this._pipelineContext.setArray(e, t), this } setFloatArray2(e, t) { return this._pipelineContext.setArray2(e, t), this } setFloatArray3(e, t) { return this._pipelineContext.setArray3(e, t), this } setFloatArray4(e, t) { return this._pipelineContext.setArray4(e, t), this } setArray(e, t) { return this._pipelineContext.setArray(e, t), this } setArray2(e, t) { return this._pipelineContext.setArray2(e, t), this } setArray3(e, t) { return this._pipelineContext.setArray3(e, t), this } setArray4(e, t) { return this._pipelineContext.setArray4(e, t), this } setMatrices(e, t) { return this._pipelineContext.setMatrices(e, t), this } setMatrix(e, t) { return this._pipelineContext.setMatrix(e, t), this } setMatrix3x3(e, t) { return this._pipelineContext.setMatrix3x3(e, t), this } setMatrix2x2(e, t) { return this._pipelineContext.setMatrix2x2(e, t), this } setFloat(e, t) { return this._pipelineContext.setFloat(e, t), this } setBool(e, t) { return this._pipelineContext.setInt(e, t ? 1 : 0), this } setVector2(e, t) { return this._pipelineContext.setVector2(e, t), this } setFloat2(e, t, i) { return this._pipelineContext.setFloat2(e, t, i), this } setVector3(e, t) { return this._pipelineContext.setVector3(e, t), this } setFloat3(e, t, i, s) { return this._pipelineContext.setFloat3(e, t, i, s), this } setVector4(e, t) { return this._pipelineContext.setVector4(e, t), this } setQuaternion(e, t) { return this._pipelineContext.setQuaternion(e, t), this } setFloat4(e, t, i, s, r) { return this._pipelineContext.setFloat4(e, t, i, s, r), this } setColor3(e, t) { return this._pipelineContext.setColor3(e, t), this } setColor4(e, t, i) { return this._pipelineContext.setColor4(e, t, i), this } setDirectColor4(e, t) { return this._pipelineContext.setDirectColor4(e, t), this } dispose() { this._pipelineContext && this._pipelineContext.dispose(), this._engine._releaseEffect(this), this._isDisposed = !0 } static RegisterShader(e, t, i, s = we.GLSL) { t && (k.GetShadersStore(s)[`${e}PixelShader`] = t), i && (k.GetShadersStore(s)[`${e}VertexShader`] = i) } static ResetCache() { Ve._BaseCache = {} }
    } Ve.LogShaderCodeOnCompilationError = !0, Ve._UniqueIdSeed = 0, Ve._BaseCache = {}, Ve.ShadersStore = k.ShadersStore, Ve.IncludesShadersStore = k.IncludesShadersStore; class Cr { constructor(e = !0) { this._isDepthTestDirty = !1, this._isDepthMaskDirty = !1, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !1, this._isFrontFaceDirty = !1, e && this.reset() } get isDirty() { return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty } get zOffset() { return this._zOffset } set zOffset(e) { this._zOffset !== e && (this._zOffset = e, this._isZOffsetDirty = !0) } get zOffsetUnits() { return this._zOffsetUnits } set zOffsetUnits(e) { this._zOffsetUnits !== e && (this._zOffsetUnits = e, this._isZOffsetDirty = !0) } get cullFace() { return this._cullFace } set cullFace(e) { this._cullFace !== e && (this._cullFace = e, this._isCullFaceDirty = !0) } get cull() { return this._cull } set cull(e) { this._cull !== e && (this._cull = e, this._isCullDirty = !0) } get depthFunc() { return this._depthFunc } set depthFunc(e) { this._depthFunc !== e && (this._depthFunc = e, this._isDepthFuncDirty = !0) } get depthMask() { return this._depthMask } set depthMask(e) { this._depthMask !== e && (this._depthMask = e, this._isDepthMaskDirty = !0) } get depthTest() { return this._depthTest } set depthTest(e) { this._depthTest !== e && (this._depthTest = e, this._isDepthTestDirty = !0) } get frontFace() { return this._frontFace } set frontFace(e) { this._frontFace !== e && (this._frontFace = e, this._isFrontFaceDirty = !0) } reset() { this._depthMask = !0, this._depthTest = !0, this._depthFunc = null, this._cullFace = null, this._cull = null, this._zOffset = 0, this._zOffsetUnits = 0, this._frontFace = null, this._isDepthTestDirty = !0, this._isDepthMaskDirty = !0, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !0, this._isFrontFaceDirty = !1 } apply(e) { this.isDirty && (this._isCullDirty && (this.cull ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this._isCullDirty = !1), this._isCullFaceDirty && (e.cullFace(this.cullFace), this._isCullFaceDirty = !1), this._isDepthMaskDirty && (e.depthMask(this.depthMask), this._isDepthMaskDirty = !1), this._isDepthTestDirty && (this.depthTest ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this._isDepthTestDirty = !1), this._isDepthFuncDirty && (e.depthFunc(this.depthFunc), this._isDepthFuncDirty = !1), this._isZOffsetDirty && (this.zOffset || this.zOffsetUnits ? (e.enable(e.POLYGON_OFFSET_FILL), e.polygonOffset(this.zOffset, this.zOffsetUnits)) : e.disable(e.POLYGON_OFFSET_FILL), this._isZOffsetDirty = !1), this._isFrontFaceDirty && (e.frontFace(this.frontFace), this._isFrontFaceDirty = !1)) } } class _t { constructor() { this.reset() } reset() { this.enabled = !1, this.mask = 255, this.func = _t.ALWAYS, this.funcRef = 1, this.funcMask = 255, this.opStencilFail = _t.KEEP, this.opDepthFail = _t.KEEP, this.opStencilDepthPass = _t.REPLACE } get stencilFunc() { return this.func } set stencilFunc(e) { this.func = e } get stencilFuncRef() { return this.funcRef } set stencilFuncRef(e) { this.funcRef = e } get stencilFuncMask() { return this.funcMask } set stencilFuncMask(e) { this.funcMask = e } get stencilOpStencilFail() { return this.opStencilFail } set stencilOpStencilFail(e) { this.opStencilFail = e } get stencilOpDepthFail() { return this.opDepthFail } set stencilOpDepthFail(e) { this.opDepthFail = e } get stencilOpStencilDepthPass() { return this.opStencilDepthPass } set stencilOpStencilDepthPass(e) { this.opStencilDepthPass = e } get stencilMask() { return this.mask } set stencilMask(e) { this.mask = e } get stencilTest() { return this.enabled } set stencilTest(e) { this.enabled = e } } _t.ALWAYS = 519, _t.KEEP = 7680, _t.REPLACE = 7681; class Ir { constructor() { this._blendFunctionParameters = new Array(4), this._blendEquationParameters = new Array(2), this._blendConstants = new Array(4), this._isBlendConstantsDirty = !1, this._alphaBlend = !1, this._isAlphaBlendDirty = !1, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this.reset() } get isDirty() { return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty } get alphaBlend() { return this._alphaBlend } set alphaBlend(e) { this._alphaBlend !== e && (this._alphaBlend = e, this._isAlphaBlendDirty = !0) } setAlphaBlendConstants(e, t, i, s) { this._blendConstants[0] === e && this._blendConstants[1] === t && this._blendConstants[2] === i && this._blendConstants[3] === s || (this._blendConstants[0] = e, this._blendConstants[1] = t, this._blendConstants[2] = i, this._blendConstants[3] = s, this._isBlendConstantsDirty = !0) } setAlphaBlendFunctionParameters(e, t, i, s) { this._blendFunctionParameters[0] === e && this._blendFunctionParameters[1] === t && this._blendFunctionParameters[2] === i && this._blendFunctionParameters[3] === s || (this._blendFunctionParameters[0] = e, this._blendFunctionParameters[1] = t, this._blendFunctionParameters[2] = i, this._blendFunctionParameters[3] = s, this._isBlendFunctionParametersDirty = !0) } setAlphaEquationParameters(e, t) { this._blendEquationParameters[0] === e && this._blendEquationParameters[1] === t || (this._blendEquationParameters[0] = e, this._blendEquationParameters[1] = t, this._isBlendEquationParametersDirty = !0) } reset() { this._alphaBlend = !1, this._blendFunctionParameters[0] = null, this._blendFunctionParameters[1] = null, this._blendFunctionParameters[2] = null, this._blendFunctionParameters[3] = null, this._blendEquationParameters[0] = null, this._blendEquationParameters[1] = null, this._blendConstants[0] = null, this._blendConstants[1] = null, this._blendConstants[2] = null, this._blendConstants[3] = null, this._isAlphaBlendDirty = !0, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this._isBlendConstantsDirty = !1 } apply(e) { this.isDirty && (this._isAlphaBlendDirty && (this._alphaBlend ? e.enable(e.BLEND) : e.disable(e.BLEND), this._isAlphaBlendDirty = !1), this._isBlendFunctionParametersDirty && (e.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]), this._isBlendFunctionParametersDirty = !1), this._isBlendEquationParametersDirty && (e.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]), this._isBlendEquationParametersDirty = !1), this._isBlendConstantsDirty && (e.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]), this._isBlendConstantsDirty = !1)) } } class Pr { get wrapU() { return this._cachedWrapU } set wrapU(e) { this._cachedWrapU = e } get wrapV() { return this._cachedWrapV } set wrapV(e) { this._cachedWrapV = e } get wrapR() { return this._cachedWrapR } set wrapR(e) { this._cachedWrapR = e } get anisotropicFilteringLevel() { return this._cachedAnisotropicFilteringLevel } set anisotropicFilteringLevel(e) { this._cachedAnisotropicFilteringLevel = e } get comparisonFunction() { return this._comparisonFunction } set comparisonFunction(e) { this._comparisonFunction = e } get useMipMaps() { return this._useMipMaps } set useMipMaps(e) { this._useMipMaps = e } constructor() { this.samplingMode = -1, this._useMipMaps = !0, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedWrapR = null, this._cachedAnisotropicFilteringLevel = null, this._comparisonFunction = 0 } setParameters(e = 1, t = 1, i = 1, s = 1, r = 2, n = 0) { return this._cachedWrapU = e, this._cachedWrapV = t, this._cachedWrapR = i, this._cachedAnisotropicFilteringLevel = s, this.samplingMode = r, this._comparisonFunction = n, this } compareSampler(e) { return this._cachedWrapU === e._cachedWrapU && this._cachedWrapV === e._cachedWrapV && this._cachedWrapR === e._cachedWrapR && this._cachedAnisotropicFilteringLevel === e._cachedAnisotropicFilteringLevel && this.samplingMode === e.samplingMode && this._comparisonFunction === e._comparisonFunction && this._useMipMaps === e._useMipMaps } } var Ne; (function (c) { c[c.Unknown = 0] = "Unknown", c[c.Url = 1] = "Url", c[c.Temp = 2] = "Temp", c[c.Raw = 3] = "Raw", c[c.Dynamic = 4] = "Dynamic", c[c.RenderTarget = 5] = "RenderTarget", c[c.MultiRenderTarget = 6] = "MultiRenderTarget", c[c.Cube = 7] = "Cube", c[c.CubeRaw = 8] = "CubeRaw", c[c.CubePrefiltered = 9] = "CubePrefiltered", c[c.Raw3D = 10] = "Raw3D", c[c.Raw2DArray = 11] = "Raw2DArray", c[c.DepthStencil = 12] = "DepthStencil", c[c.CubeRawRGBD = 13] = "CubeRawRGBD", c[c.Depth = 14] = "Depth" })(Ne || (Ne = {})); class Ot extends Pr { get useMipMaps() { return this.generateMipMaps } set useMipMaps(e) { this.generateMipMaps = e } get uniqueId() { return this._uniqueId } _setUniqueId(e) { this._uniqueId = e } getEngine() { return this._engine } get source() { return this._source } constructor(e, t, i = !1) { super(), this.isReady = !1, this.isCube = !1, this.is3D = !1, this.is2DArray = !1, this.isMultiview = !1, this.url = "", this.generateMipMaps = !1, this.samples = 0, this.type = -1, this.format = -1, this.onLoadedObservable = new L, this.onErrorObservable = new L, this.onRebuildCallback = null, this.width = 0, this.height = 0, this.depth = 0, this.baseWidth = 0, this.baseHeight = 0, this.baseDepth = 0, this.invertY = !1, this._invertVScale = !1, this._associatedChannel = -1, this._source = Ne.Unknown, this._buffer = null, this._bufferView = null, this._bufferViewArray = null, this._bufferViewArrayArray = null, this._size = 0, this._extension = "", this._files = null, this._workingCanvas = null, this._workingContext = null, this._cachedCoordinatesMode = null, this._isDisabled = !1, this._compression = null, this._sphericalPolynomial = null, this._sphericalPolynomialPromise = null, this._sphericalPolynomialComputed = !1, this._lodGenerationScale = 0, this._lodGenerationOffset = 0, this._useSRGBBuffer = !1, this._lodTextureHigh = null, this._lodTextureMid = null, this._lodTextureLow = null, this._isRGBD = !1, this._linearSpecularLOD = !1, this._irradianceTexture = null, this._hardwareTexture = null, this._maxLodLevel = null, this._references = 1, this._gammaSpace = null, this._premulAlpha = !1, this._dynamicTextureSource = null, this._engine = e, this._source = t, this._uniqueId = Ot._Counter++, i || (this._hardwareTexture = e._createHardwareTexture()) } incrementReferences() { this._references++ } updateSize(e, t, i = 1) { this._engine.updateTextureDimensions(this, e, t, i), this.width = e, this.height = t, this.depth = i, this.baseWidth = e, this.baseHeight = t, this.baseDepth = i, this._size = e * t * i } _rebuild() { var e; if (this.isReady = !1, this._cachedCoordinatesMode = null, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedWrapR = null, this._cachedAnisotropicFilteringLevel = null, this.onRebuildCallback) { const i = this.onRebuildCallback(this), s = r => { r._swapAndDie(this, !1), this.isReady = i.isReady }; i.isAsync ? i.proxy.then(s) : s(i.proxy); return } let t; switch (this.source) { case Ne.Temp: break; case Ne.Url: t = this._engine.createTexture((e = this._originalUrl) !== null && e !== void 0 ? e : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, i => { i._swapAndDie(this, !1), this.isReady = !0 }, null, this._buffer, void 0, this.format, this._extension, void 0, void 0, void 0, this._useSRGBBuffer); return; case Ne.Raw: t = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, void 0, this._useSRGBBuffer), t._swapAndDie(this, !1), this.isReady = !0; break; case Ne.Raw3D: t = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type), t._swapAndDie(this, !1), this.isReady = !0; break; case Ne.Raw2DArray: t = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type), t._swapAndDie(this, !1), this.isReady = !0; break; case Ne.Dynamic: t = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode), t._swapAndDie(this, !1), this._dynamicTextureSource && this._engine.updateDynamicTexture(this, this._dynamicTextureSource, this.invertY, this._premulAlpha, this.format, !0); break; case Ne.Cube: t = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, () => { t._swapAndDie(this, !1), this.isReady = !0 }, null, this.format, this._extension, !1, 0, 0, null, void 0, this._useSRGBBuffer); return; case Ne.CubeRaw: t = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression), t._swapAndDie(this, !1), this.isReady = !0; break; case Ne.CubeRawRGBD: return; case Ne.CubePrefiltered: t = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, i => { i && i._swapAndDie(this, !1), this.isReady = !0 }, null, this.format, this._extension), t._sphericalPolynomial = this._sphericalPolynomial; return } } _swapAndDie(e, t = !0) { var i; (i = this._hardwareTexture) === null || i === void 0 || i.setUsage(e._source, this.generateMipMaps, this.isCube, this.width, this.height), e._hardwareTexture = this._hardwareTexture, t && (e._isRGBD = this._isRGBD), this._lodTextureHigh && (e._lodTextureHigh && e._lodTextureHigh.dispose(), e._lodTextureHigh = this._lodTextureHigh), this._lodTextureMid && (e._lodTextureMid && e._lodTextureMid.dispose(), e._lodTextureMid = this._lodTextureMid), this._lodTextureLow && (e._lodTextureLow && e._lodTextureLow.dispose(), e._lodTextureLow = this._lodTextureLow), this._irradianceTexture && (e._irradianceTexture && e._irradianceTexture.dispose(), e._irradianceTexture = this._irradianceTexture); const s = this._engine.getLoadedTexturesCache(); let r = s.indexOf(this); r !== -1 && s.splice(r, 1), r = s.indexOf(e), r === -1 && s.push(e) } dispose() { this._references--, this.onLoadedObservable.clear(), this.onErrorObservable.clear(), this._references === 0 && (this._engine._releaseTexture(this), this._hardwareTexture = null, this._dynamicTextureSource = null) } } Ot._Counter = 0; class Dr { constructor() { this.shaderLanguage = we.GLSL } postProcessor(e, t, i, s, r) { if (!r.getCaps().drawBuffersExtension) { const n = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g; e = e.replace(n, "") } return e } } const Fr = /(flat\s)?\s*varying\s*.*/; class wr {
        constructor() { this.shaderLanguage = we.GLSL } attributeProcessor(e) { return e.replace("attribute", "in") } varyingCheck(e, t) { return Fr.test(e) } varyingProcessor(e, t) { return e.replace("varying", t ? "in" : "out") } postProcessor(e, t, i) {
            const s = e.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1, r = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g; if (e = e.replace(r, ""), e = e.replace(/texture2D\s*\(/g, "texture("), i) {
                const n = e.search(/layout *\(location *= *0\) *out/g) !== -1; e = e.replace(/texture2DLodEXT\s*\(/g, "textureLod("), e = e.replace(/textureCubeLodEXT\s*\(/g, "textureLod("), e = e.replace(/textureCube\s*\(/g, "texture("), e = e.replace(/gl_FragDepthEXT/g, "gl_FragDepth"), e = e.replace(/gl_FragColor/g, "glFragColor"), e = e.replace(/gl_FragData/g, "glFragData"), e = e.replace(/void\s+?main\s*\(/g, (s || n ? "" : `layout(location = 0) out vec4 glFragColor;
`) + "void main(")
            } else if (t.indexOf("#define MULTIVIEW") !== -1) return `#extension GL_OVR_multiview2 : require
layout (num_views = 2) in;
`+ e; return e
        }
    } class ti { get underlyingResource() { return null } constructor() { this.references = 0, this.capacity = 0, this.is32Bits = !1, this.uniqueId = ti._Counter++ } } ti._Counter = 0; class ii extends ti { constructor(e) { super(), this._buffer = e } get underlyingResource() { return this._buffer } } class Or { constructor() { this._valueCache = {}, this.vertexCompilationError = null, this.fragmentCompilationError = null, this.programLinkError = null, this.programValidationError = null, this._isDisposed = !1 } get isAsync() { return this.isParallelCompiled } get isReady() { return this.program ? this.isParallelCompiled ? this.engine._isRenderingStateCompiled(this) : !0 : !1 } _handlesSpectorRebuildCallback(e) { e && this.program && e(this.program) } _fillEffectInformation(e, t, i, s, r, n, a, o) { const l = this.engine; if (l.supportsUniformBuffers) for (const f in t) e.bindUniformBlock(f, t[f]); this.engine.getUniforms(this, i).forEach((f, _) => { s[i[_]] = f }), this._uniforms = s; let u; for (u = 0; u < r.length; u++)e.getUniform(r[u]) == null && (r.splice(u, 1), u--); r.forEach((f, _) => { n[f] = _ }); for (const f of l.getAttributes(this, a)) o.push(f) } dispose() { this._uniforms = {}, this._isDisposed = !0 } _cacheMatrix(e, t) { const i = this._valueCache[e], s = t.updateFlag; return i !== void 0 && i === s ? !1 : (this._valueCache[e] = s, !0) } _cacheFloat2(e, t, i) { let s = this._valueCache[e]; if (!s || s.length !== 2) return s = [t, i], this._valueCache[e] = s, !0; let r = !1; return s[0] !== t && (s[0] = t, r = !0), s[1] !== i && (s[1] = i, r = !0), r } _cacheFloat3(e, t, i, s) { let r = this._valueCache[e]; if (!r || r.length !== 3) return r = [t, i, s], this._valueCache[e] = r, !0; let n = !1; return r[0] !== t && (r[0] = t, n = !0), r[1] !== i && (r[1] = i, n = !0), r[2] !== s && (r[2] = s, n = !0), n } _cacheFloat4(e, t, i, s, r) { let n = this._valueCache[e]; if (!n || n.length !== 4) return n = [t, i, s, r], this._valueCache[e] = n, !0; let a = !1; return n[0] !== t && (n[0] = t, a = !0), n[1] !== i && (n[1] = i, a = !0), n[2] !== s && (n[2] = s, a = !0), n[3] !== r && (n[3] = r, a = !0), a } setInt(e, t) { const i = this._valueCache[e]; i !== void 0 && i === t || this.engine.setInt(this._uniforms[e], t) && (this._valueCache[e] = t) } setInt2(e, t, i) { this._cacheFloat2(e, t, i) && (this.engine.setInt2(this._uniforms[e], t, i) || (this._valueCache[e] = null)) } setInt3(e, t, i, s) { this._cacheFloat3(e, t, i, s) && (this.engine.setInt3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null)) } setInt4(e, t, i, s, r) { this._cacheFloat4(e, t, i, s, r) && (this.engine.setInt4(this._uniforms[e], t, i, s, r) || (this._valueCache[e] = null)) } setIntArray(e, t) { this._valueCache[e] = null, this.engine.setIntArray(this._uniforms[e], t) } setIntArray2(e, t) { this._valueCache[e] = null, this.engine.setIntArray2(this._uniforms[e], t) } setIntArray3(e, t) { this._valueCache[e] = null, this.engine.setIntArray3(this._uniforms[e], t) } setIntArray4(e, t) { this._valueCache[e] = null, this.engine.setIntArray4(this._uniforms[e], t) } setUInt(e, t) { const i = this._valueCache[e]; i !== void 0 && i === t || this.engine.setUInt(this._uniforms[e], t) && (this._valueCache[e] = t) } setUInt2(e, t, i) { this._cacheFloat2(e, t, i) && (this.engine.setUInt2(this._uniforms[e], t, i) || (this._valueCache[e] = null)) } setUInt3(e, t, i, s) { this._cacheFloat3(e, t, i, s) && (this.engine.setUInt3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null)) } setUInt4(e, t, i, s, r) { this._cacheFloat4(e, t, i, s, r) && (this.engine.setUInt4(this._uniforms[e], t, i, s, r) || (this._valueCache[e] = null)) } setUIntArray(e, t) { this._valueCache[e] = null, this.engine.setUIntArray(this._uniforms[e], t) } setUIntArray2(e, t) { this._valueCache[e] = null, this.engine.setUIntArray2(this._uniforms[e], t) } setUIntArray3(e, t) { this._valueCache[e] = null, this.engine.setUIntArray3(this._uniforms[e], t) } setUIntArray4(e, t) { this._valueCache[e] = null, this.engine.setUIntArray4(this._uniforms[e], t) } setArray(e, t) { this._valueCache[e] = null, this.engine.setArray(this._uniforms[e], t) } setArray2(e, t) { this._valueCache[e] = null, this.engine.setArray2(this._uniforms[e], t) } setArray3(e, t) { this._valueCache[e] = null, this.engine.setArray3(this._uniforms[e], t) } setArray4(e, t) { this._valueCache[e] = null, this.engine.setArray4(this._uniforms[e], t) } setMatrices(e, t) { t && (this._valueCache[e] = null, this.engine.setMatrices(this._uniforms[e], t)) } setMatrix(e, t) { this._cacheMatrix(e, t) && (this.engine.setMatrices(this._uniforms[e], t.toArray()) || (this._valueCache[e] = null)) } setMatrix3x3(e, t) { this._valueCache[e] = null, this.engine.setMatrix3x3(this._uniforms[e], t) } setMatrix2x2(e, t) { this._valueCache[e] = null, this.engine.setMatrix2x2(this._uniforms[e], t) } setFloat(e, t) { const i = this._valueCache[e]; i !== void 0 && i === t || this.engine.setFloat(this._uniforms[e], t) && (this._valueCache[e] = t) } setVector2(e, t) { this._cacheFloat2(e, t.x, t.y) && (this.engine.setFloat2(this._uniforms[e], t.x, t.y) || (this._valueCache[e] = null)) } setFloat2(e, t, i) { this._cacheFloat2(e, t, i) && (this.engine.setFloat2(this._uniforms[e], t, i) || (this._valueCache[e] = null)) } setVector3(e, t) { this._cacheFloat3(e, t.x, t.y, t.z) && (this.engine.setFloat3(this._uniforms[e], t.x, t.y, t.z) || (this._valueCache[e] = null)) } setFloat3(e, t, i, s) { this._cacheFloat3(e, t, i, s) && (this.engine.setFloat3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null)) } setVector4(e, t) { this._cacheFloat4(e, t.x, t.y, t.z, t.w) && (this.engine.setFloat4(this._uniforms[e], t.x, t.y, t.z, t.w) || (this._valueCache[e] = null)) } setQuaternion(e, t) { this._cacheFloat4(e, t.x, t.y, t.z, t.w) && (this.engine.setFloat4(this._uniforms[e], t.x, t.y, t.z, t.w) || (this._valueCache[e] = null)) } setFloat4(e, t, i, s, r) { this._cacheFloat4(e, t, i, s, r) && (this.engine.setFloat4(this._uniforms[e], t, i, s, r) || (this._valueCache[e] = null)) } setColor3(e, t) { this._cacheFloat3(e, t.r, t.g, t.b) && (this.engine.setFloat3(this._uniforms[e], t.r, t.g, t.b) || (this._valueCache[e] = null)) } setColor4(e, t, i) { this._cacheFloat4(e, t.r, t.g, t.b, i) && (this.engine.setFloat4(this._uniforms[e], t.r, t.g, t.b, i) || (this._valueCache[e] = null)) } setDirectColor4(e, t) { this._cacheFloat4(e, t.r, t.g, t.b, t.a) && (this.engine.setFloat4(this._uniforms[e], t.r, t.g, t.b, t.a) || (this._valueCache[e] = null)) } _getVertexShaderCode() { return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null } _getFragmentShaderCode() { return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null } } class ms { get underlyingResource() { return this._webGLTexture } constructor(e = null, t) { if (this._MSAARenderBuffers = null, this._context = t, !e && (e = t.createTexture(), !e)) throw new Error("Unable to create webGL texture"); this.set(e) } setUsage() { } set(e) { this._webGLTexture = e } reset() { this._webGLTexture = null, this._MSAARenderBuffers = null } addMSAARenderBuffer(e) { this._MSAARenderBuffers || (this._MSAARenderBuffers = []), this._MSAARenderBuffers.push(e) } releaseMSAARenderBuffers() { if (this._MSAARenderBuffers) { for (const e of this._MSAARenderBuffers) this._context.deleteRenderbuffer(e); this._MSAARenderBuffers = null } } getMSAARenderBuffer(e = 0) { var t, i; return (i = (t = this._MSAARenderBuffers) === null || t === void 0 ? void 0 : t[e]) !== null && i !== void 0 ? i : null } release() { this.releaseMSAARenderBuffers(), this._webGLTexture && this._context.deleteTexture(this._webGLTexture), this.reset() } } class Li { static IsWrapper(e) { return e.getPipelineContext === void 0 } static GetEffect(e) { return e.getPipelineContext === void 0 ? e.effect : e } constructor(e, t = !0) { this.effect = null, this.defines = null, this.drawContext = e.createDrawContext(), t && (this.materialContext = e.createMaterialContext()) } setEffect(e, t, i = !0) { var s; this.effect = e, t !== void 0 && (this.defines = t), i && ((s = this.drawContext) === null || s === void 0 || s.reset()) } dispose() { var e; (e = this.drawContext) === null || e === void 0 || e.dispose() } } class Lr { get isDirty() { return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty } get func() { return this._func } set func(e) { this._func !== e && (this._func = e, this._isStencilFuncDirty = !0) } get funcRef() { return this._funcRef } set funcRef(e) { this._funcRef !== e && (this._funcRef = e, this._isStencilFuncDirty = !0) } get funcMask() { return this._funcMask } set funcMask(e) { this._funcMask !== e && (this._funcMask = e, this._isStencilFuncDirty = !0) } get opStencilFail() { return this._opStencilFail } set opStencilFail(e) { this._opStencilFail !== e && (this._opStencilFail = e, this._isStencilOpDirty = !0) } get opDepthFail() { return this._opDepthFail } set opDepthFail(e) { this._opDepthFail !== e && (this._opDepthFail = e, this._isStencilOpDirty = !0) } get opStencilDepthPass() { return this._opStencilDepthPass } set opStencilDepthPass(e) { this._opStencilDepthPass !== e && (this._opStencilDepthPass = e, this._isStencilOpDirty = !0) } get mask() { return this._mask } set mask(e) { this._mask !== e && (this._mask = e, this._isStencilMaskDirty = !0) } get enabled() { return this._enabled } set enabled(e) { this._enabled !== e && (this._enabled = e, this._isStencilTestDirty = !0) } constructor(e = !0) { this._isStencilTestDirty = !1, this._isStencilMaskDirty = !1, this._isStencilFuncDirty = !1, this._isStencilOpDirty = !1, this.useStencilGlobalOnly = !1, e && this.reset() } reset() { var e; this.stencilMaterial = void 0, (e = this.stencilGlobal) === null || e === void 0 || e.reset(), this._isStencilTestDirty = !0, this._isStencilMaskDirty = !0, this._isStencilFuncDirty = !0, this._isStencilOpDirty = !0 } apply(e) { var t; if (!e) return; const i = !this.useStencilGlobalOnly && !!(!((t = this.stencilMaterial) === null || t === void 0) && t.enabled); this.enabled = i ? this.stencilMaterial.enabled : this.stencilGlobal.enabled, this.func = i ? this.stencilMaterial.func : this.stencilGlobal.func, this.funcRef = i ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef, this.funcMask = i ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask, this.opStencilFail = i ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail, this.opDepthFail = i ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail, this.opStencilDepthPass = i ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass, this.mask = i ? this.stencilMaterial.mask : this.stencilGlobal.mask, this.isDirty && (this._isStencilTestDirty && (this.enabled ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this._isStencilTestDirty = !1), this._isStencilMaskDirty && (e.stencilMask(this.mask), this._isStencilMaskDirty = !1), this._isStencilFuncDirty && (e.stencilFunc(this.func, this.funcRef, this.funcMask), this._isStencilFuncDirty = !1), this._isStencilOpDirty && (e.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass), this._isStencilOpDirty = !1)) } } class Nr { } class $ {
        static get NpmPackage() { return "babylonjs@6.33.1" } static get Version() { return "6.33.1" } get description() { let e = this.name + this.webGLVersion; return this._caps.parallelShaderCompile && (e += " - Parallel shader compilation"), e } get name() { return this._name } set name(e) { this._name = e } get version() { return this._webGLVersion } get isDisposed() { return this._isDisposed } static get ShadersRepository() { return Ve.ShadersRepository } static set ShadersRepository(e) { Ve.ShadersRepository = e } _getShaderProcessor(e) { return this._shaderProcessor } get useReverseDepthBuffer() { return this._useReverseDepthBuffer } set useReverseDepthBuffer(e) { e !== this._useReverseDepthBuffer && (this._useReverseDepthBuffer = e, e ? this._depthCullingState.depthFunc = 518 : this._depthCullingState.depthFunc = 515) } get frameId() { return this._frameId } get supportsUniformBuffers() { return this.webGLVersion > 1 && !this.disableUniformBuffers } getCreationOptions() { return this._creationOptions } get _shouldUseHighPrecisionShader() { return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed) } get needPOTTextures() { return this._webGLVersion < 2 || this.forcePOTTextures } get activeRenderLoops() { return this._activeRenderLoops } get doNotHandleContextLost() { return this._doNotHandleContextLost } set doNotHandleContextLost(e) { this._doNotHandleContextLost = e } get _supportsHardwareTextureRescaling() { return !1 } set framebufferDimensionsObject(e) { this._framebufferDimensionsObject = e } get currentViewport() { return this._cachedViewport } get emptyTexture() { return this._emptyTexture || (this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, !1, !1, 1)), this._emptyTexture } get emptyTexture3D() { return this._emptyTexture3D || (this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)), this._emptyTexture3D } get emptyTexture2DArray() { return this._emptyTexture2DArray || (this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)), this._emptyTexture2DArray } get emptyCubeTexture() { if (!this._emptyCubeTexture) { const e = new Uint8Array(4), t = [e, e, e, e, e, e]; this._emptyCubeTexture = this.createRawCubeTexture(t, 1, 5, 0, !1, !1, 1) } return this._emptyCubeTexture } get isWebGPU() { return this._isWebGPU } get shaderPlatformName() { return this._shaderPlatformName } get snapshotRendering() { return !1 } set snapshotRendering(e) { } get snapshotRenderingMode() { return this._snapshotRenderingMode } set snapshotRenderingMode(e) { this._snapshotRenderingMode = e } snapshotRenderingReset() { this.snapshotRendering = !1 } static _CreateCanvas(e, t) { if (typeof document > "u") return new OffscreenCanvas(e, t); const i = document.createElement("canvas"); return i.width = e, i.height = t, i } createCanvas(e, t) { return $._CreateCanvas(e, t) } createCanvasImage() { return document.createElement("img") } constructor(e, t, i, s) { var r, n, a, o, l, h, u, f, _, p, v; this._name = "WebGL", this._isDisposed = !1, this.forcePOTTextures = !1, this.isFullscreen = !1, this.cullBackFaces = null, this.renderEvenInBackground = !0, this.preventCacheWipeBetweenFrames = !1, this.validateShaderPrograms = !1, this._useReverseDepthBuffer = !1, this.isNDCHalfZRange = !1, this.hasOriginBottomLeft = !0, this.disableUniformBuffers = !1, this.onDisposeObservable = new L, this._frameId = 0, this._uniformBuffers = new Array, this._storageBuffers = new Array, this._webGLVersion = 1, this._windowIsBackground = !1, this._highPrecisionShadersAllowed = !0, this._badOS = !1, this._badDesktopOS = !1, this._renderingQueueLaunched = !1, this._activeRenderLoops = new Array, this.onContextLostObservable = new L, this.onContextRestoredObservable = new L, this._contextWasLost = !1, this._doNotHandleContextLost = !1, this.disableVertexArrayObjects = !1, this._colorWrite = !0, this._colorWriteChanged = !0, this._depthCullingState = new Cr, this._stencilStateComposer = new Lr, this._stencilState = new _t, this._alphaState = new Ir, this._alphaMode = 1, this._alphaEquation = 0, this._internalTexturesCache = new Array, this._renderTargetWrapperCache = new Array, this._activeChannel = 0, this._currentTextureChannel = -1, this._boundTexturesCache = {}, this._compiledEffects = {}, this._vertexAttribArraysEnabled = [], this._currentRenderTarget = null, this._uintIndicesCurrentlySet = !1, this._currentBoundBuffer = new Array, this._currentFramebuffer = null, this._dummyFramebuffer = null, this._currentBufferPointers = new Array, this._currentInstanceLocations = new Array, this._currentInstanceBuffers = new Array, this._vaoRecordInProgress = !1, this._mustWipeVertexAttributes = !1, this._nextFreeTextureSlots = new Array, this._maxSimultaneousTextures = 0, this._maxMSAASamplesOverride = null, this._activeRequests = new Array, this.adaptToDeviceRatio = !1, this._lastDevicePixelRatio = 1, this._transformTextureUrl = null, this.hostInformation = { isMobile: !1 }, this.premultipliedAlpha = !0, this.onBeforeTextureInitObservable = new L, this._isWebGPU = !1, this._snapshotRenderingMode = 0, this._viewportCached = { x: 0, y: 0, z: 0, w: 0 }, this._unpackFlipYCached = null, this.enableUnpackFlipYCached = !0, this._boundUniforms = {}, this.startTime = wt.Now; let E = null; i = i || {}, this._creationOptions = i, this.adaptToDeviceRatio = s ?? !1, this._stencilStateComposer.stencilGlobal = this._stencilState, Pe.SetMatrixPrecision(!!i.useHighPrecisionMatrix), i.antialias = t ?? i.antialias, i.deterministicLockstep = (r = i.deterministicLockstep) !== null && r !== void 0 ? r : !1, i.lockstepMaxSteps = (n = i.lockstepMaxSteps) !== null && n !== void 0 ? n : 4, i.timeStep = (a = i.timeStep) !== null && a !== void 0 ? a : 1 / 60, i.audioEngine = (o = i.audioEngine) !== null && o !== void 0 ? o : !0, i.stencil = (l = i.stencil) !== null && l !== void 0 ? l : !0, this._audioContext = (u = (h = i.audioEngineOptions) === null || h === void 0 ? void 0 : h.audioContext) !== null && u !== void 0 ? u : null, this._audioDestination = (_ = (f = i.audioEngineOptions) === null || f === void 0 ? void 0 : f.audioDestination) !== null && _ !== void 0 ? _ : null, this.premultipliedAlpha = (p = i.premultipliedAlpha) !== null && p !== void 0 ? p : !0, this.useExactSrgbConversions = (v = i.useExactSrgbConversions) !== null && v !== void 0 ? v : !1, this._doNotHandleContextLost = !!i.doNotHandleContextLost, this._isStencilEnable = !!i.stencil, s = s || i.adaptToDeviceRatio || !1; const m = Fe() && window.devicePixelRatio || 1, x = i.limitDeviceRatio || m; if (this._hardwareScalingLevel = s ? 1 / Math.min(x, m) : 1, this._lastDevicePixelRatio = m, !e) return; if (e.getContext) { if (E = e, this._renderingCanvas = E, i.preserveDrawingBuffer === void 0 && (i.preserveDrawingBuffer = !1), i.xrCompatible === void 0 && (i.xrCompatible = !0), navigator && navigator.userAgent) { this._setupMobileChecks(); const S = navigator.userAgent; for (const y of $.ExceptionList) { const b = y.key, R = y.targets; if (new RegExp(b).test(S)) { if (y.capture && y.captureConstraint) { const N = y.capture, X = y.captureConstraint, J = new RegExp(N).exec(S); if (J && J.length > 0 && parseInt(J[J.length - 1]) >= X) continue } for (const N of R) switch (N) { case "uniformBuffer": this.disableUniformBuffers = !0; break; case "vao": this.disableVertexArrayObjects = !0; break; case "antialias": i.antialias = !1; break; case "maxMSAASamples": this._maxMSAASamplesOverride = 1; break } } } } if (this._doNotHandleContextLost || (this._onContextLost = S => { S.preventDefault(), this._contextWasLost = !0, O.Warn("WebGL context lost."), this.onContextLostObservable.notifyObservers(this) }, this._onContextRestored = () => { this._restoreEngineAfterContextLost(() => this._initGLContext()) }, E.addEventListener("webglcontextlost", this._onContextLost, !1), E.addEventListener("webglcontextrestored", this._onContextRestored, !1), i.powerPreference = i.powerPreference || "high-performance"), this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), this._badDesktopOS && (i.xrCompatible = !1), !i.disableWebGL2Support) try { this._gl = E.getContext("webgl2", i) || E.getContext("experimental-webgl2", i), this._gl && (this._webGLVersion = 2, this._shaderPlatformName = "WEBGL2", this._gl.deleteQuery || (this._webGLVersion = 1, this._shaderPlatformName = "WEBGL1")) } catch { } if (!this._gl) { if (!E) throw new Error("The provided canvas is null or undefined."); try { this._gl = E.getContext("webgl", i) || E.getContext("experimental-webgl", i) } catch { throw new Error("WebGL not supported") } } if (!this._gl) throw new Error("WebGL not supported") } else { this._gl = e, this._renderingCanvas = this._gl.canvas, this._gl.renderbufferStorageMultisample ? (this._webGLVersion = 2, this._shaderPlatformName = "WEBGL2") : this._shaderPlatformName = "WEBGL1"; const S = this._gl.getContextAttributes(); S && (i.stencil = S.stencil) } this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE), i.useHighPrecisionFloats !== void 0 && (this._highPrecisionShadersAllowed = i.useHighPrecisionFloats), this.resize(), this._initGLContext(), this._initFeatures(); for (let S = 0; S < this._caps.maxVertexAttribs; S++)this._currentBufferPointers[S] = new Nr; this._shaderProcessor = this.webGLVersion > 1 ? new wr : new Dr, this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent); const C = `Babylon.js v${$.Version}`; console.log(C + ` - ${this.description}`), this._renderingCanvas && this._renderingCanvas.setAttribute && this._renderingCanvas.setAttribute("data-engine", C) } _setupMobileChecks() { navigator && navigator.userAgent && (this._checkForMobile = () => { const e = navigator.userAgent; this.hostInformation.isMobile = e.indexOf("Mobile") !== -1 || e.indexOf("Mac") !== -1 && Qt() && "ontouchend" in document }, this._checkForMobile(), Fe() && window.addEventListener("resize", this._checkForMobile)) } _restoreEngineAfterContextLost(e) { setTimeout(async () => { var t; this._dummyFramebuffer = null; const i = this._depthCullingState.depthTest, s = this._depthCullingState.depthFunc, r = this._depthCullingState.depthMask, n = this._stencilState.stencilTest; await e(), this.wipeCaches(!0), this._rebuildEffects(), (t = this._rebuildComputeEffects) === null || t === void 0 || t.call(this), this._rebuildBuffers(), this._rebuildInternalTextures(), this._rebuildRenderTargetWrappers(), this.wipeCaches(!0), this._depthCullingState.depthTest = i, this._depthCullingState.depthFunc = s, this._depthCullingState.depthMask = r, this._stencilState.stencilTest = n, O.Warn(this.name + " context successfully restored."), this.onContextRestoredObservable.notifyObservers(this), this._contextWasLost = !1 }, 0) } _sharedInit(e) { this._renderingCanvas = e } _getShaderProcessingContext(e) { return null } _rebuildInternalTextures() { const e = this._internalTexturesCache.slice(); for (const t of e) t._rebuild() } _rebuildRenderTargetWrappers() { const e = this._renderTargetWrapperCache.slice(); for (const t of e) t._rebuild() } _rebuildEffects() { for (const e in this._compiledEffects) { const t = this._compiledEffects[e]; t._pipelineContext = null, t._wasPreviouslyReady = !1, t._prepareEffect() } Ve.ResetCache() } areAllEffectsReady() { for (const e in this._compiledEffects) if (!this._compiledEffects[e].isReady()) return !1; return !0 } _rebuildBuffers() { for (const e of this._uniformBuffers) e._rebuild(); for (const e of this._storageBuffers) e._rebuild() } _initGLContext() { var e; this._caps = { maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS), maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS), maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE), maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1, maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE), maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE), maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS), maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS), maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS), maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS), parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0, standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null, maxAnisotropy: 1, astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"), bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"), s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"), s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"), pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"), etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"), textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"), uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null, fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null, highPrecisionShaderSupported: !1, timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"), supportOcclusionQuery: this._webGLVersion > 1, canUseTimestampForTimerQuery: !1, drawBuffersExtension: !1, maxMSAASamples: 1, colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")), supportFloatTexturesResolve: !1, colorBufferHalfFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_half_float")), textureFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float")), textureHalfFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float")), textureHalfFloatRender: !1, textureFloatLinearFiltering: !1, textureFloatRender: !1, textureHalfFloatLinearFiltering: !1, vertexArrayObject: !1, instancedArrays: !1, textureLOD: !!(this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod")), texelFetch: this._webGLVersion !== 1, blendMinMax: !1, multiview: this._gl.getExtension("OVR_multiview2"), oculusMultiview: this._gl.getExtension("OCULUS_multiview"), depthTextureExtension: !1, canUseGLInstanceID: this._webGLVersion > 1, canUseGLVertexID: this._webGLVersion > 1, supportComputeShaders: !1, supportSRGBBuffers: !1, supportTransformFeedbacks: this._webGLVersion > 1, textureMaxLevel: this._webGLVersion > 1, texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS) : 128, disableMorphTargetTexture: !1 }, this._caps.supportFloatTexturesResolve = this._caps.colorBufferFloat, this._glVersion = this._gl.getParameter(this._gl.VERSION); const t = this._gl.getExtension("WEBGL_debug_renderer_info"); if (t != null && (this._glRenderer = this._gl.getParameter(t.UNMASKED_RENDERER_WEBGL), this._glVendor = this._gl.getParameter(t.UNMASKED_VENDOR_WEBGL)), this._glVendor || (this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor"), this._glRenderer || (this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer"), this._gl.HALF_FLOAT_OES !== 36193 && (this._gl.HALF_FLOAT_OES = 36193), this._gl.RGBA16F !== 34842 && (this._gl.RGBA16F = 34842), this._gl.RGBA32F !== 34836 && (this._gl.RGBA32F = 34836), this._gl.DEPTH24_STENCIL8 !== 35056 && (this._gl.DEPTH24_STENCIL8 = 35056), this._caps.timerQuery && (this._webGLVersion === 1 && (this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)), this._caps.canUseTimestampForTimerQuery = ((e = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT)) !== null && e !== void 0 ? e : 0) > 0), this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, this._caps.textureFloatLinearFiltering = !!(this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear")), this._caps.textureFloatRender = !!(this._caps.textureFloat && this._canRenderToFloatFramebuffer()), this._caps.textureHalfFloatLinearFiltering = !!(this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear")), this._caps.astc && (this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR), this._caps.bptc && (this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT), this._caps.s3tc_srgb && (this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT, this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT), this._caps.etc2 && (this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2, this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC), this._webGLVersion > 1 && this._gl.HALF_FLOAT_OES !== 5131 && (this._gl.HALF_FLOAT_OES = 5131), this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer(), this._webGLVersion > 1) this._caps.drawBuffersExtension = !0, this._caps.maxMSAASamples = this._maxMSAASamplesOverride !== null ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES); else { const i = this._gl.getExtension("WEBGL_draw_buffers"); if (i !== null) { this._caps.drawBuffersExtension = !0, this._gl.drawBuffers = i.drawBuffersWEBGL.bind(i), this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER; for (let s = 0; s < 16; s++)this._gl["COLOR_ATTACHMENT" + s + "_WEBGL"] = i["COLOR_ATTACHMENT" + s + "_WEBGL"] } } if (this._webGLVersion > 1) this._caps.depthTextureExtension = !0; else { const i = this._gl.getExtension("WEBGL_depth_texture"); i != null && (this._caps.depthTextureExtension = !0, this._gl.UNSIGNED_INT_24_8 = i.UNSIGNED_INT_24_8_WEBGL) } if (this.disableVertexArrayObjects) this._caps.vertexArrayObject = !1; else if (this._webGLVersion > 1) this._caps.vertexArrayObject = !0; else { const i = this._gl.getExtension("OES_vertex_array_object"); i != null && (this._caps.vertexArrayObject = !0, this._gl.createVertexArray = i.createVertexArrayOES.bind(i), this._gl.bindVertexArray = i.bindVertexArrayOES.bind(i), this._gl.deleteVertexArray = i.deleteVertexArrayOES.bind(i)) } if (this._webGLVersion > 1) this._caps.instancedArrays = !0; else { const i = this._gl.getExtension("ANGLE_instanced_arrays"); i != null ? (this._caps.instancedArrays = !0, this._gl.drawArraysInstanced = i.drawArraysInstancedANGLE.bind(i), this._gl.drawElementsInstanced = i.drawElementsInstancedANGLE.bind(i), this._gl.vertexAttribDivisor = i.vertexAttribDivisorANGLE.bind(i)) : this._caps.instancedArrays = !1 } if (this._gl.getShaderPrecisionFormat) { const i = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT), s = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT); i && s && (this._caps.highPrecisionShaderSupported = i.precision !== 0 && s.precision !== 0) } if (this._webGLVersion > 1) this._caps.blendMinMax = !0; else { const i = this._gl.getExtension("EXT_blend_minmax"); i != null && (this._caps.blendMinMax = !0, this._gl.MAX = i.MAX_EXT, this._gl.MIN = i.MIN_EXT) } if (!this._caps.supportSRGBBuffers) { if (this._webGLVersion > 1) this._caps.supportSRGBBuffers = !0, this._glSRGBExtensionValues = { SRGB: WebGL2RenderingContext.SRGB, SRGB8: WebGL2RenderingContext.SRGB8, SRGB8_ALPHA8: WebGL2RenderingContext.SRGB8_ALPHA8 }; else { const i = this._gl.getExtension("EXT_sRGB"); i != null && (this._caps.supportSRGBBuffers = !0, this._glSRGBExtensionValues = { SRGB: i.SRGB_EXT, SRGB8: i.SRGB_ALPHA_EXT, SRGB8_ALPHA8: i.SRGB_ALPHA_EXT }) } this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && this._creationOptions.forceSRGBBufferSupportState) } this._depthCullingState.depthTest = !0, this._depthCullingState.depthFunc = this._gl.LEQUAL, this._depthCullingState.depthMask = !0, this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits; for (let i = 0; i < this._maxSimultaneousTextures; i++)this._nextFreeTextureSlots.push(i); this._glRenderer === "Mali-G72" && (this._caps.disableMorphTargetTexture = !0) } _initFeatures() { this._features = { forceBitmapOverHTMLImageElement: !1, supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1, supportDepthStencilTexture: this._webGLVersion !== 1, supportShadowSamplers: this._webGLVersion !== 1, uniformBufferHardCheckMatrix: !1, allowTexturePrefiltering: this._webGLVersion !== 1, trackUbosInFrame: !1, checkUbosContentBeforeUpload: !1, supportCSM: this._webGLVersion !== 1, basisNeedsPOT: this._webGLVersion === 1, support3DTextures: this._webGLVersion !== 1, needTypeSuffixInShaderConstants: this._webGLVersion !== 1, supportMSAA: this._webGLVersion !== 1, supportSSAO2: this._webGLVersion !== 1, supportExtendedTextureFormats: this._webGLVersion !== 1, supportSwitchCaseInShader: this._webGLVersion !== 1, supportSyncTextureRead: !0, needsInvertingBitmap: !0, useUBOBindingCache: !0, needShaderCodeInlining: !1, needToAlwaysBindUniformBuffers: !1, supportRenderPasses: !1, supportSpriteInstancing: !0, forceVertexBufferStrideMultiple4Bytes: !1, _collectUbosUpdatedInFrame: !1 } } get webGLVersion() { return this._webGLVersion } getClassName() { return "ThinEngine" } get isStencilEnable() { return this._isStencilEnable } _prepareWorkingCanvas() { if (this._workingCanvas) return; this._workingCanvas = this.createCanvas(1, 1); const e = this._workingCanvas.getContext("2d"); e && (this._workingContext = e) } resetTextureCache() { for (const e in this._boundTexturesCache) Object.prototype.hasOwnProperty.call(this._boundTexturesCache, e) && (this._boundTexturesCache[e] = null); this._currentTextureChannel = -1 } getInfo() { return this.getGlInfo() } getGlInfo() { return { vendor: this._glVendor, renderer: this._glRenderer, version: this._glVersion } } setHardwareScalingLevel(e) { this._hardwareScalingLevel = e, this.resize() } getHardwareScalingLevel() { return this._hardwareScalingLevel } getLoadedTexturesCache() { return this._internalTexturesCache } getCaps() { return this._caps } stopRenderLoop(e) { if (!e) { this._activeRenderLoops.length = 0, this._cancelFrame(); return } const t = this._activeRenderLoops.indexOf(e); t >= 0 && (this._activeRenderLoops.splice(t, 1), this._activeRenderLoops.length == 0 && this._cancelFrame()) } _cancelFrame() { if (this._renderingQueueLaunched && this._frameHandler) { if (this._renderingQueueLaunched = !1, Fe()) { const { cancelAnimationFrame: e } = this.getHostWindow() || window; if (typeof e == "function") return e(this._frameHandler) } else if (typeof cancelAnimationFrame == "function") return cancelAnimationFrame(this._frameHandler); return clearTimeout(this._frameHandler) } } _renderLoop() { if (!this._contextWasLost) { let e = !0; if ((this._isDisposed || !this.renderEvenInBackground && this._windowIsBackground) && (e = !1), e) { this.beginFrame(); for (let t = 0; t < this._activeRenderLoops.length; t++) { const i = this._activeRenderLoops[t]; i() } this.endFrame() } } this._activeRenderLoops.length > 0 ? this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()) : this._renderingQueueLaunched = !1 } getRenderingCanvas() { return this._renderingCanvas } getAudioContext() { return this._audioContext } getAudioDestination() { return this._audioDestination } getHostWindow() { return Fe() ? this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView ? this._renderingCanvas.ownerDocument.defaultView : window : null } getRenderWidth(e = !1) { return !e && this._currentRenderTarget ? this._currentRenderTarget.width : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth } getRenderHeight(e = !1) { return !e && this._currentRenderTarget ? this._currentRenderTarget.height : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight } _queueNewFrame(e, t) { return $.QueueNewFrame(e, t) } runRenderLoop(e) { this._activeRenderLoops.indexOf(e) === -1 && (this._activeRenderLoops.push(e), this._renderingQueueLaunched || (this._renderingQueueLaunched = !0, this._boundRenderFunction = () => this._renderLoop(), this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()))) } clear(e, t, i, s = !1) { var r, n; const a = this.stencilStateComposer.useStencilGlobalOnly; this.stencilStateComposer.useStencilGlobalOnly = !0, this.applyStates(), this.stencilStateComposer.useStencilGlobalOnly = a; let o = 0; if (t && e) { let l = !0; if (this._currentRenderTarget) { const h = (r = this._currentRenderTarget.texture) === null || r === void 0 ? void 0 : r.format; if (h === 8 || h === 9 || h === 10 || h === 11) { const u = (n = this._currentRenderTarget.texture) === null || n === void 0 ? void 0 : n.type; u === 7 || u === 5 ? ($._TempClearColorUint32[0] = e.r * 255, $._TempClearColorUint32[1] = e.g * 255, $._TempClearColorUint32[2] = e.b * 255, $._TempClearColorUint32[3] = e.a * 255, this._gl.clearBufferuiv(this._gl.COLOR, 0, $._TempClearColorUint32), l = !1) : ($._TempClearColorInt32[0] = e.r * 255, $._TempClearColorInt32[1] = e.g * 255, $._TempClearColorInt32[2] = e.b * 255, $._TempClearColorInt32[3] = e.a * 255, this._gl.clearBufferiv(this._gl.COLOR, 0, $._TempClearColorInt32), l = !1) } } l && (this._gl.clearColor(e.r, e.g, e.b, e.a !== void 0 ? e.a : 1), o |= this._gl.COLOR_BUFFER_BIT) } i && (this.useReverseDepthBuffer ? (this._depthCullingState.depthFunc = this._gl.GEQUAL, this._gl.clearDepth(0)) : this._gl.clearDepth(1), o |= this._gl.DEPTH_BUFFER_BIT), s && (this._gl.clearStencil(0), o |= this._gl.STENCIL_BUFFER_BIT), this._gl.clear(o) } _viewport(e, t, i, s) { (e !== this._viewportCached.x || t !== this._viewportCached.y || i !== this._viewportCached.z || s !== this._viewportCached.w) && (this._viewportCached.x = e, this._viewportCached.y = t, this._viewportCached.z = i, this._viewportCached.w = s, this._gl.viewport(e, t, i, s)) } setViewport(e, t, i) { const s = t || this.getRenderWidth(), r = i || this.getRenderHeight(), n = e.x || 0, a = e.y || 0; this._cachedViewport = e, this._viewport(n * s, a * r, s * e.width, r * e.height) } beginFrame() { } endFrame() { this._badOS && this.flushFramebuffer(), this._frameId++ } resize(e = !1) { let t, i; if (this.adaptToDeviceRatio) { const s = Fe() && window.devicePixelRatio || 1, r = this._lastDevicePixelRatio / s; this._lastDevicePixelRatio = s, this._hardwareScalingLevel *= r } if (Fe() && Qt()) if (this._renderingCanvas) { const s = this._renderingCanvas.getBoundingClientRect ? this._renderingCanvas.getBoundingClientRect() : { width: this._renderingCanvas.width * this._hardwareScalingLevel, height: this._renderingCanvas.height * this._hardwareScalingLevel }; t = this._renderingCanvas.clientWidth || s.width || this._renderingCanvas.width || 100, i = this._renderingCanvas.clientHeight || s.height || this._renderingCanvas.height || 100 } else t = window.innerWidth, i = window.innerHeight; else t = this._renderingCanvas ? this._renderingCanvas.width : 100, i = this._renderingCanvas ? this._renderingCanvas.height : 100; this.setSize(t / this._hardwareScalingLevel, i / this._hardwareScalingLevel, e) } setSize(e, t, i = !1) { return !this._renderingCanvas || (e = e | 0, t = t | 0, !i && this._renderingCanvas.width === e && this._renderingCanvas.height === t) ? !1 : (this._renderingCanvas.width = e, this._renderingCanvas.height = t, !0) } bindFramebuffer(e, t = 0, i, s, r, n = 0, a = 0) { var o, l, h, u, f, _; const p = e; this._currentRenderTarget && this.unBindFramebuffer(this._currentRenderTarget), this._currentRenderTarget = e, this._bindUnboundFramebuffer(p._MSAAFramebuffer ? p._MSAAFramebuffer : p._framebuffer); const v = this._gl; e.isMulti || (e.is2DArray ? v.framebufferTextureLayer(v.FRAMEBUFFER, v.COLOR_ATTACHMENT0, (o = e.texture._hardwareTexture) === null || o === void 0 ? void 0 : o.underlyingResource, n, a) : e.isCube ? v.framebufferTexture2D(v.FRAMEBUFFER, v.COLOR_ATTACHMENT0, v.TEXTURE_CUBE_MAP_POSITIVE_X + t, (l = e.texture._hardwareTexture) === null || l === void 0 ? void 0 : l.underlyingResource, n) : p._currentLOD !== n && (v.framebufferTexture2D(v.FRAMEBUFFER, v.COLOR_ATTACHMENT0, v.TEXTURE_2D, (h = e.texture._hardwareTexture) === null || h === void 0 ? void 0 : h.underlyingResource, n), p._currentLOD = n)); const E = e._depthStencilTexture; if (E) { const m = e._depthStencilTextureWithStencil ? v.DEPTH_STENCIL_ATTACHMENT : v.DEPTH_ATTACHMENT; e.is2DArray ? v.framebufferTextureLayer(v.FRAMEBUFFER, m, (u = E._hardwareTexture) === null || u === void 0 ? void 0 : u.underlyingResource, n, a) : e.isCube ? v.framebufferTexture2D(v.FRAMEBUFFER, m, v.TEXTURE_CUBE_MAP_POSITIVE_X + t, (f = E._hardwareTexture) === null || f === void 0 ? void 0 : f.underlyingResource, n) : v.framebufferTexture2D(v.FRAMEBUFFER, m, v.TEXTURE_2D, (_ = E._hardwareTexture) === null || _ === void 0 ? void 0 : _.underlyingResource, n) } this._cachedViewport && !r ? this.setViewport(this._cachedViewport, i, s) : (i || (i = e.width, n && (i = i / Math.pow(2, n))), s || (s = e.height, n && (s = s / Math.pow(2, n))), this._viewport(0, 0, i, s)), this.wipeCaches() } setState(e, t = 0, i, s = !1, r, n, a = 0) { var o, l; (this._depthCullingState.cull !== e || i) && (this._depthCullingState.cull = e); const h = !((l = (o = this.cullBackFaces) !== null && o !== void 0 ? o : r) !== null && l !== void 0) || l ? this._gl.BACK : this._gl.FRONT; (this._depthCullingState.cullFace !== h || i) && (this._depthCullingState.cullFace = h), this.setZOffset(t), this.setZOffsetUnits(a); const u = s ? this._gl.CW : this._gl.CCW; (this._depthCullingState.frontFace !== u || i) && (this._depthCullingState.frontFace = u), this._stencilStateComposer.stencilMaterial = n } getDepthBuffer() { return this._depthCullingState.depthTest } setDepthBuffer(e) { this._depthCullingState.depthTest = e } setZOffset(e) { this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -e : e } getZOffset() { const e = this._depthCullingState.zOffset; return this.useReverseDepthBuffer ? -e : e } setZOffsetUnits(e) { this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -e : e } getZOffsetUnits() { const e = this._depthCullingState.zOffsetUnits; return this.useReverseDepthBuffer ? -e : e } _bindUnboundFramebuffer(e) { this._currentFramebuffer !== e && (this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, e), this._currentFramebuffer = e) } _currentFrameBufferIsDefaultFrameBuffer() { return this._currentFramebuffer === null } generateMipmaps(e) { this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null) } unBindFramebuffer(e, t = !1, i) { var s; const r = e; this._currentRenderTarget = null; const n = this._gl; if (r._MSAAFramebuffer) { if (e.isMulti) { this.unBindMultiColorAttachmentFramebuffer(e, t, i); return } n.bindFramebuffer(n.READ_FRAMEBUFFER, r._MSAAFramebuffer), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, r._framebuffer), n.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, n.COLOR_BUFFER_BIT, n.NEAREST) } !((s = e.texture) === null || s === void 0) && s.generateMipMaps && !t && !e.isCube && this.generateMipmaps(e.texture), i && (r._MSAAFramebuffer && this._bindUnboundFramebuffer(r._framebuffer), i()), this._bindUnboundFramebuffer(null) } flushFramebuffer() { this._gl.flush() } restoreDefaultFramebuffer() { this._currentRenderTarget ? this.unBindFramebuffer(this._currentRenderTarget) : this._bindUnboundFramebuffer(null), this._cachedViewport && this.setViewport(this._cachedViewport), this.wipeCaches() } _resetVertexBufferBinding() { this.bindArrayBuffer(null), this._cachedVertexBuffers = null } createVertexBuffer(e, t, i) { return this._createVertexBuffer(e, this._gl.STATIC_DRAW) } _createVertexBuffer(e, t) { const i = this._gl.createBuffer(); if (!i) throw new Error("Unable to create vertex buffer"); const s = new ii(i); return this.bindArrayBuffer(s), e instanceof Array ? this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(e), t) : this._gl.bufferData(this._gl.ARRAY_BUFFER, e, t), this._resetVertexBufferBinding(), s.references = 1, s } createDynamicVertexBuffer(e, t) { return this._createVertexBuffer(e, this._gl.DYNAMIC_DRAW) } _resetIndexBufferBinding() { this.bindIndexBuffer(null), this._cachedIndexBuffer = null } createIndexBuffer(e, t, i) { const s = this._gl.createBuffer(), r = new ii(s); if (!s) throw new Error("Unable to create index buffer"); this.bindIndexBuffer(r); const n = this._normalizeIndexData(e); return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, n, t ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW), this._resetIndexBufferBinding(), r.references = 1, r.is32Bits = n.BYTES_PER_ELEMENT === 4, r } _normalizeIndexData(e) { if (e.BYTES_PER_ELEMENT === 2) return e; if (this._caps.uintIndices) { if (e instanceof Uint32Array) return e; for (let i = 0; i < e.length; i++)if (e[i] >= 65535) return new Uint32Array(e); return new Uint16Array(e) } return new Uint16Array(e) } bindArrayBuffer(e) { this._vaoRecordInProgress || this._unbindVertexArrayObject(), this._bindBuffer(e, this._gl.ARRAY_BUFFER) } bindUniformBlock(e, t, i) { const s = e.program, r = this._gl.getUniformBlockIndex(s, t); this._gl.uniformBlockBinding(s, r, i) } bindIndexBuffer(e) { this._vaoRecordInProgress || this._unbindVertexArrayObject(), this._bindBuffer(e, this._gl.ELEMENT_ARRAY_BUFFER) } _bindBuffer(e, t) { (this._vaoRecordInProgress || this._currentBoundBuffer[t] !== e) && (this._gl.bindBuffer(t, e ? e.underlyingResource : null), this._currentBoundBuffer[t] = e) } updateArrayBuffer(e) { this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e) } _vertexAttribPointer(e, t, i, s, r, n, a) { const o = this._currentBufferPointers[t]; if (!o) return; let l = !1; o.active ? (o.buffer !== e && (o.buffer = e, l = !0), o.size !== i && (o.size = i, l = !0), o.type !== s && (o.type = s, l = !0), o.normalized !== r && (o.normalized = r, l = !0), o.stride !== n && (o.stride = n, l = !0), o.offset !== a && (o.offset = a, l = !0)) : (l = !0, o.active = !0, o.index = t, o.size = i, o.type = s, o.normalized = r, o.stride = n, o.offset = a, o.buffer = e), (l || this._vaoRecordInProgress) && (this.bindArrayBuffer(e), s === this._gl.UNSIGNED_INT || s === this._gl.INT ? this._gl.vertexAttribIPointer(t, i, s, n, a) : this._gl.vertexAttribPointer(t, i, s, r, n, a)) } _bindIndexBufferWithCache(e) { e != null && this._cachedIndexBuffer !== e && (this._cachedIndexBuffer = e, this.bindIndexBuffer(e), this._uintIndicesCurrentlySet = e.is32Bits) } _bindVertexBuffersAttributes(e, t, i) { const s = t.getAttributesNames(); this._vaoRecordInProgress || this._unbindVertexArrayObject(), this.unbindAllAttributes(); for (let r = 0; r < s.length; r++) { const n = t.getAttributeLocation(r); if (n >= 0) { const a = s[r]; let o = null; if (i && (o = i[a]), o || (o = e[a]), !o) continue; this._gl.enableVertexAttribArray(n), this._vaoRecordInProgress || (this._vertexAttribArraysEnabled[n] = !0); const l = o.getBuffer(); l && (this._vertexAttribPointer(l, n, o.getSize(), o.type, o.normalized, o.byteStride, o.byteOffset), o.getIsInstanced() && (this._gl.vertexAttribDivisor(n, o.getInstanceDivisor()), this._vaoRecordInProgress || (this._currentInstanceLocations.push(n), this._currentInstanceBuffers.push(l)))) } } } recordVertexArrayObject(e, t, i, s) { const r = this._gl.createVertexArray(); if (!r) throw new Error("Unable to create VAO"); return this._vaoRecordInProgress = !0, this._gl.bindVertexArray(r), this._mustWipeVertexAttributes = !0, this._bindVertexBuffersAttributes(e, i, s), this.bindIndexBuffer(t), this._vaoRecordInProgress = !1, this._gl.bindVertexArray(null), r } bindVertexArrayObject(e, t) { this._cachedVertexArrayObject !== e && (this._cachedVertexArrayObject = e, this._gl.bindVertexArray(e), this._cachedVertexBuffers = null, this._cachedIndexBuffer = null, this._uintIndicesCurrentlySet = t != null && t.is32Bits, this._mustWipeVertexAttributes = !0) } bindBuffersDirectly(e, t, i, s, r) { if (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== r) { this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = r; const n = r.getAttributesCount(); this._unbindVertexArrayObject(), this.unbindAllAttributes(); let a = 0; for (let o = 0; o < n; o++)if (o < i.length) { const l = r.getAttributeLocation(o); l >= 0 && (this._gl.enableVertexAttribArray(l), this._vertexAttribArraysEnabled[l] = !0, this._vertexAttribPointer(e, l, i[o], this._gl.FLOAT, !1, s, a)), a += i[o] * 4 } } this._bindIndexBufferWithCache(t) } _unbindVertexArrayObject() { this._cachedVertexArrayObject && (this._cachedVertexArrayObject = null, this._gl.bindVertexArray(null)) } bindBuffers(e, t, i, s) { (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== i) && (this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = i, this._bindVertexBuffersAttributes(e, i, s)), this._bindIndexBufferWithCache(t) } unbindInstanceAttributes() { let e; for (let t = 0, i = this._currentInstanceLocations.length; t < i; t++) { const s = this._currentInstanceBuffers[t]; e != s && s.references && (e = s, this.bindArrayBuffer(s)); const r = this._currentInstanceLocations[t]; this._gl.vertexAttribDivisor(r, 0) } this._currentInstanceBuffers.length = 0, this._currentInstanceLocations.length = 0 } releaseVertexArrayObject(e) { this._gl.deleteVertexArray(e) } _releaseBuffer(e) { return e.references--, e.references === 0 ? (this._deleteBuffer(e), !0) : !1 } _deleteBuffer(e) { this._gl.deleteBuffer(e.underlyingResource) } updateAndBindInstancesBuffer(e, t, i) { if (this.bindArrayBuffer(e), t && this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t), i[0].index !== void 0) this.bindInstancesBuffer(e, i, !0); else for (let s = 0; s < 4; s++) { const r = i[s]; this._vertexAttribArraysEnabled[r] || (this._gl.enableVertexAttribArray(r), this._vertexAttribArraysEnabled[r] = !0), this._vertexAttribPointer(e, r, 4, this._gl.FLOAT, !1, 64, s * 16), this._gl.vertexAttribDivisor(r, 1), this._currentInstanceLocations.push(r), this._currentInstanceBuffers.push(e) } } bindInstancesBuffer(e, t, i = !0) { this.bindArrayBuffer(e); let s = 0; if (i) for (let r = 0; r < t.length; r++) { const n = t[r]; s += n.attributeSize * 4 } for (let r = 0; r < t.length; r++) { const n = t[r]; n.index === void 0 && (n.index = this._currentEffect.getAttributeLocationByName(n.attributeName)), !(n.index < 0) && (this._vertexAttribArraysEnabled[n.index] || (this._gl.enableVertexAttribArray(n.index), this._vertexAttribArraysEnabled[n.index] = !0), this._vertexAttribPointer(e, n.index, n.attributeSize, n.attributeType || this._gl.FLOAT, n.normalized || !1, s, n.offset), this._gl.vertexAttribDivisor(n.index, n.divisor === void 0 ? 1 : n.divisor), this._currentInstanceLocations.push(n.index), this._currentInstanceBuffers.push(e)) } } disableInstanceAttributeByName(e) { if (!this._currentEffect) return; const t = this._currentEffect.getAttributeLocationByName(e); this.disableInstanceAttribute(t) } disableInstanceAttribute(e) { let t = !1, i; for (; (i = this._currentInstanceLocations.indexOf(e)) !== -1;)this._currentInstanceLocations.splice(i, 1), this._currentInstanceBuffers.splice(i, 1), t = !0, i = this._currentInstanceLocations.indexOf(e); t && (this._gl.vertexAttribDivisor(e, 0), this.disableAttributeByIndex(e)) } disableAttributeByIndex(e) { this._gl.disableVertexAttribArray(e), this._vertexAttribArraysEnabled[e] = !1, this._currentBufferPointers[e].active = !1 } draw(e, t, i, s) { this.drawElementsType(e ? 0 : 1, t, i, s) } drawPointClouds(e, t, i) { this.drawArraysType(2, e, t, i) } drawUnIndexed(e, t, i, s) { this.drawArraysType(e ? 0 : 1, t, i, s) } drawElementsType(e, t, i, s) { this.applyStates(), this._reportDrawCall(); const r = this._drawMode(e), n = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT, a = this._uintIndicesCurrentlySet ? 4 : 2; s ? this._gl.drawElementsInstanced(r, i, n, t * a, s) : this._gl.drawElements(r, i, n, t * a) } drawArraysType(e, t, i, s) { this.applyStates(), this._reportDrawCall(); const r = this._drawMode(e); s ? this._gl.drawArraysInstanced(r, t, i, s) : this._gl.drawArrays(r, t, i) } _drawMode(e) { switch (e) { case 0: return this._gl.TRIANGLES; case 2: return this._gl.POINTS; case 1: return this._gl.LINES; case 3: return this._gl.POINTS; case 4: return this._gl.LINES; case 5: return this._gl.LINE_LOOP; case 6: return this._gl.LINE_STRIP; case 7: return this._gl.TRIANGLE_STRIP; case 8: return this._gl.TRIANGLE_FAN; default: return this._gl.TRIANGLES } } _reportDrawCall() { } _releaseEffect(e) { this._compiledEffects[e._key] && delete this._compiledEffects[e._key]; const t = e.getPipelineContext(); t && this._deletePipelineContext(t) } _deletePipelineContext(e) { const t = e; t && t.program && (t.program.__SPECTOR_rebuildProgram = null, this._gl.deleteProgram(t.program)) } _getGlobalDefines(e) {
            if (e) { this.isNDCHalfZRange ? e.IS_NDC_HALF_ZRANGE = "" : delete e.IS_NDC_HALF_ZRANGE, this.useReverseDepthBuffer ? e.USE_REVERSE_DEPTHBUFFER = "" : delete e.USE_REVERSE_DEPTHBUFFER, this.useExactSrgbConversions ? e.USE_EXACT_SRGB_CONVERSIONS = "" : delete e.USE_EXACT_SRGB_CONVERSIONS; return } else {
                let t = ""; return this.isNDCHalfZRange && (t += "#define IS_NDC_HALF_ZRANGE"), this.useReverseDepthBuffer && (t && (t += `
`), t += "#define USE_REVERSE_DEPTHBUFFER"), this.useExactSrgbConversions && (t && (t += `
`), t += "#define USE_EXACT_SRGB_CONVERSIONS"), t
            }
        } createEffect(e, t, i, s, r, n, a, o, l, h = we.GLSL) { var u; const f = e.vertexElement || e.vertex || e.vertexToken || e.vertexSource || e, _ = e.fragmentElement || e.fragment || e.fragmentToken || e.fragmentSource || e, p = this._getGlobalDefines(); let v = (u = r ?? t.defines) !== null && u !== void 0 ? u : ""; p && (v += p); const E = f + "+" + _ + "@" + v; if (this._compiledEffects[E]) { const x = this._compiledEffects[E]; return a && x.isReady() && a(x), x } const m = new Ve(e, t, i, s, this, r, n, a, o, l, E, h); return this._compiledEffects[E] = m, m } static _ConcatenateShader(e, t, i = "") {
            return i + (t ? t + `
`: "") + e
        } _compileShader(e, t, i, s) { return this._compileRawShader($._ConcatenateShader(e, i, s), t) } _compileRawShader(e, t) { const i = this._gl, s = i.createShader(t === "vertex" ? i.VERTEX_SHADER : i.FRAGMENT_SHADER); if (!s) { let r = i.NO_ERROR, n = i.NO_ERROR; for (; (n = i.getError()) !== i.NO_ERROR;)r = n; throw new Error(`Something went wrong while creating a gl ${t} shader object. gl error=${r}, gl isContextLost=${i.isContextLost()}, _contextWasLost=${this._contextWasLost}`) } return i.shaderSource(s, e), i.compileShader(s), s } _getShaderSource(e) { return this._gl.getShaderSource(e) } createRawShaderProgram(e, t, i, s, r = null) { s = s || this._gl; const n = this._compileRawShader(t, "vertex"), a = this._compileRawShader(i, "fragment"); return this._createShaderProgram(e, n, a, s, r) } createShaderProgram(e, t, i, s, r, n = null) {
            r = r || this._gl; const a = this._webGLVersion > 1 ? `#version 300 es
#define WEBGL2 
`: "", o = this._compileShader(t, "vertex", s, a), l = this._compileShader(i, "fragment", s, a); return this._createShaderProgram(e, o, l, r, n)
        } inlineShaderCode(e) { return e } createPipelineContext(e) { const t = new Or; return t.engine = this, this._caps.parallelShaderCompile && (t.isParallelCompiled = !0), t } createMaterialContext() { } createDrawContext() { } _createShaderProgram(e, t, i, s, r = null) { const n = s.createProgram(); if (e.program = n, !n) throw new Error("Unable to create program"); return s.attachShader(n, t), s.attachShader(n, i), s.linkProgram(n), e.context = s, e.vertexShader = t, e.fragmentShader = i, e.isParallelCompiled || this._finalizePipelineContext(e), n } _finalizePipelineContext(e) { const t = e.context, i = e.vertexShader, s = e.fragmentShader, r = e.program; if (!t.getProgramParameter(r, t.LINK_STATUS)) { if (!this._gl.getShaderParameter(i, this._gl.COMPILE_STATUS)) { const o = this._gl.getShaderInfoLog(i); if (o) throw e.vertexCompilationError = o, new Error("VERTEX SHADER " + o) } if (!this._gl.getShaderParameter(s, this._gl.COMPILE_STATUS)) { const o = this._gl.getShaderInfoLog(s); if (o) throw e.fragmentCompilationError = o, new Error("FRAGMENT SHADER " + o) } const a = t.getProgramInfoLog(r); if (a) throw e.programLinkError = a, new Error(a) } if (this.validateShaderPrograms && (t.validateProgram(r), !t.getProgramParameter(r, t.VALIDATE_STATUS))) { const o = t.getProgramInfoLog(r); if (o) throw e.programValidationError = o, new Error(o) } t.deleteShader(i), t.deleteShader(s), e.vertexShader = void 0, e.fragmentShader = void 0, e.onCompiled && (e.onCompiled(), e.onCompiled = void 0) } _preparePipelineContext(e, t, i, s, r, n, a, o, l, h) { const u = e; s ? u.program = this.createRawShaderProgram(u, t, i, void 0, l) : u.program = this.createShaderProgram(u, t, i, o, void 0, l), u.program.__SPECTOR_rebuildProgram = a } _isRenderingStateCompiled(e) { const t = e; return this._isDisposed || t._isDisposed ? !1 : this._gl.getProgramParameter(t.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR) ? (this._finalizePipelineContext(t), !0) : !1 } _executeWhenRenderingStateIsCompiled(e, t) { const i = e; if (!i.isParallelCompiled) { t(); return } const s = i.onCompiled; s ? i.onCompiled = () => { s(), t() } : i.onCompiled = t } getUniforms(e, t) { const i = new Array, s = e; for (let r = 0; r < t.length; r++)i.push(this._gl.getUniformLocation(s.program, t[r])); return i } getAttributes(e, t) { const i = [], s = e; for (let r = 0; r < t.length; r++)try { i.push(this._gl.getAttribLocation(s.program, t[r])) } catch { i.push(-1) } return i } enableEffect(e) { e = e !== null && Li.IsWrapper(e) ? e.effect : e, !(!e || e === this._currentEffect) && (this._stencilStateComposer.stencilMaterial = void 0, e = e, this.bindSamplers(e), this._currentEffect = e, e.onBind && e.onBind(e), e._onBindObservable && e._onBindObservable.notifyObservers(e)) } setInt(e, t) { return e ? (this._gl.uniform1i(e, t), !0) : !1 } setInt2(e, t, i) { return e ? (this._gl.uniform2i(e, t, i), !0) : !1 } setInt3(e, t, i, s) { return e ? (this._gl.uniform3i(e, t, i, s), !0) : !1 } setInt4(e, t, i, s, r) { return e ? (this._gl.uniform4i(e, t, i, s, r), !0) : !1 } setIntArray(e, t) { return e ? (this._gl.uniform1iv(e, t), !0) : !1 } setIntArray2(e, t) { return !e || t.length % 2 !== 0 ? !1 : (this._gl.uniform2iv(e, t), !0) } setIntArray3(e, t) { return !e || t.length % 3 !== 0 ? !1 : (this._gl.uniform3iv(e, t), !0) } setIntArray4(e, t) { return !e || t.length % 4 !== 0 ? !1 : (this._gl.uniform4iv(e, t), !0) } setUInt(e, t) { return e ? (this._gl.uniform1ui(e, t), !0) : !1 } setUInt2(e, t, i) { return e ? (this._gl.uniform2ui(e, t, i), !0) : !1 } setUInt3(e, t, i, s) { return e ? (this._gl.uniform3ui(e, t, i, s), !0) : !1 } setUInt4(e, t, i, s, r) { return e ? (this._gl.uniform4ui(e, t, i, s, r), !0) : !1 } setUIntArray(e, t) { return e ? (this._gl.uniform1uiv(e, t), !0) : !1 } setUIntArray2(e, t) { return !e || t.length % 2 !== 0 ? !1 : (this._gl.uniform2uiv(e, t), !0) } setUIntArray3(e, t) { return !e || t.length % 3 !== 0 ? !1 : (this._gl.uniform3uiv(e, t), !0) } setUIntArray4(e, t) { return !e || t.length % 4 !== 0 ? !1 : (this._gl.uniform4uiv(e, t), !0) } setArray(e, t) { return !e || t.length < 1 ? !1 : (this._gl.uniform1fv(e, t), !0) } setArray2(e, t) { return !e || t.length % 2 !== 0 ? !1 : (this._gl.uniform2fv(e, t), !0) } setArray3(e, t) { return !e || t.length % 3 !== 0 ? !1 : (this._gl.uniform3fv(e, t), !0) } setArray4(e, t) { return !e || t.length % 4 !== 0 ? !1 : (this._gl.uniform4fv(e, t), !0) } setMatrices(e, t) { return e ? (this._gl.uniformMatrix4fv(e, !1, t), !0) : !1 } setMatrix3x3(e, t) { return e ? (this._gl.uniformMatrix3fv(e, !1, t), !0) : !1 } setMatrix2x2(e, t) { return e ? (this._gl.uniformMatrix2fv(e, !1, t), !0) : !1 } setFloat(e, t) { return e ? (this._gl.uniform1f(e, t), !0) : !1 } setFloat2(e, t, i) { return e ? (this._gl.uniform2f(e, t, i), !0) : !1 } setFloat3(e, t, i, s) { return e ? (this._gl.uniform3f(e, t, i, s), !0) : !1 } setFloat4(e, t, i, s, r) { return e ? (this._gl.uniform4f(e, t, i, s, r), !0) : !1 } applyStates() { if (this._depthCullingState.apply(this._gl), this._stencilStateComposer.apply(this._gl), this._alphaState.apply(this._gl), this._colorWriteChanged) { this._colorWriteChanged = !1; const e = this._colorWrite; this._gl.colorMask(e, e, e, e) } } setColorWrite(e) { e !== this._colorWrite && (this._colorWriteChanged = !0, this._colorWrite = e) } getColorWrite() { return this._colorWrite } get depthCullingState() { return this._depthCullingState } get alphaState() { return this._alphaState } get stencilState() { return this._stencilState } get stencilStateComposer() { return this._stencilStateComposer } clearInternalTexturesCache() { this._internalTexturesCache.length = 0 } wipeCaches(e) { this.preventCacheWipeBetweenFrames && !e || (this._currentEffect = null, this._viewportCached.x = 0, this._viewportCached.y = 0, this._viewportCached.z = 0, this._viewportCached.w = 0, this._unbindVertexArrayObject(), e && (this._currentProgram = null, this.resetTextureCache(), this._stencilStateComposer.reset(), this._depthCullingState.reset(), this._depthCullingState.depthFunc = this._gl.LEQUAL, this._alphaState.reset(), this._alphaMode = 1, this._alphaEquation = 0, this._colorWrite = !0, this._colorWriteChanged = !0, this._unpackFlipYCached = null, this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE), this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), this._mustWipeVertexAttributes = !0, this.unbindAllAttributes()), this._resetVertexBufferBinding(), this._cachedIndexBuffer = null, this._cachedEffectForVertexBuffers = null, this.bindIndexBuffer(null)) } _getSamplingParameters(e, t) { const i = this._gl; let s = i.NEAREST, r = i.NEAREST; switch (e) { case 11: s = i.LINEAR, t ? r = i.LINEAR_MIPMAP_NEAREST : r = i.LINEAR; break; case 3: s = i.LINEAR, t ? r = i.LINEAR_MIPMAP_LINEAR : r = i.LINEAR; break; case 8: s = i.NEAREST, t ? r = i.NEAREST_MIPMAP_LINEAR : r = i.NEAREST; break; case 4: s = i.NEAREST, t ? r = i.NEAREST_MIPMAP_NEAREST : r = i.NEAREST; break; case 5: s = i.NEAREST, t ? r = i.LINEAR_MIPMAP_NEAREST : r = i.LINEAR; break; case 6: s = i.NEAREST, t ? r = i.LINEAR_MIPMAP_LINEAR : r = i.LINEAR; break; case 7: s = i.NEAREST, r = i.LINEAR; break; case 1: s = i.NEAREST, r = i.NEAREST; break; case 9: s = i.LINEAR, t ? r = i.NEAREST_MIPMAP_NEAREST : r = i.NEAREST; break; case 10: s = i.LINEAR, t ? r = i.NEAREST_MIPMAP_LINEAR : r = i.NEAREST; break; case 2: s = i.LINEAR, r = i.LINEAR; break; case 12: s = i.LINEAR, r = i.NEAREST; break }return { min: r, mag: s } } _createTexture() { const e = this._gl.createTexture(); if (!e) throw new Error("Unable to create texture"); return e } _createHardwareTexture() { return new ms(this._createTexture(), this._gl) } _createInternalTexture(e, t, i = !0, s = Ne.Unknown) { var r; let n = !1, a = 0, o = 3, l = 5, h = !1, u = 1, f; t !== void 0 && typeof t == "object" ? (n = !!t.generateMipMaps, a = t.type === void 0 ? 0 : t.type, o = t.samplingMode === void 0 ? 3 : t.samplingMode, l = t.format === void 0 ? 5 : t.format, h = t.useSRGBBuffer === void 0 ? !1 : t.useSRGBBuffer, u = (r = t.samples) !== null && r !== void 0 ? r : 1, f = t.label) : n = !!t, h && (h = this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU)), (a === 1 && !this._caps.textureFloatLinearFiltering || a === 2 && !this._caps.textureHalfFloatLinearFiltering) && (o = 1), a === 1 && !this._caps.textureFloat && (a = 0, O.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE")); const _ = this._gl, p = new Ot(this, s), v = e.width || e, E = e.height || e, m = e.layers || 0, x = this._getSamplingParameters(o, n), C = m !== 0 ? _.TEXTURE_2D_ARRAY : _.TEXTURE_2D, S = this._getRGBABufferInternalSizedFormat(a, l, h), y = this._getInternalFormat(l), b = this._getWebGLTextureType(a); return this._bindTextureDirectly(C, p), m !== 0 ? (p.is2DArray = !0, _.texImage3D(C, 0, S, v, E, m, 0, y, b, null)) : _.texImage2D(C, 0, S, v, E, 0, y, b, null), _.texParameteri(C, _.TEXTURE_MAG_FILTER, x.mag), _.texParameteri(C, _.TEXTURE_MIN_FILTER, x.min), _.texParameteri(C, _.TEXTURE_WRAP_S, _.CLAMP_TO_EDGE), _.texParameteri(C, _.TEXTURE_WRAP_T, _.CLAMP_TO_EDGE), n && this._gl.generateMipmap(C), this._bindTextureDirectly(C, null), p._useSRGBBuffer = h, p.baseWidth = v, p.baseHeight = E, p.width = v, p.height = E, p.depth = m, p.isReady = !0, p.samples = u, p.generateMipMaps = n, p.samplingMode = o, p.type = a, p.format = l, p.label = f, this._internalTexturesCache.push(p), p } _getUseSRGBBuffer(e, t) { return e && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || t) } _createTextureBase(e, t, i, s, r = 3, n = null, a = null, o, l, h = null, u = null, f = null, _ = null, p, v, E) { e = e || ""; const m = e.substr(0, 5) === "data:", x = e.substr(0, 5) === "blob:", C = m && e.indexOf(";base64,") !== -1, S = u || new Ot(this, Ne.Url); S !== u && (S.label = e.substring(0, 60)); const y = e; this._transformTextureUrl && !C && !u && !h && (e = this._transformTextureUrl(e)), y !== e && (S._originalUrl = y); const b = e.lastIndexOf("."); let R = _ || (b > -1 ? e.substring(b).toLowerCase() : ""), w = null; R.indexOf("?") > -1 && (R = R.split("?")[0]); for (const J of $._TextureLoaders) if (J.canLoad(R, p)) { w = J; break } s && s.addPendingData(S), S.url = e, S.generateMipMaps = !t, S.samplingMode = r, S.invertY = i, S._useSRGBBuffer = this._getUseSRGBBuffer(!!E, t), this._doNotHandleContextLost || (S._buffer = h); let X = null; n && !u && (X = S.onLoadedObservable.add(n)), u || this._internalTexturesCache.push(S); const fe = (J, ae) => { s && s.removePendingData(S), e === y ? (X && S.onLoadedObservable.remove(X), ce.UseFallbackTexture && this._createTextureBase(ce.FallbackTexture, t, S.invertY, s, r, null, a, o, l, h, S), J = (J || "Unknown error") + (ce.UseFallbackTexture ? " - Fallback texture was used" : ""), S.onErrorObservable.notifyObservers({ message: J, exception: ae }), a && a(J, ae)) : (O.Warn(`Failed to load ${e}, falling back to ${y}`), this._createTextureBase(y, t, S.invertY, s, r, n, a, o, l, h, S, f, _, p, v, E)) }; if (w) { const J = ae => { w.loadData(ae, S, (ee, Me, Ae, Se, xe, Re) => { Re ? fe("TextureLoader failed to load data") : o(S, R, s, { width: ee, height: Me }, S.invertY, !Ae, Se, () => (xe(), !1), r) }, v) }; h ? h instanceof ArrayBuffer ? J(new Uint8Array(h)) : ArrayBuffer.isView(h) ? J(h) : a && a("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null) : this._loadFile(e, ae => J(new Uint8Array(ae)), void 0, s ? s.offlineProvider : void 0, !0, (ae, ee) => { fe("Unable to load " + (ae && ae.responseURL, ee)) }) } else { const J = ae => { x && !this._doNotHandleContextLost && (S._buffer = ae), o(S, R, s, ae, S.invertY, t, !1, l, r) }; !m || C ? h && (typeof h.decoding == "string" || h.close) ? J(h) : $._FileToolsLoadImage(e, J, fe, s ? s.offlineProvider : null, p, S.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0) : typeof h == "string" || h instanceof ArrayBuffer || ArrayBuffer.isView(h) || h instanceof Blob ? $._FileToolsLoadImage(h, J, fe, s ? s.offlineProvider : null, p, S.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0) : h && J(h) } return S } createTexture(e, t, i, s, r = 3, n = null, a = null, o = null, l = null, h = null, u = null, f, _, p, v) { return this._createTextureBase(e, t, i, s, r, n, a, this._prepareWebGLTexture.bind(this), (E, m, x, C, S, y) => { const b = this._gl, R = x.width === E && x.height === m, w = this._getTexImageParametersForCreateTexture(h, C, S._useSRGBBuffer); if (R) return b.texImage2D(b.TEXTURE_2D, 0, w.internalFormat, w.format, w.type, x), !1; const N = this._caps.maxTextureSize; if (x.width > N || x.height > N || !this._supportsHardwareTextureRescaling) return this._prepareWorkingCanvas(), !this._workingCanvas || !this._workingContext || (this._workingCanvas.width = E, this._workingCanvas.height = m, this._workingContext.drawImage(x, 0, 0, x.width, x.height, 0, 0, E, m), b.texImage2D(b.TEXTURE_2D, 0, w.internalFormat, w.format, w.type, this._workingCanvas), S.width = E, S.height = m), !1; { const X = new Ot(this, Ne.Temp); this._bindTextureDirectly(b.TEXTURE_2D, X, !0), b.texImage2D(b.TEXTURE_2D, 0, w.internalFormat, w.format, w.type, x), this._rescaleTexture(X, S, s, w.format, () => { this._releaseTexture(X), this._bindTextureDirectly(b.TEXTURE_2D, S, !0), y() }) } return !0 }, o, l, h, u, f, _, v) } _getTexImageParametersForCreateTexture(e, t, i) { e == null && (e = t === ".jpg" && !i ? 4 : 5); let s, r; return this.webGLVersion === 1 ? (s = this._getInternalFormat(e, i), r = s) : (s = this._getInternalFormat(e, !1), r = this._getRGBABufferInternalSizedFormat(0, e, i)), { internalFormat: r, format: s, type: this._gl.UNSIGNED_BYTE } } static _FileToolsLoadImage(e, t, i, s, r, n) { throw K("FileTools") } _rescaleTexture(e, t, i, s, r) { } createRawTexture(e, t, i, s, r, n, a, o = null, l = 0, h = 0, u = !1) { throw K("Engine.RawTexture") } createRawCubeTexture(e, t, i, s, r, n, a, o = null) { throw K("Engine.RawTexture") } createRawTexture3D(e, t, i, s, r, n, a, o, l = null, h = 0) { throw K("Engine.RawTexture") } createRawTexture2DArray(e, t, i, s, r, n, a, o, l = null, h = 0) { throw K("Engine.RawTexture") } _unpackFlipY(e) { this._unpackFlipYCached !== e && (this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, e ? 1 : 0), this.enableUnpackFlipYCached && (this._unpackFlipYCached = e)) } _getUnpackAlignement() { return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT) } _getTextureTarget(e) { return e.isCube ? this._gl.TEXTURE_CUBE_MAP : e.is3D ? this._gl.TEXTURE_3D : e.is2DArray || e.isMultiview ? this._gl.TEXTURE_2D_ARRAY : this._gl.TEXTURE_2D } updateTextureSamplingMode(e, t, i = !1) { const s = this._getTextureTarget(t), r = this._getSamplingParameters(e, t.useMipMaps || i); this._setTextureParameterInteger(s, this._gl.TEXTURE_MAG_FILTER, r.mag, t), this._setTextureParameterInteger(s, this._gl.TEXTURE_MIN_FILTER, r.min), i && (t.generateMipMaps = !0, this._gl.generateMipmap(s)), this._bindTextureDirectly(s, null), t.samplingMode = e } updateTextureDimensions(e, t, i, s = 1) { } updateTextureWrappingMode(e, t, i = null, s = null) { const r = this._getTextureTarget(e); t !== null && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t), e), e._cachedWrapU = t), i !== null && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(i), e), e._cachedWrapV = i), (e.is2DArray || e.is3D) && s !== null && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(s), e), e._cachedWrapR = s), this._bindTextureDirectly(r, null) } _setupDepthStencilTexture(e, t, i, s, r, n = 1) { const a = t.width || t, o = t.height || t, l = t.layers || 0; e.baseWidth = a, e.baseHeight = o, e.width = a, e.height = o, e.is2DArray = l > 0, e.depth = l, e.isReady = !0, e.samples = n, e.generateMipMaps = !1, e.samplingMode = s ? 2 : 1, e.type = 0, e._comparisonFunction = r; const h = this._gl, u = this._getTextureTarget(e), f = this._getSamplingParameters(e.samplingMode, !1); h.texParameteri(u, h.TEXTURE_MAG_FILTER, f.mag), h.texParameteri(u, h.TEXTURE_MIN_FILTER, f.min), h.texParameteri(u, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE), h.texParameteri(u, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE), this.webGLVersion > 1 && (r === 0 ? (h.texParameteri(u, h.TEXTURE_COMPARE_FUNC, 515), h.texParameteri(u, h.TEXTURE_COMPARE_MODE, h.NONE)) : (h.texParameteri(u, h.TEXTURE_COMPARE_FUNC, r), h.texParameteri(u, h.TEXTURE_COMPARE_MODE, h.COMPARE_REF_TO_TEXTURE))) } _uploadCompressedDataToTextureDirectly(e, t, i, s, r, n = 0, a = 0) { const o = this._gl; let l = o.TEXTURE_2D; if (e.isCube && (l = o.TEXTURE_CUBE_MAP_POSITIVE_X + n), e._useSRGBBuffer) switch (t) { case 37492: case 36196: this._caps.etc2 ? t = o.COMPRESSED_SRGB8_ETC2 : e._useSRGBBuffer = !1; break; case 37496: this._caps.etc2 ? t = o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : e._useSRGBBuffer = !1; break; case 36492: t = o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT; break; case 37808: t = o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR; break; case 33776: this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_S3TC_DXT1_EXT : e._useSRGBBuffer = !1; break; case 33777: this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : e._useSRGBBuffer = !1; break; case 33779: this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : e._useSRGBBuffer = !1; break; default: e._useSRGBBuffer = !1; break }this._gl.compressedTexImage2D(l, a, t, i, s, 0, r) } _uploadDataToTextureDirectly(e, t, i = 0, s = 0, r, n = !1) { const a = this._gl, o = this._getWebGLTextureType(e.type), l = this._getInternalFormat(e.format), h = r === void 0 ? this._getRGBABufferInternalSizedFormat(e.type, e.format, e._useSRGBBuffer) : this._getInternalFormat(r, e._useSRGBBuffer); this._unpackFlipY(e.invertY); let u = a.TEXTURE_2D; e.isCube && (u = a.TEXTURE_CUBE_MAP_POSITIVE_X + i); const f = Math.round(Math.log(e.width) * Math.LOG2E), _ = Math.round(Math.log(e.height) * Math.LOG2E), p = n ? e.width : Math.pow(2, Math.max(f - s, 0)), v = n ? e.height : Math.pow(2, Math.max(_ - s, 0)); a.texImage2D(u, s, h, p, v, 0, l, o, t) } updateTextureData(e, t, i, s, r, n, a = 0, o = 0, l = !1) { const h = this._gl, u = this._getWebGLTextureType(e.type), f = this._getInternalFormat(e.format); this._unpackFlipY(e.invertY); let _ = h.TEXTURE_2D, p = h.TEXTURE_2D; e.isCube && (p = h.TEXTURE_CUBE_MAP_POSITIVE_X + a, _ = h.TEXTURE_CUBE_MAP), this._bindTextureDirectly(_, e, !0), h.texSubImage2D(p, o, i, s, r, n, f, u, t), l && this._gl.generateMipmap(p), this._bindTextureDirectly(_, null) } _uploadArrayBufferViewToTexture(e, t, i = 0, s = 0) { const r = this._gl, n = e.isCube ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D; this._bindTextureDirectly(n, e, !0), this._uploadDataToTextureDirectly(e, t, i, s), this._bindTextureDirectly(n, null, !0) } _prepareWebGLTextureContinuation(e, t, i, s, r) { const n = this._gl; if (!n) return; const a = this._getSamplingParameters(r, !i); n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, a.mag), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, a.min), !i && !s && n.generateMipmap(n.TEXTURE_2D), this._bindTextureDirectly(n.TEXTURE_2D, null), t && t.removePendingData(e), e.onLoadedObservable.notifyObservers(e), e.onLoadedObservable.clear() } _prepareWebGLTexture(e, t, i, s, r, n, a, o, l = 3) { const h = this.getCaps().maxTextureSize, u = Math.min(h, this.needPOTTextures ? $.GetExponentOfTwo(s.width, h) : s.width), f = Math.min(h, this.needPOTTextures ? $.GetExponentOfTwo(s.height, h) : s.height), _ = this._gl; if (_) { if (!e._hardwareTexture) { i && i.removePendingData(e); return } this._bindTextureDirectly(_.TEXTURE_2D, e, !0), this._unpackFlipY(r === void 0 ? !0 : !!r), e.baseWidth = s.width, e.baseHeight = s.height, e.width = u, e.height = f, e.isReady = !0, e.type = e.type !== -1 ? e.type : 0, e.format = e.format !== -1 ? e.format : t === ".jpg" && !e._useSRGBBuffer ? 4 : 5, !o(u, f, s, t, e, () => { this._prepareWebGLTextureContinuation(e, i, n, a, l) }) && this._prepareWebGLTextureContinuation(e, i, n, a, l) } } _setupFramebufferDepthAttachments(e, t, i, s, r = 1) { const n = this._gl; if (e && t) return this._createRenderBuffer(i, s, r, n.DEPTH_STENCIL, n.DEPTH24_STENCIL8, n.DEPTH_STENCIL_ATTACHMENT); if (t) { let a = n.DEPTH_COMPONENT16; return this._webGLVersion > 1 && (a = n.DEPTH_COMPONENT32F), this._createRenderBuffer(i, s, r, a, a, n.DEPTH_ATTACHMENT) } return e ? this._createRenderBuffer(i, s, r, n.STENCIL_INDEX8, n.STENCIL_INDEX8, n.STENCIL_ATTACHMENT) : null } _createRenderBuffer(e, t, i, s, r, n, a = !0) { const l = this._gl.createRenderbuffer(); return this._updateRenderBuffer(l, e, t, i, s, r, n, a) } _updateRenderBuffer(e, t, i, s, r, n, a, o = !0) { const l = this._gl; return l.bindRenderbuffer(l.RENDERBUFFER, e), s > 1 && l.renderbufferStorageMultisample ? l.renderbufferStorageMultisample(l.RENDERBUFFER, s, n, t, i) : l.renderbufferStorage(l.RENDERBUFFER, r, t, i), l.framebufferRenderbuffer(l.FRAMEBUFFER, a, l.RENDERBUFFER, e), o && l.bindRenderbuffer(l.RENDERBUFFER, null), e } _releaseTexture(e) { var t; this._deleteTexture((t = e._hardwareTexture) === null || t === void 0 ? void 0 : t.underlyingResource), this.unbindAllTextures(); const i = this._internalTexturesCache.indexOf(e); i !== -1 && this._internalTexturesCache.splice(i, 1), e._lodTextureHigh && e._lodTextureHigh.dispose(), e._lodTextureMid && e._lodTextureMid.dispose(), e._lodTextureLow && e._lodTextureLow.dispose(), e._irradianceTexture && e._irradianceTexture.dispose() } _releaseRenderTargetWrapper(e) { const t = this._renderTargetWrapperCache.indexOf(e); t !== -1 && this._renderTargetWrapperCache.splice(t, 1) } _deleteTexture(e) { e && this._gl.deleteTexture(e) } _setProgram(e) { this._currentProgram !== e && (this._gl.useProgram(e), this._currentProgram = e) } bindSamplers(e) { const t = e.getPipelineContext(); this._setProgram(t.program); const i = e.getSamplers(); for (let s = 0; s < i.length; s++) { const r = e.getUniform(i[s]); r && (this._boundUniforms[s] = r) } this._currentEffect = null } _activateCurrentTexture() { this._currentTextureChannel !== this._activeChannel && (this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel), this._currentTextureChannel = this._activeChannel) } _bindTextureDirectly(e, t, i = !1, s = !1) { var r, n; let a = !1; const o = t && t._associatedChannel > -1; if (i && o && (this._activeChannel = t._associatedChannel), this._boundTexturesCache[this._activeChannel] !== t || s) { if (this._activateCurrentTexture(), t && t.isMultiview) throw console.error(e, t), "_bindTextureDirectly called with a multiview texture!"; this._gl.bindTexture(e, (n = (r = t == null ? void 0 : t._hardwareTexture) === null || r === void 0 ? void 0 : r.underlyingResource) !== null && n !== void 0 ? n : null), this._boundTexturesCache[this._activeChannel] = t, t && (t._associatedChannel = this._activeChannel) } else i && (a = !0, this._activateCurrentTexture()); return o && !i && this._bindSamplerUniformToChannel(t._associatedChannel, this._activeChannel), a } _bindTexture(e, t, i) { if (e === void 0) return; t && (t._associatedChannel = e), this._activeChannel = e; const s = t ? this._getTextureTarget(t) : this._gl.TEXTURE_2D; this._bindTextureDirectly(s, t) } unbindAllTextures() { for (let e = 0; e < this._maxSimultaneousTextures; e++)this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null)) } setTexture(e, t, i, s) { e !== void 0 && (t && (this._boundUniforms[e] = t), this._setTexture(e, i)) } _bindSamplerUniformToChannel(e, t) { const i = this._boundUniforms[e]; !i || i._currentState === t || (this._gl.uniform1i(i, t), i._currentState = t) } _getTextureWrapMode(e) { switch (e) { case 1: return this._gl.REPEAT; case 0: return this._gl.CLAMP_TO_EDGE; case 2: return this._gl.MIRRORED_REPEAT }return this._gl.REPEAT } _setTexture(e, t, i = !1, s = !1, r = "") { if (!t) return this._boundTexturesCache[e] != null && (this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null))), !1; if (t.video) { this._activeChannel = e; const l = t.getInternalTexture(); l && (l._associatedChannel = e), t.update() } else if (t.delayLoadState === 4) return t.delayLoad(), !1; let n; s ? n = t.depthStencilTexture : t.isReady() ? n = t.getInternalTexture() : t.isCube ? n = this.emptyCubeTexture : t.is3D ? n = this.emptyTexture3D : t.is2DArray ? n = this.emptyTexture2DArray : n = this.emptyTexture, !i && n && (n._associatedChannel = e); let a = !0; this._boundTexturesCache[e] === n && (i || this._bindSamplerUniformToChannel(n._associatedChannel, e), a = !1), this._activeChannel = e; const o = this._getTextureTarget(n); if (a && this._bindTextureDirectly(o, n, i), n && !n.isMultiview) { if (n.isCube && n._cachedCoordinatesMode !== t.coordinatesMode) { n._cachedCoordinatesMode = t.coordinatesMode; const l = t.coordinatesMode !== 3 && t.coordinatesMode !== 5 ? 1 : 0; t.wrapU = l, t.wrapV = l } n._cachedWrapU !== t.wrapU && (n._cachedWrapU = t.wrapU, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t.wrapU), n)), n._cachedWrapV !== t.wrapV && (n._cachedWrapV = t.wrapV, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(t.wrapV), n)), n.is3D && n._cachedWrapR !== t.wrapR && (n._cachedWrapR = t.wrapR, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(t.wrapR), n)), this._setAnisotropicLevel(o, n, t.anisotropicFilteringLevel) } return !0 } setTextureArray(e, t, i, s) { if (!(e === void 0 || !t)) { (!this._textureUnits || this._textureUnits.length !== i.length) && (this._textureUnits = new Int32Array(i.length)); for (let r = 0; r < i.length; r++) { const n = i[r].getInternalTexture(); n ? (this._textureUnits[r] = e + r, n._associatedChannel = e + r) : this._textureUnits[r] = -1 } this._gl.uniform1iv(t, this._textureUnits); for (let r = 0; r < i.length; r++)this._setTexture(this._textureUnits[r], i[r], !0) } } _setAnisotropicLevel(e, t, i) { const s = this._caps.textureAnisotropicFilterExtension; t.samplingMode !== 11 && t.samplingMode !== 3 && t.samplingMode !== 2 && (i = 1), s && t._cachedAnisotropicFilteringLevel !== i && (this._setTextureParameterFloat(e, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i, this._caps.maxAnisotropy), t), t._cachedAnisotropicFilteringLevel = i) } _setTextureParameterFloat(e, t, i, s) { this._bindTextureDirectly(e, s, !0, !0), this._gl.texParameterf(e, t, i) } _setTextureParameterInteger(e, t, i, s) { s && this._bindTextureDirectly(e, s, !0, !0), this._gl.texParameteri(e, t, i) } unbindAllAttributes() { if (this._mustWipeVertexAttributes) { this._mustWipeVertexAttributes = !1; for (let e = 0; e < this._caps.maxVertexAttribs; e++)this.disableAttributeByIndex(e); return } for (let e = 0, t = this._vertexAttribArraysEnabled.length; e < t; e++)e >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[e] || this.disableAttributeByIndex(e) } releaseEffects() { for (const e in this._compiledEffects) { const t = this._compiledEffects[e].getPipelineContext(); this._deletePipelineContext(t) } this._compiledEffects = {} } dispose() { var e, t; this._isDisposed = !0, this.stopRenderLoop(), this.onBeforeTextureInitObservable && this.onBeforeTextureInitObservable.clear(), this._emptyTexture && (this._releaseTexture(this._emptyTexture), this._emptyTexture = null), this._emptyCubeTexture && (this._releaseTexture(this._emptyCubeTexture), this._emptyCubeTexture = null), this._dummyFramebuffer && this._gl.deleteFramebuffer(this._dummyFramebuffer), this.releaseEffects(), (e = this.releaseComputeEffects) === null || e === void 0 || e.call(this), this.unbindAllAttributes(), this._boundUniforms = {}, Fe() && this._renderingCanvas && (this._doNotHandleContextLost || (this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost), this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored)), window.removeEventListener("resize", this._checkForMobile)), this._workingCanvas = null, this._workingContext = null, this._currentBufferPointers.length = 0, this._renderingCanvas = null, this._currentProgram = null, this._boundRenderFunction = null, Ve.ResetCache(); for (const i of this._activeRequests) i.abort(); this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this._creationOptions.loseContextOnDispose && ((t = this._gl.getExtension("WEBGL_lose_context")) === null || t === void 0 || t.loseContext()) } attachContextLostEvent(e) { this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextlost", e, !1) } attachContextRestoredEvent(e) { this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextrestored", e, !1) } getError() { return this._gl.getError() } _canRenderToFloatFramebuffer() { return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(1) } _canRenderToHalfFloatFramebuffer() { return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(2) } _canRenderToFramebuffer(e) { const t = this._gl; for (; t.getError() !== t.NO_ERROR;); let i = !0; const s = t.createTexture(); t.bindTexture(t.TEXTURE_2D, s), t.texImage2D(t.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(e), 1, 1, 0, t.RGBA, this._getWebGLTextureType(e), null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST); const r = t.createFramebuffer(); t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, s, 0); const n = t.checkFramebufferStatus(t.FRAMEBUFFER); if (i = i && n === t.FRAMEBUFFER_COMPLETE, i = i && t.getError() === t.NO_ERROR, i && (t.clear(t.COLOR_BUFFER_BIT), i = i && t.getError() === t.NO_ERROR), i) { t.bindFramebuffer(t.FRAMEBUFFER, null); const a = t.RGBA, o = t.UNSIGNED_BYTE, l = new Uint8Array(4); t.readPixels(0, 0, 1, 1, a, o, l), i = i && t.getError() === t.NO_ERROR } for (t.deleteTexture(s), t.deleteFramebuffer(r), t.bindFramebuffer(t.FRAMEBUFFER, null); !i && t.getError() !== t.NO_ERROR;); return i } _getWebGLTextureType(e) { if (this._webGLVersion === 1) { switch (e) { case 1: return this._gl.FLOAT; case 2: return this._gl.HALF_FLOAT_OES; case 0: return this._gl.UNSIGNED_BYTE; case 8: return this._gl.UNSIGNED_SHORT_4_4_4_4; case 9: return this._gl.UNSIGNED_SHORT_5_5_5_1; case 10: return this._gl.UNSIGNED_SHORT_5_6_5 }return this._gl.UNSIGNED_BYTE } switch (e) { case 3: return this._gl.BYTE; case 0: return this._gl.UNSIGNED_BYTE; case 4: return this._gl.SHORT; case 5: return this._gl.UNSIGNED_SHORT; case 6: return this._gl.INT; case 7: return this._gl.UNSIGNED_INT; case 1: return this._gl.FLOAT; case 2: return this._gl.HALF_FLOAT; case 8: return this._gl.UNSIGNED_SHORT_4_4_4_4; case 9: return this._gl.UNSIGNED_SHORT_5_5_5_1; case 10: return this._gl.UNSIGNED_SHORT_5_6_5; case 11: return this._gl.UNSIGNED_INT_2_10_10_10_REV; case 12: return this._gl.UNSIGNED_INT_24_8; case 13: return this._gl.UNSIGNED_INT_10F_11F_11F_REV; case 14: return this._gl.UNSIGNED_INT_5_9_9_9_REV; case 15: return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV }return this._gl.UNSIGNED_BYTE } _getInternalFormat(e, t = !1) { let i = t ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA; switch (e) { case 0: i = this._gl.ALPHA; break; case 1: i = this._gl.LUMINANCE; break; case 2: i = this._gl.LUMINANCE_ALPHA; break; case 6: i = this._gl.RED; break; case 7: i = this._gl.RG; break; case 4: i = t ? this._glSRGBExtensionValues.SRGB : this._gl.RGB; break; case 5: i = t ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA; break }if (this._webGLVersion > 1) switch (e) { case 8: i = this._gl.RED_INTEGER; break; case 9: i = this._gl.RG_INTEGER; break; case 10: i = this._gl.RGB_INTEGER; break; case 11: i = this._gl.RGBA_INTEGER; break }return i } _getRGBABufferInternalSizedFormat(e, t, i = !1) { if (this._webGLVersion === 1) { if (t !== void 0) switch (t) { case 0: return this._gl.ALPHA; case 1: return this._gl.LUMINANCE; case 2: return this._gl.LUMINANCE_ALPHA; case 4: return i ? this._glSRGBExtensionValues.SRGB : this._gl.RGB }return this._gl.RGBA } switch (e) { case 3: switch (t) { case 6: return this._gl.R8_SNORM; case 7: return this._gl.RG8_SNORM; case 4: return this._gl.RGB8_SNORM; case 8: return this._gl.R8I; case 9: return this._gl.RG8I; case 10: return this._gl.RGB8I; case 11: return this._gl.RGBA8I; default: return this._gl.RGBA8_SNORM }case 0: switch (t) { case 6: return this._gl.R8; case 7: return this._gl.RG8; case 4: return i ? this._glSRGBExtensionValues.SRGB8 : this._gl.RGB8; case 5: return i ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8; case 8: return this._gl.R8UI; case 9: return this._gl.RG8UI; case 10: return this._gl.RGB8UI; case 11: return this._gl.RGBA8UI; case 0: return this._gl.ALPHA; case 1: return this._gl.LUMINANCE; case 2: return this._gl.LUMINANCE_ALPHA; default: return this._gl.RGBA8 }case 4: switch (t) { case 8: return this._gl.R16I; case 9: return this._gl.RG16I; case 10: return this._gl.RGB16I; case 11: return this._gl.RGBA16I; default: return this._gl.RGBA16I }case 5: switch (t) { case 8: return this._gl.R16UI; case 9: return this._gl.RG16UI; case 10: return this._gl.RGB16UI; case 11: return this._gl.RGBA16UI; default: return this._gl.RGBA16UI }case 6: switch (t) { case 8: return this._gl.R32I; case 9: return this._gl.RG32I; case 10: return this._gl.RGB32I; case 11: return this._gl.RGBA32I; default: return this._gl.RGBA32I }case 7: switch (t) { case 8: return this._gl.R32UI; case 9: return this._gl.RG32UI; case 10: return this._gl.RGB32UI; case 11: return this._gl.RGBA32UI; default: return this._gl.RGBA32UI }case 1: switch (t) { case 6: return this._gl.R32F; case 7: return this._gl.RG32F; case 4: return this._gl.RGB32F; case 5: return this._gl.RGBA32F; default: return this._gl.RGBA32F }case 2: switch (t) { case 6: return this._gl.R16F; case 7: return this._gl.RG16F; case 4: return this._gl.RGB16F; case 5: return this._gl.RGBA16F; default: return this._gl.RGBA16F }case 10: return this._gl.RGB565; case 13: return this._gl.R11F_G11F_B10F; case 14: return this._gl.RGB9_E5; case 8: return this._gl.RGBA4; case 9: return this._gl.RGB5_A1; case 11: switch (t) { case 5: return this._gl.RGB10_A2; case 11: return this._gl.RGB10_A2UI; default: return this._gl.RGB10_A2 } }return i ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8 } _loadFile(e, t, i, s, r, n) { const a = $._FileToolsLoadFile(e, t, i, s, r, n); return this._activeRequests.push(a), a.onCompleteObservable.add(o => { this._activeRequests.splice(this._activeRequests.indexOf(o), 1) }), a } static _FileToolsLoadFile(e, t, i, s, r, n) { throw K("FileTools") } readPixels(e, t, i, s, r = !0, n = !0) { const a = r ? 4 : 3, o = r ? this._gl.RGBA : this._gl.RGB, l = new Uint8Array(s * i * a); return n && this.flushFramebuffer(), this._gl.readPixels(e, t, i, s, o, this._gl.UNSIGNED_BYTE, l), Promise.resolve(l) } static get IsSupportedAsync() { return Promise.resolve(this.isSupported()) } static get IsSupported() { return this.isSupported() } static isSupported() { if (this._HasMajorPerformanceCaveat !== null) return !this._HasMajorPerformanceCaveat; if (this._IsSupported === null) try { const e = this._CreateCanvas(1, 1), t = e.getContext("webgl") || e.getContext("experimental-webgl"); this._IsSupported = t != null && !!window.WebGLRenderingContext } catch { this._IsSupported = !1 } return this._IsSupported } static get HasMajorPerformanceCaveat() { if (this._HasMajorPerformanceCaveat === null) try { const e = this._CreateCanvas(1, 1), t = e.getContext("webgl", { failIfMajorPerformanceCaveat: !0 }) || e.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: !0 }); this._HasMajorPerformanceCaveat = !t } catch { this._HasMajorPerformanceCaveat = !1 } return this._HasMajorPerformanceCaveat } static CeilingPOT(e) { return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e++, e } static FloorPOT(e) { return e = e | e >> 1, e = e | e >> 2, e = e | e >> 4, e = e | e >> 8, e = e | e >> 16, e - (e >> 1) } static NearestPOT(e) { const t = $.CeilingPOT(e), i = $.FloorPOT(e); return t - e > e - i ? i : t } static GetExponentOfTwo(e, t, i = 2) { let s; switch (i) { case 1: s = $.FloorPOT(e); break; case 2: s = $.NearestPOT(e); break; case 3: default: s = $.CeilingPOT(e); break }return Math.min(s, t) } static QueueNewFrame(e, t) { if (Fe()) { const { requestAnimationFrame: i } = t || window; if (typeof i == "function") return i(e) } else if (typeof requestAnimationFrame == "function") return requestAnimationFrame(e); return setTimeout(e, 16) } getHostDocument() { return this._renderingCanvas && this._renderingCanvas.ownerDocument ? this._renderingCanvas.ownerDocument : Qt() ? document : null }
    } $._TempClearColorUint32 = new Uint32Array(4), $._TempClearColorInt32 = new Int32Array(4), $.ExceptionList = [{ key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] }, { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] }, { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] }, { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] }, { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] }, { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] }, { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] }, { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] }, { key: "Mac OS.+Chrome", capture: null, captureConstraint: null, targets: ["uniformBuffer"] }, { key: ".*AppleWebKit.*(15.4).*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] }, { key: ".*(15.4).*AppleWebKit.*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] }], $._TextureLoaders = [], $.CollisionsEpsilon = .001, $._IsSupported = null, $._HasMajorPerformanceCaveat = null; class vi { static SetImmediate(e) { Fe() && window.setImmediate ? window.setImmediate(e) : setTimeout(e, 1) } } const ps = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i); class Ei extends zt { constructor(e, t) { super(e, gi.LoadFileError), this.name = "LoadFileError", Xt._setPrototypeOf(this, Ei.prototype), t instanceof ke ? this.request = t : this.file = t } } class bi extends zt { constructor(e, t) { super(e, gi.RequestFileError), this.request = t, this.name = "RequestFileError", Xt._setPrototypeOf(this, bi.prototype) } } class Ni extends zt { constructor(e, t) { super(e, gi.ReadFileError), this.file = t, this.name = "ReadFileError", Xt._setPrototypeOf(this, Ni.prototype) } } const ye = { DefaultRetryStrategy: mr.ExponentialBackoff(), BaseUrl: "", CorsBehavior: "anonymous", PreprocessUrl: c => c, ScriptBaseUrl: "", ScriptPreprocessUrl: c => c }, vs = c => (c = c.replace(/#/gm, "%23"), c), Bi = (c, e) => { if (!(c && c.indexOf("data:") === 0) && ye.CorsBehavior) if (typeof ye.CorsBehavior == "string" || ye.CorsBehavior instanceof String) e.crossOrigin = ye.CorsBehavior; else { const t = ye.CorsBehavior(c); t && (e.crossOrigin = t) } }, Ui = (c, e, t, i, s = "", r) => { var n; let a, o = !1; c instanceof ArrayBuffer || ArrayBuffer.isView(c) ? typeof Blob < "u" && typeof URL < "u" ? (a = URL.createObjectURL(new Blob([c], { type: s })), o = !0) : a = `data:${s};base64,` + fs(c) : c instanceof Blob ? (a = URL.createObjectURL(c), o = !0) : (a = vs(c), a = ye.PreprocessUrl(c)); const l = ce.LastCreatedEngine, h = b => { if (t) { const R = a || c.toString(); t(`Error while trying to load image: ${R.indexOf("http") === 0 || R.length <= 128 ? R : R.slice(0, 128) + "..."}`, b) } }; if (typeof Image > "u" || (n = l == null ? void 0 : l._features.forceBitmapOverHTMLImageElement) !== null && n !== void 0 && n) return Rt(a, b => { l.createImageBitmap(new Blob([b], { type: s }), Object.assign({ premultiplyAlpha: "none" }, r)).then(R => { e(R), o && URL.revokeObjectURL(a) }).catch(R => { t && t("Error while trying to load image: " + c, R) }) }, void 0, i || void 0, !0, (b, R) => { h(R) }), null; const u = new Image; Bi(a, u); const f = [], _ = () => { f.forEach(b => { b.target.addEventListener(b.name, b.handler) }) }, p = () => { f.forEach(b => { b.target.removeEventListener(b.name, b.handler) }), f.length = 0 }, v = () => { p(), e(u), o && u.src && URL.revokeObjectURL(u.src) }, E = b => { p(), h(b), o && u.src && URL.revokeObjectURL(u.src) }, m = b => { if (b.blockedURI !== u.src) return; p(); const R = new Error(`CSP violation of policy ${b.effectiveDirective} ${b.blockedURI}. Current policy is ${b.originalPolicy}`); ce.UseFallbackTexture = !1, h(R), o && u.src && URL.revokeObjectURL(u.src), u.src = "" }; f.push({ target: u, name: "load", handler: v }), f.push({ target: u, name: "error", handler: E }), f.push({ target: document, name: "securitypolicyviolation", handler: m }), _(); const x = a.substring(0, 5) === "blob:", C = a.substring(0, 5) === "data:", S = () => { x || C || !ke.IsCustomRequestAvailable ? u.src = a : Rt(a, (b, R, w) => { const N = !s && w ? w : s, X = new Blob([b], { type: N }), fe = URL.createObjectURL(X); o = !0, u.src = fe }, void 0, i || void 0, !0, (b, R) => { h(R) }) }, y = () => { i && i.loadImage(a, u) }; if (!x && !C && i && i.enableTexturesOffline) i.open(y, S); else { if (a.indexOf("file:") !== -1) { const b = decodeURIComponent(a.substring(5).toLowerCase()); if (Jt.FilesToLoad[b] && typeof URL < "u") { try { let R; try { R = URL.createObjectURL(Jt.FilesToLoad[b]) } catch { R = URL.createObjectURL(Jt.FilesToLoad[b]) } u.src = R, o = !0 } catch { u.src = "" } return u } } S() } return u }, si = (c, e, t, i, s) => { const r = new FileReader, n = { onCompleteObservable: new L, abort: () => r.abort() }; return r.onloadend = () => n.onCompleteObservable.notifyObservers(n), s && (r.onerror = () => { s(new Ni(`Unable to read ${c.name}`, c)) }), r.onload = a => { e(a.target.result) }, t && (r.onprogress = t), i ? r.readAsArrayBuffer(c) : r.readAsText(c), n }, Rt = (c, e, t, i, s, r, n) => { if (c.name) return si(c, e, t, s, r ? h => { r(void 0, h) } : void 0); const a = c; if (a.indexOf("file:") !== -1) { let h = decodeURIComponent(a.substring(5).toLowerCase()); h.indexOf("./") === 0 && (h = h.substring(2)); const u = Jt.FilesToLoad[h]; if (u) return si(u, e, t, s, r ? f => r(void 0, new Ei(f.message, f.file)) : void 0) } const { match: o, type: l } = Br(a); if (o) { const h = { onCompleteObservable: new L, abort: () => () => { } }; try { const u = s ? Vi(a) : Ts(a); e(u, void 0, l) } catch (u) { r ? r(void 0, u) : O.Error(u.message || "Failed to parse the Data URL") } return vi.SetImmediate(() => { h.onCompleteObservable.notifyObservers(h) }), h } return ki(a, (h, u) => { e(h, u == null ? void 0 : u.responseURL, u == null ? void 0 : u.getResponseHeader("content-type")) }, t, i, s, r ? h => { r(h.request, new Ei(h.message, h.request)) } : void 0, n) }, ki = (c, e, t, i, s, r, n) => { c = vs(c), c = ye.PreprocessUrl(c); const a = ye.BaseUrl + c; let o = !1; const l = { onCompleteObservable: new L, abort: () => o = !0 }, h = () => { let u = new ke, f = null, _; const p = () => { u && (t && u.removeEventListener("progress", t), _ && u.removeEventListener("readystatechange", _), u.removeEventListener("loadend", v)) }; let v = () => { p(), l.onCompleteObservable.notifyObservers(l), l.onCompleteObservable.clear(), t = void 0, _ = null, v = null, r = void 0, n = void 0, e = void 0 }; l.abort = () => { o = !0, v && v(), u && u.readyState !== (XMLHttpRequest.DONE || 4) && u.abort(), f !== null && (clearTimeout(f), f = null), u = null }; const E = x => { const C = x.message || "Unknown error"; r && u ? r(new bi(C, u)) : O.Error(C) }, m = x => { if (u) { if (u.open("GET", a), n) try { n(u) } catch (C) { E(C); return } s && (u.responseType = "arraybuffer"), t && u.addEventListener("progress", t), v && u.addEventListener("loadend", v), _ = () => { if (!(o || !u) && u.readyState === (XMLHttpRequest.DONE || 4)) { if (_ && u.removeEventListener("readystatechange", _), u.status >= 200 && u.status < 300 || u.status === 0 && (!Fe() || Es())) { try { e && e(s ? u.response : u.responseText, u) } catch (y) { E(y) } return } const C = ye.DefaultRetryStrategy; if (C) { const y = C(a, u, x); if (y !== -1) { p(), u = new ke, f = setTimeout(() => m(x + 1), y); return } } const S = new bi("Error status: " + u.status + " " + u.statusText + " - Unable to load " + a, u); r && r(S) } }, u.addEventListener("readystatechange", _), u.send() } }; m(0) }; if (i && i.enableSceneOffline) { const u = _ => { _ && _.status > 400 ? r && r(_) : h() }, f = () => { i && i.loadFile(ye.BaseUrl + c, _ => { !o && e && e(_), l.onCompleteObservable.notifyObservers(l) }, t ? _ => { !o && t && t(_) } : void 0, u, s) }; i.open(f, u) } else h(); return l }, Es = () => typeof location < "u" && location.protocol === "file:", bs = c => ps.test(c), Br = c => { const e = ps.exec(c); return e === null || e.length === 0 ? { match: !1, type: "" } : { match: !0, type: e[0].replace("data:", "").replace("base64,", "") } }; function Vi(c) { return pr(c.split(",")[1]) } const Ts = c => ds(c.split(",")[1]); (() => { $._FileToolsLoadImage = Ui, $._FileToolsLoadFile = Rt, ht._FileToolsLoadFile = Rt })(); let ri; ((c, e, t, i, s, r, n, a, o, l) => { ri = { DecodeBase64UrlToBinary: c, DecodeBase64UrlToString: e, DefaultRetryStrategy: t.DefaultRetryStrategy, BaseUrl: t.BaseUrl, CorsBehavior: t.CorsBehavior, PreprocessUrl: t.PreprocessUrl, IsBase64DataUrl: i, IsFileURL: s, LoadFile: r, LoadImage: n, ReadFile: a, RequestFile: o, SetCorsBehavior: l }, Object.defineProperty(ri, "DefaultRetryStrategy", { get: function () { return t.DefaultRetryStrategy }, set: function (h) { t.DefaultRetryStrategy = h } }), Object.defineProperty(ri, "BaseUrl", { get: function () { return t.BaseUrl }, set: function (h) { t.BaseUrl = h } }), Object.defineProperty(ri, "PreprocessUrl", { get: function () { return t.PreprocessUrl }, set: function (h) { t.PreprocessUrl = h } }), Object.defineProperty(ri, "CorsBehavior", { get: function () { return t.CorsBehavior }, set: function (h) { t.CorsBehavior = h } }) })(Vi, Ts, ye, bs, Es, Rt, Ui, si, ki, Bi); class ni { static Instantiate(e) { if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[e]) return this.RegisteredExternalClasses[e]; const t = Yt(e); if (t) return t; O.Warn(e + " not found, you may have missed an import."); const i = e.split("."); let s = window || this; for (let r = 0, n = i.length; r < n; r++)s = s[i[r]]; return typeof s != "function" ? null : s } } ni.RegisteredExternalClasses = {}; function xs() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => { const e = Math.random() * 16 | 0; return (c === "x" ? e : e & 3 | 8).toString(16) }) } class G { static get BaseUrl() { return ye.BaseUrl } static set BaseUrl(e) { ye.BaseUrl = e } static IsAbsoluteUrl(e) { return e.indexOf("//") === 0 ? !0 : e.indexOf("://") === -1 || e.indexOf(".") === -1 || e.indexOf("/") === -1 || e.indexOf(":") > e.indexOf("/") ? !1 : e.indexOf("://") < e.indexOf(".") || e.indexOf("data:") === 0 || e.indexOf("blob:") === 0 } static set ScriptBaseUrl(e) { ye.ScriptBaseUrl = e } static get ScriptBaseUrl() { return ye.ScriptBaseUrl } static set ScriptPreprocessUrl(e) { ye.ScriptPreprocessUrl = e } static get ScriptPreprocessUrl() { return ye.ScriptPreprocessUrl } static get DefaultRetryStrategy() { return ye.DefaultRetryStrategy } static set DefaultRetryStrategy(e) { ye.DefaultRetryStrategy = e } static get CorsBehavior() { return ye.CorsBehavior } static set CorsBehavior(e) { ye.CorsBehavior = e } static get UseFallbackTexture() { return ce.UseFallbackTexture } static set UseFallbackTexture(e) { ce.UseFallbackTexture = e } static get RegisteredExternalClasses() { return ni.RegisteredExternalClasses } static set RegisteredExternalClasses(e) { ni.RegisteredExternalClasses = e } static get fallbackTexture() { return ce.FallbackTexture } static set fallbackTexture(e) { ce.FallbackTexture = e } static FetchToRef(e, t, i, s, r, n) { const a = Math.abs(e) * i % i | 0, o = Math.abs(t) * s % s | 0, l = (a + o * i) * 4; n.r = r[l] / 255, n.g = r[l + 1] / 255, n.b = r[l + 2] / 255, n.a = r[l + 3] / 255 } static Mix(e, t, i) { return e * (1 - i) + t * i } static Instantiate(e) { return ni.Instantiate(e) } static SetImmediate(e) { vi.SetImmediate(e) } static IsExponentOfTwo(e) { let t = 1; do t *= 2; while (t < e); return t === e } static FloatRound(e) { return Math.fround(e) } static GetFilename(e) { const t = e.lastIndexOf("/"); return t < 0 ? e : e.substring(t + 1) } static GetFolderPath(e, t = !1) { const i = e.lastIndexOf("/"); return i < 0 ? t ? e : "" : e.substring(0, i + 1) } static ToDegrees(e) { return e * 180 / Math.PI } static ToRadians(e) { return e * Math.PI / 180 } static SmoothAngleChange(e, t, i = .9) { const s = this.ToRadians(e), r = this.ToRadians(t); return this.ToDegrees(Math.atan2((1 - i) * Math.sin(r) + i * Math.sin(s), (1 - i) * Math.cos(r) + i * Math.cos(s))) } static MakeArray(e, t) { return t !== !0 && (e === void 0 || e == null) ? null : Array.isArray(e) ? e : [e] } static GetPointerPrefix(e) { let t = "pointer"; return Fe() && !window.PointerEvent && (t = "mouse"), e._badDesktopOS && !e._badOS && !(document && "ontouchend" in document) && (t = "mouse"), t } static SetCorsBehavior(e, t) { Bi(e, t) } static SetReferrerPolicyBehavior(e, t) { t.referrerPolicy = e } static CleanUrl(e) { return e = e.replace(/#/gm, "%23"), e } static get PreprocessUrl() { return ye.PreprocessUrl } static set PreprocessUrl(e) { ye.PreprocessUrl = e } static LoadImage(e, t, i, s, r, n) { return Ui(e, t, i, s, r, n) } static LoadFile(e, t, i, s, r, n) { return Rt(e, t, i, s, r, n) } static LoadFileAsync(e, t = !0) { return new Promise((i, s) => { Rt(e, r => { i(r) }, void 0, void 0, t, (r, n) => { s(n) }) }) } static GetBabylonScriptURL(e, t) { if (!e) return ""; if (G.ScriptBaseUrl && e.startsWith(G._DefaultCdnUrl)) { const i = G.ScriptBaseUrl[G.ScriptBaseUrl.length - 1] === "/" ? G.ScriptBaseUrl.substring(0, G.ScriptBaseUrl.length - 1) : G.ScriptBaseUrl; e = e.replace(G._DefaultCdnUrl, i) } return e = G.ScriptPreprocessUrl(e), t && (e = G.GetAbsoluteUrl(e)), e } static LoadBabylonScript(e, t, i, s) { e = G.GetBabylonScriptURL(e), G.LoadScript(e, t, i) } static LoadBabylonScriptAsync(e) { return e = G.GetBabylonScriptURL(e), G.LoadScriptAsync(e) } static LoadScript(e, t, i, s) { if (typeof importScripts == "function") { try { importScripts(e), t() } catch (a) { i == null || i(`Unable to load script '${e}' in worker`, a) } return } else if (!Fe()) { i == null || i(`Cannot load script '${e}' outside of a window or a worker`); return } const r = document.getElementsByTagName("head")[0], n = document.createElement("script"); n.setAttribute("type", "text/javascript"), n.setAttribute("src", e), s && (n.id = s), n.onload = () => { t && t() }, n.onerror = a => { i && i(`Unable to load script '${e}'`, a) }, r.appendChild(n) } static LoadScriptAsync(e) { return new Promise((t, i) => { this.LoadScript(e, () => { t() }, (s, r) => { i(r || new Error(s)) }) }) } static ReadFileAsDataURL(e, t, i) { const s = new FileReader, r = { onCompleteObservable: new L, abort: () => s.abort() }; return s.onloadend = () => { r.onCompleteObservable.notifyObservers(r) }, s.onload = n => { t(n.target.result) }, s.onprogress = i, s.readAsDataURL(e), r } static ReadFile(e, t, i, s, r) { return si(e, t, i, s, r) } static FileAsURL(e) { const t = new Blob([e]); return window.URL.createObjectURL(t) } static Format(e, t = 2) { return e.toFixed(t) } static DeepCopy(e, t, i, s) { us.DeepCopy(e, t, i, s) } static IsEmpty(e) { for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1; return !0 } static RegisterTopRootEvents(e, t) { for (let i = 0; i < t.length; i++) { const s = t[i]; e.addEventListener(s.name, s.handler, !1); try { window.parent && window.parent.addEventListener(s.name, s.handler, !1) } catch { } } } static UnregisterTopRootEvents(e, t) { for (let i = 0; i < t.length; i++) { const s = t[i]; e.removeEventListener(s.name, s.handler); try { e.parent && e.parent.removeEventListener(s.name, s.handler) } catch { } } } static async DumpFramebuffer(e, t, i, s, r = "image/png", n, a) { throw K("DumpTools") } static DumpData(e, t, i, s, r = "image/png", n, a = !1, o = !1, l) { throw K("DumpTools") } static DumpDataAsync(e, t, i, s = "image/png", r, n = !1, a = !1, o) { throw K("DumpTools") } static _IsOffScreenCanvas(e) { return e.convertToBlob !== void 0 } static ToBlob(e, t, i = "image/png", s) { !G._IsOffScreenCanvas(e) && !e.toBlob && (e.toBlob = function (r, n, a) { setTimeout(() => { const o = atob(this.toDataURL(n, a).split(",")[1]), l = o.length, h = new Uint8Array(l); for (let u = 0; u < l; u++)h[u] = o.charCodeAt(u); r(new Blob([h])) }) }), G._IsOffScreenCanvas(e) ? e.convertToBlob({ type: i, quality: s }).then(r => t(r)) : e.toBlob(function (r) { t(r) }, i, s) } static DownloadBlob(e, t) { if ("download" in document.createElement("a")) { if (!t) { const i = new Date; t = "screenshot_" + ((i.getFullYear() + "-" + (i.getMonth() + 1)).slice(2) + "-" + i.getDate() + "_" + i.getHours() + "-" + ("0" + i.getMinutes()).slice(-2)) + ".png" } G.Download(e, t) } else if (e && typeof URL < "u") { const i = URL.createObjectURL(e), s = window.open(""); if (!s) return; const r = s.document.createElement("img"); r.onload = function () { URL.revokeObjectURL(i) }, r.src = i, s.document.body.appendChild(r) } } static EncodeScreenshotCanvasData(e, t, i = "image/png", s, r) { if (typeof s == "string" || !t) this.ToBlob(e, function (n) { n && G.DownloadBlob(n, s), t && t("") }, i, r); else if (t) { if (G._IsOffScreenCanvas(e)) { e.convertToBlob({ type: i, quality: r }).then(a => { const o = new FileReader; o.readAsDataURL(a), o.onloadend = () => { const l = o.result; t(l) } }); return } const n = e.toDataURL(i, r); t(n) } } static Download(e, t) { if (typeof URL > "u") return; const i = window.URL.createObjectURL(e), s = document.createElement("a"); document.body.appendChild(s), s.style.display = "none", s.href = i, s.download = t, s.addEventListener("click", () => { s.parentElement && s.parentElement.removeChild(s) }), s.click(), window.URL.revokeObjectURL(i) } static BackCompatCameraNoPreventDefault(e) { return typeof e[0] == "boolean" ? e[0] : typeof e[1] == "boolean" ? e[1] : !1 } static CreateScreenshot(e, t, i, s, r = "image/png", n = !1, a) { throw K("ScreenshotTools") } static CreateScreenshotAsync(e, t, i, s = "image/png", r) { throw K("ScreenshotTools") } static CreateScreenshotUsingRenderTarget(e, t, i, s, r = "image/png", n = 1, a = !1, o, l = !1, h = !1, u = !0, f) { throw K("ScreenshotTools") } static CreateScreenshotUsingRenderTargetAsync(e, t, i, s = "image/png", r = 1, n = !1, a, o = !1, l = !1, h = !0, u) { throw K("ScreenshotTools") } static RandomId() { return xs() } static IsBase64(e) { return bs(e) } static DecodeBase64(e) { return Vi(e) } static get errorsCount() { return O.errorsCount } static Log(e) { O.Log(e) } static Warn(e) { O.Warn(e) } static Error(e) { O.Error(e) } static get LogCache() { return O.LogCache } static ClearLogCache() { O.ClearLogCache() } static set LogLevels(e) { O.LogLevels = e } static set PerformanceLogLevel(e) { if ((e & G.PerformanceUserMarkLogLevel) === G.PerformanceUserMarkLogLevel) { G.StartPerformanceCounter = G._StartUserMark, G.EndPerformanceCounter = G._EndUserMark; return } if ((e & G.PerformanceConsoleLogLevel) === G.PerformanceConsoleLogLevel) { G.StartPerformanceCounter = G._StartPerformanceConsole, G.EndPerformanceCounter = G._EndPerformanceConsole; return } G.StartPerformanceCounter = G._StartPerformanceCounterDisabled, G.EndPerformanceCounter = G._EndPerformanceCounterDisabled } static _StartPerformanceCounterDisabled(e, t) { } static _EndPerformanceCounterDisabled(e, t) { } static _StartUserMark(e, t = !0) { if (!G._Performance) { if (!Fe()) return; G._Performance = window.performance } !t || !G._Performance.mark || G._Performance.mark(e + "-Begin") } static _EndUserMark(e, t = !0) { !t || !G._Performance.mark || (G._Performance.mark(e + "-End"), G._Performance.measure(e, e + "-Begin", e + "-End")) } static _StartPerformanceConsole(e, t = !0) { t && (G._StartUserMark(e, t), console.time && console.time(e)) } static _EndPerformanceConsole(e, t = !0) { t && (G._EndUserMark(e, t), console.timeEnd(e)) } static get Now() { return wt.Now } static GetClassName(e, t = !1) { let i = null; return !t && e.getClassName ? i = e.getClassName() : (e instanceof Object && (i = (t ? e : Object.getPrototypeOf(e)).constructor.__bjsclassName__), i || (i = typeof e)), i } static First(e, t) { for (const i of e) if (t(i)) return i; return null } static getFullClassName(e, t = !1) { let i = null, s = null; if (!t && e.getClassName) i = e.getClassName(); else { if (e instanceof Object) { const r = t ? e : Object.getPrototypeOf(e); i = r.constructor.__bjsclassName__, s = r.constructor.__bjsmoduleName__ } i || (i = typeof e) } return i ? (s != null ? s + "." : "") + i : null } static DelayAsync(e) { return new Promise(t => { setTimeout(() => { t() }, e) }) } static IsSafari() { return $t() ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1 } } G.UseCustomRequestHeaders = !1, G.CustomRequestHeaders = ke.CustomRequestHeaders, G.GetDOMTextContent = hs, G._DefaultCdnUrl = "https://cdn.babylonjs.com", G.GetAbsoluteUrl = typeof document == "object" ? c => { const e = document.createElement("a"); return e.href = c, e.href } : typeof URL == "function" && typeof location == "object" ? c => new URL(c, location.origin).href : () => { throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.") }, G.NoneLogLevel = O.NoneLogLevel, G.MessageLogLevel = O.MessageLogLevel, G.WarningLogLevel = O.WarningLogLevel, G.ErrorLogLevel = O.ErrorLogLevel, G.AllLogLevel = O.AllLogLevel, G.IsWindowObjectExist = Fe, G.PerformanceNoneLogLevel = 0, G.PerformanceUserMarkLogLevel = 1, G.PerformanceConsoleLogLevel = 2, G.StartPerformanceCounter = G._StartPerformanceCounterDisabled, G.EndPerformanceCounter = G._EndPerformanceCounterDisabled; class Ti { constructor(e, t, i, s = 0) { this.iterations = e, this.index = s - 1, this._done = !1, this._fn = t, this._successCallback = i } executeNext() { this._done || (this.index + 1 < this.iterations ? (++this.index, this._fn(this)) : this.breakLoop()) } breakLoop() { this._done = !0, this._successCallback() } static Run(e, t, i, s = 0) { const r = new Ti(e, t, i, s); return r.executeNext(), r } static SyncAsyncForLoop(e, t, i, s, r, n = 0) { return Ti.Run(Math.ceil(e / t), a => { r && r() ? a.breakLoop() : setTimeout(() => { for (let o = 0; o < t; ++o) { const l = a.index * t + o; if (l >= e) break; if (i(l), r && r()) { a.breakLoop(); break } } a.executeNext() }, n) }, s) } } ce.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z"; class Ur { constructor() { this._doNotSerialize = !1, this._isDisposed = !1, this._sceneRootNodesIndex = -1, this._isEnabled = !0, this._isParentEnabled = !0, this._isReady = !0, this._onEnabledStateChangedObservable = new L, this._onClonedObservable = new L } } class We { static AddNodeConstructor(e, t) { this._NodeConstructors[e] = t } static Construct(e, t, i, s) { const r = this._NodeConstructors[e]; return r ? r(t, i, s) : null } set accessibilityTag(e) { this._accessibilityTag = e, this.onAccessibilityTagChangedObservable.notifyObservers(e) } get accessibilityTag() { return this._accessibilityTag } get doNotSerialize() { return this._nodeDataStorage._doNotSerialize ? !0 : this._parentNode ? this._parentNode.doNotSerialize : !1 } set doNotSerialize(e) { this._nodeDataStorage._doNotSerialize = e } isDisposed() { return this._nodeDataStorage._isDisposed } set parent(e) { if (this._parentNode === e) return; const t = this._parentNode; if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) { const i = this._parentNode._children.indexOf(this); i !== -1 && this._parentNode._children.splice(i, 1), !e && !this._nodeDataStorage._isDisposed && this._addToSceneRootNodes() } this._parentNode = e, this._parentNode && ((this._parentNode._children === void 0 || this._parentNode._children === null) && (this._parentNode._children = new Array), this._parentNode._children.push(this), t || this._removeFromSceneRootNodes()), this._syncParentEnabledState() } get parent() { return this._parentNode } _serializeAsParent(e) { e.parentId = this.uniqueId } _addToSceneRootNodes() { this._nodeDataStorage._sceneRootNodesIndex === -1 && (this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length, this._scene.rootNodes.push(this)) } _removeFromSceneRootNodes() { if (this._nodeDataStorage._sceneRootNodesIndex !== -1) { const e = this._scene.rootNodes, t = e.length - 1; e[this._nodeDataStorage._sceneRootNodesIndex] = e[t], e[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex, this._scene.rootNodes.pop(), this._nodeDataStorage._sceneRootNodesIndex = -1 } } get animationPropertiesOverride() { return this._animationPropertiesOverride ? this._animationPropertiesOverride : this._scene.animationPropertiesOverride } set animationPropertiesOverride(e) { this._animationPropertiesOverride = e } getClassName() { return "Node" } set onDispose(e) { this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e) } get onEnabledStateChangedObservable() { return this._nodeDataStorage._onEnabledStateChangedObservable } get onClonedObservable() { return this._nodeDataStorage._onClonedObservable } constructor(e, t = null) { this._isDirty = !1, this._nodeDataStorage = new Ur, this.state = "", this.metadata = null, this.reservedDataStore = null, this._accessibilityTag = null, this.onAccessibilityTagChangedObservable = new L, this._parentContainer = null, this.animations = [], this._ranges = {}, this.onReady = null, this._currentRenderId = -1, this._parentUpdateId = -1, this._childUpdateId = -1, this._waitingParentId = null, this._waitingParentInstanceIndex = null, this._waitingParsedUniqueId = null, this._cache = {}, this._parentNode = null, this._children = null, this._worldMatrix = A.Identity(), this._worldMatrixDeterminant = 0, this._worldMatrixDeterminantIsDirty = !0, this._animationPropertiesOverride = null, this._isNode = !0, this.onDisposeObservable = new L, this._onDisposeObserver = null, this._behaviors = new Array, this.name = e, this.id = e, this._scene = t || ce.LastCreatedScene, this.uniqueId = this._scene.getUniqueId(), this._initCache() } getScene() { return this._scene } getEngine() { return this._scene.getEngine() } addBehavior(e, t = !1) { return this._behaviors.indexOf(e) !== -1 ? this : (e.init(), this._scene.isLoading && !t ? this._scene.onDataLoadedObservable.addOnce(() => { e.attach(this) }) : e.attach(this), this._behaviors.push(e), this) } removeBehavior(e) { const t = this._behaviors.indexOf(e); return t === -1 ? this : (this._behaviors[t].detach(), this._behaviors.splice(t, 1), this) } get behaviors() { return this._behaviors } getBehaviorByName(e) { for (const t of this._behaviors) if (t.name === e) return t; return null } getWorldMatrix() { return this._currentRenderId !== this._scene.getRenderId() && this.computeWorldMatrix(), this._worldMatrix } _getWorldMatrixDeterminant() { return this._worldMatrixDeterminantIsDirty && (this._worldMatrixDeterminantIsDirty = !1, this._worldMatrixDeterminant = this._worldMatrix.determinant()), this._worldMatrixDeterminant } get worldMatrixFromCache() { return this._worldMatrix } _initCache() { this._cache = {}, this._cache.parent = void 0 } updateCache(e) { !e && this.isSynchronized() || (this._cache.parent = this.parent, this._updateCache()) } _getActionManagerForTrigger(e, t = !0) { return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null } _updateCache(e) { } _isSynchronized() { return !0 } _markSyncedWithParent() { this._parentNode && (this._parentUpdateId = this._parentNode._childUpdateId) } isSynchronizedWithParent() { return this._parentNode ? this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId ? !1 : this._parentNode.isSynchronized() : !0 } isSynchronized() { return this._cache.parent !== this._parentNode ? (this._cache.parent = this._parentNode, !1) : this._parentNode && !this.isSynchronizedWithParent() ? !1 : this._isSynchronized() } isReady(e = !1) { return this._nodeDataStorage._isReady } markAsDirty(e) { return this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this } isEnabled(e = !0) { return e === !1 ? this._nodeDataStorage._isEnabled : this._nodeDataStorage._isEnabled ? this._nodeDataStorage._isParentEnabled : !1 } _syncParentEnabledState() { this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : !0, this._children && this._children.forEach(e => { e._syncParentEnabledState() }) } setEnabled(e) { this._nodeDataStorage._isEnabled !== e && (this._nodeDataStorage._isEnabled = e, this._syncParentEnabledState(), this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(e)) } isDescendantOf(e) { return this.parent ? this.parent === e ? !0 : this.parent.isDescendantOf(e) : !1 } _getDescendants(e, t = !1, i) { if (this._children) for (let s = 0; s < this._children.length; s++) { const r = this._children[s]; (!i || i(r)) && e.push(r), t || r._getDescendants(e, !1, i) } } getDescendants(e, t) { const i = []; return this._getDescendants(i, e, t), i } getChildMeshes(e, t) { const i = []; return this._getDescendants(i, e, s => (!t || t(s)) && s.cullingStrategy !== void 0), i } getChildren(e, t = !0) { return this.getDescendants(t, e) } _setReady(e) { if (e !== this._nodeDataStorage._isReady) { if (!e) { this._nodeDataStorage._isReady = !1; return } this.onReady && this.onReady(this), this._nodeDataStorage._isReady = !0 } } getAnimationByName(e) { for (let t = 0; t < this.animations.length; t++) { const i = this.animations[t]; if (i.name === e) return i } return null } createAnimationRange(e, t, i) { if (!this._ranges[e]) { this._ranges[e] = We._AnimationRangeFactory(e, t, i); for (let s = 0, r = this.animations.length; s < r; s++)this.animations[s] && this.animations[s].createRange(e, t, i) } } deleteAnimationRange(e, t = !0) { for (let i = 0, s = this.animations.length; i < s; i++)this.animations[i] && this.animations[i].deleteRange(e, t); this._ranges[e] = null } getAnimationRange(e) { return this._ranges[e] || null } clone(e, t, i) { const s = re.Clone(() => new We(e, this.getScene()), this); if (t && (s.parent = t), !i) { const r = this.getDescendants(!0); for (let n = 0; n < r.length; n++) { const a = r[n]; a.clone(e + "." + a.name, s) } } return s } getAnimationRanges() { const e = []; let t; for (t in this._ranges) e.push(this._ranges[t]); return e } beginAnimation(e, t, i, s) { const r = this.getAnimationRange(e); return r ? this._scene.beginAnimation(this, r.from, r.to, t, i, s) : null } serializeAnimationRanges() { const e = []; for (const t in this._ranges) { const i = this._ranges[t]; if (!i) continue; const s = {}; s.name = t, s.from = i.from, s.to = i.to, e.push(s) } return e } computeWorldMatrix(e) { return this._worldMatrix || (this._worldMatrix = A.Identity()), this._worldMatrix } dispose(e, t = !1) { if (this._nodeDataStorage._isDisposed = !0, !e) { const i = this.getDescendants(!0); for (const s of i) s.dispose(e, t) } this.parent ? this.parent = null : this._removeFromSceneRootNodes(), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onEnabledStateChangedObservable.clear(), this.onClonedObservable.clear(); for (const i of this._behaviors) i.detach(); this._behaviors.length = 0, this.metadata = null } static ParseAnimationRanges(e, t, i) { if (t.ranges) for (let s = 0; s < t.ranges.length; s++) { const r = t.ranges[s]; e.createAnimationRange(r.name, r.from, r.to) } } getHierarchyBoundingVectors(e = !0, t = null) { this.getScene().incrementRenderId(), this.computeWorldMatrix(!0); let i, s; const r = this; if (r.getBoundingInfo && r.subMeshes) { const n = r.getBoundingInfo(); i = n.boundingBox.minimumWorld.clone(), s = n.boundingBox.maximumWorld.clone() } else i = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), s = new g(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE); if (e) { const n = this.getDescendants(!1); for (const a of n) { const o = a; if (o.computeWorldMatrix(!0), t && !t(o) || !o.getBoundingInfo || o.getTotalVertices() === 0) continue; const h = o.getBoundingInfo().boundingBox, u = h.minimumWorld, f = h.maximumWorld; g.CheckExtends(u, i, s), g.CheckExtends(f, i, s) } } return { min: i, max: s } } } We._AnimationRangeFactory = (c, e, t) => { throw K("AnimationRange") }, We._NodeConstructors = {}, T([M()], We.prototype, "name", void 0), T([M()], We.prototype, "id", void 0), T([M()], We.prototype, "uniqueId", void 0), T([M()], We.prototype, "state", void 0), T([M()], We.prototype, "metadata", void 0); class Q extends We { get position() { return this._position } set position(e) { this._position = e } set upVector(e) { this._upVector = e } get upVector() { return this._upVector } get screenArea() { var e, t, i, s; let r = 0, n = 0; if (this.mode === Q.PERSPECTIVE_CAMERA) this.fovMode === Q.FOVMODE_VERTICAL_FIXED ? (n = this.minZ * 2 * Math.tan(this.fov / 2), r = this.getEngine().getAspectRatio(this) * n) : (r = this.minZ * 2 * Math.tan(this.fov / 2), n = r / this.getEngine().getAspectRatio(this)); else { const a = this.getEngine().getRenderWidth() / 2, o = this.getEngine().getRenderHeight() / 2; r = ((e = this.orthoRight) !== null && e !== void 0 ? e : a) - ((t = this.orthoLeft) !== null && t !== void 0 ? t : -a), n = ((i = this.orthoTop) !== null && i !== void 0 ? i : o) - ((s = this.orthoBottom) !== null && s !== void 0 ? s : -o) } return r * n } set orthoLeft(e) { this._orthoLeft = e; for (const t of this._rigCameras) t.orthoLeft = e } get orthoLeft() { return this._orthoLeft } set orthoRight(e) { this._orthoRight = e; for (const t of this._rigCameras) t.orthoRight = e } get orthoRight() { return this._orthoRight } set orthoBottom(e) { this._orthoBottom = e; for (const t of this._rigCameras) t.orthoBottom = e } get orthoBottom() { return this._orthoBottom } set orthoTop(e) { this._orthoTop = e; for (const t of this._rigCameras) t.orthoTop = e } get orthoTop() { return this._orthoTop } set mode(e) { this._mode = e; for (const t of this._rigCameras) t.mode = e } get mode() { return this._mode } constructor(e, t, i, s = !0) { super(e, i), this._position = g.Zero(), this._upVector = g.Up(), this.oblique = null, this._orthoLeft = null, this._orthoRight = null, this._orthoBottom = null, this._orthoTop = null, this.fov = .8, this.projectionPlaneTilt = 0, this.minZ = 1, this.maxZ = 1e4, this.inertia = .9, this._mode = Q.PERSPECTIVE_CAMERA, this.isIntermediate = !1, this.viewport = new qt(0, 0, 1, 1), this.layerMask = 268435455, this.fovMode = Q.FOVMODE_VERTICAL_FIXED, this.cameraRigMode = Q.RIG_MODE_NONE, this.customRenderTargets = [], this.outputRenderTarget = null, this.onViewMatrixChangedObservable = new L, this.onProjectionMatrixChangedObservable = new L, this.onAfterCheckInputsObservable = new L, this.onRestoreStateObservable = new L, this.isRigCamera = !1, this._rigCameras = new Array, this._skipRendering = !1, this._projectionMatrix = new A, this._postProcesses = new Array, this._activeMeshes = new He(256), this._globalPosition = g.Zero(), this._computedViewMatrix = A.Identity(), this._doNotComputeProjectionMatrix = !1, this._transformMatrix = A.Zero(), this._refreshFrustumPlanes = !0, this._absoluteRotation = q.Identity(), this._isCamera = !0, this._isLeftCamera = !1, this._isRightCamera = !1, this.getScene().addCamera(this), s && !this.getScene().activeCamera && (this.getScene().activeCamera = this), this.position = t, this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${e}`) } storeState() { return this._stateStored = !0, this._storedFov = this.fov, this } _restoreStateValues() { return this._stateStored ? (this.fov = this._storedFov, !0) : !1 } restoreState() { return this._restoreStateValues() ? (this.onRestoreStateObservable.notifyObservers(this), !0) : !1 } getClassName() { return "Camera" } toString(e) { let t = "Name: " + this.name; if (t += ", type: " + this.getClassName(), this.animations) for (let i = 0; i < this.animations.length; i++)t += ", animation[0]: " + this.animations[i].toString(e); return t } applyVerticalCorrection() { const e = this.absoluteRotation.toEulerAngles(); this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -e.x : e.x } get globalPosition() { return this._globalPosition } getActiveMeshes() { return this._activeMeshes } isActiveMesh(e) { return this._activeMeshes.indexOf(e) !== -1 } isReady(e = !1) { if (e) { for (const t of this._postProcesses) if (t && !t.isReady()) return !1 } return super.isReady(e) } _initCache() { super._initCache(), this._cache.position = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.upVector = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.mode = void 0, this._cache.minZ = void 0, this._cache.maxZ = void 0, this._cache.fov = void 0, this._cache.fovMode = void 0, this._cache.aspectRatio = void 0, this._cache.orthoLeft = void 0, this._cache.orthoRight = void 0, this._cache.orthoBottom = void 0, this._cache.orthoTop = void 0, this._cache.obliqueAngle = void 0, this._cache.obliqueLength = void 0, this._cache.obliqueOffset = void 0, this._cache.renderWidth = void 0, this._cache.renderHeight = void 0 } _updateCache(e) { e || super._updateCache(), this._cache.position.copyFrom(this.position), this._cache.upVector.copyFrom(this.upVector) } _isSynchronized() { return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix() } _isSynchronizedViewMatrix() { return super._isSynchronized() ? this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent() : !1 } _isSynchronizedProjectionMatrix() { let e = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ; if (!e) return !1; const t = this.getEngine(); return this.mode === Q.PERSPECTIVE_CAMERA ? e = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === t.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt : (e = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === t.getRenderWidth() && this._cache.renderHeight === t.getRenderHeight(), this.oblique && (e = e && this._cache.obliqueAngle === this.oblique.angle && this._cache.obliqueLength === this.oblique.length && this._cache.obliqueOffset === this.oblique.offset)), e } attachControl(e, t) { } detachControl(e) { } update() { this._checkInputs(), this.cameraRigMode !== Q.RIG_MODE_NONE && this._updateRigCameras(), this.getViewMatrix(), this.getProjectionMatrix() } _checkInputs() { this.onAfterCheckInputsObservable.notifyObservers(this) } get rigCameras() { return this._rigCameras } get rigPostProcess() { return this._rigPostProcess } _getFirstPostProcess() { for (let e = 0; e < this._postProcesses.length; e++)if (this._postProcesses[e] !== null) return this._postProcesses[e]; return null } _cascadePostProcessesToRigCams() { const e = this._getFirstPostProcess(); e && e.markTextureDirty(); for (let t = 0, i = this._rigCameras.length; t < i; t++) { const s = this._rigCameras[t], r = s._rigPostProcess; r ? (r.getEffectName() === "pass" && (s.isIntermediate = this._postProcesses.length === 0), s._postProcesses = this._postProcesses.slice(0).concat(r), r.markTextureDirty()) : s._postProcesses = this._postProcesses.slice(0) } } attachPostProcess(e, t = null) { return !e.isReusable() && this._postProcesses.indexOf(e) > -1 ? (O.Error("You're trying to reuse a post process not defined as reusable."), 0) : (t == null || t < 0 ? this._postProcesses.push(e) : this._postProcesses[t] === null ? this._postProcesses[t] = e : this._postProcesses.splice(t, 0, e), this._cascadePostProcessesToRigCams(), this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(), this._postProcesses.indexOf(e)) } detachPostProcess(e) { const t = this._postProcesses.indexOf(e); t !== -1 && (this._postProcesses[t] = null), this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(), this._cascadePostProcessesToRigCams() } getWorldMatrix() { return this._isSynchronizedViewMatrix() ? this._worldMatrix : (this.getViewMatrix(), this._worldMatrix) } _getViewMatrix() { return A.Identity() } getViewMatrix(e) { return !e && this._isSynchronizedViewMatrix() ? this._computedViewMatrix : (this.updateCache(), this._computedViewMatrix = this._getViewMatrix(), this._currentRenderId = this.getScene().getRenderId(), this._childUpdateId++, this._refreshFrustumPlanes = !0, this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix && this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix), this.parent && this.parent.onViewMatrixChangedObservable && this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent), this.onViewMatrixChangedObservable.notifyObservers(this), this._computedViewMatrix.invertToRef(this._worldMatrix), this._computedViewMatrix) } freezeProjectionMatrix(e) { this._doNotComputeProjectionMatrix = !0, e !== void 0 && (this._projectionMatrix = e) } unfreezeProjectionMatrix() { this._doNotComputeProjectionMatrix = !1 } getProjectionMatrix(e) { var t, i, s, r, n, a, o, l, h, u, f, _, p, v, E, m, x, C, S; if (this._doNotComputeProjectionMatrix || !e && this._isSynchronizedProjectionMatrix()) return this._projectionMatrix; this._cache.mode = this.mode, this._cache.minZ = this.minZ, this._cache.maxZ = this.maxZ, this._refreshFrustumPlanes = !0; const y = this.getEngine(), b = this.getScene(), R = y.useReverseDepthBuffer; if (this.mode === Q.PERSPECTIVE_CAMERA) { this._cache.fov = this.fov, this._cache.fovMode = this.fovMode, this._cache.aspectRatio = y.getAspectRatio(this), this._cache.projectionPlaneTilt = this.projectionPlaneTilt, this.minZ <= 0 && (this.minZ = .1); let w; b.useRightHandedSystem ? w = A.PerspectiveFovRHToRef : w = A.PerspectiveFovLHToRef, w(this.fov, y.getAspectRatio(this), R ? this.maxZ : this.minZ, R ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === Q.FOVMODE_VERTICAL_FIXED, y.isNDCHalfZRange, this.projectionPlaneTilt, R) } else { const w = y.getRenderWidth() / 2, N = y.getRenderHeight() / 2; b.useRightHandedSystem ? this.oblique ? A.ObliqueOffCenterRHToRef((t = this.orthoLeft) !== null && t !== void 0 ? t : -w, (i = this.orthoRight) !== null && i !== void 0 ? i : w, (s = this.orthoBottom) !== null && s !== void 0 ? s : -N, (r = this.orthoTop) !== null && r !== void 0 ? r : N, R ? this.maxZ : this.minZ, R ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, y.isNDCHalfZRange) : A.OrthoOffCenterRHToRef((n = this.orthoLeft) !== null && n !== void 0 ? n : -w, (a = this.orthoRight) !== null && a !== void 0 ? a : w, (o = this.orthoBottom) !== null && o !== void 0 ? o : -N, (l = this.orthoTop) !== null && l !== void 0 ? l : N, R ? this.maxZ : this.minZ, R ? this.minZ : this.maxZ, this._projectionMatrix, y.isNDCHalfZRange) : this.oblique ? A.ObliqueOffCenterLHToRef((h = this.orthoLeft) !== null && h !== void 0 ? h : -w, (u = this.orthoRight) !== null && u !== void 0 ? u : w, (f = this.orthoBottom) !== null && f !== void 0 ? f : -N, (_ = this.orthoTop) !== null && _ !== void 0 ? _ : N, R ? this.maxZ : this.minZ, R ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, y.isNDCHalfZRange) : A.OrthoOffCenterLHToRef((p = this.orthoLeft) !== null && p !== void 0 ? p : -w, (v = this.orthoRight) !== null && v !== void 0 ? v : w, (E = this.orthoBottom) !== null && E !== void 0 ? E : -N, (m = this.orthoTop) !== null && m !== void 0 ? m : N, R ? this.maxZ : this.minZ, R ? this.minZ : this.maxZ, this._projectionMatrix, y.isNDCHalfZRange), this._cache.orthoLeft = this.orthoLeft, this._cache.orthoRight = this.orthoRight, this._cache.orthoBottom = this.orthoBottom, this._cache.orthoTop = this.orthoTop, this._cache.obliqueAngle = (x = this.oblique) === null || x === void 0 ? void 0 : x.angle, this._cache.obliqueLength = (C = this.oblique) === null || C === void 0 ? void 0 : C.length, this._cache.obliqueOffset = (S = this.oblique) === null || S === void 0 ? void 0 : S.offset, this._cache.renderWidth = y.getRenderWidth(), this._cache.renderHeight = y.getRenderHeight() } return this.onProjectionMatrixChangedObservable.notifyObservers(this), this._projectionMatrix } getTransformationMatrix() { return this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._transformMatrix } _computeObliqueDistance(e) { const t = this, i = this; return (t.radius || (i.target ? g.Distance(this.position, i.target) : this.position.length())) + e } _updateFrustumPlanes() { this._refreshFrustumPlanes && (this.getTransformationMatrix(), this._frustumPlanes ? it.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = it.GetPlanes(this._transformMatrix), this._refreshFrustumPlanes = !1) } isInFrustum(e, t = !1) { if (this._updateFrustumPlanes(), t && this.rigCameras.length > 0) { let i = !1; return this.rigCameras.forEach(s => { s._updateFrustumPlanes(), i = i || e.isInFrustum(s._frustumPlanes) }), i } else return e.isInFrustum(this._frustumPlanes) } isCompletelyInFrustum(e) { return this._updateFrustumPlanes(), e.isCompletelyInFrustum(this._frustumPlanes) } getForwardRay(e = 100, t, i) { throw K("Ray") } getForwardRayToRef(e, t = 100, i, s) { throw K("Ray") } dispose(e, t = !1) { for (this.onViewMatrixChangedObservable.clear(), this.onProjectionMatrixChangedObservable.clear(), this.onAfterCheckInputsObservable.clear(), this.onRestoreStateObservable.clear(), this.inputs && this.inputs.clear(), this.getScene().stopAnimation(this), this.getScene().removeCamera(this); this._rigCameras.length > 0;) { const s = this._rigCameras.pop(); s && s.dispose() } if (this._parentContainer) { const s = this._parentContainer.cameras.indexOf(this); s > -1 && this._parentContainer.cameras.splice(s, 1), this._parentContainer = null } if (this._rigPostProcess) this._rigPostProcess.dispose(this), this._rigPostProcess = null, this._postProcesses.length = 0; else if (this.cameraRigMode !== Q.RIG_MODE_NONE) this._rigPostProcess = null, this._postProcesses.length = 0; else { let s = this._postProcesses.length; for (; --s >= 0;) { const r = this._postProcesses[s]; r && r.dispose(this) } } let i = this.customRenderTargets.length; for (; --i >= 0;)this.customRenderTargets[i].dispose(); this.customRenderTargets.length = 0, this._activeMeshes.dispose(), this.getScene().getEngine().releaseRenderPassId(this.renderPassId), super.dispose(e, t) } get isLeftCamera() { return this._isLeftCamera } get isRightCamera() { return this._isRightCamera } get leftCamera() { return this._rigCameras.length < 1 ? null : this._rigCameras[0] } get rightCamera() { return this._rigCameras.length < 2 ? null : this._rigCameras[1] } getLeftTarget() { return this._rigCameras.length < 1 ? null : this._rigCameras[0].getTarget() } getRightTarget() { return this._rigCameras.length < 2 ? null : this._rigCameras[1].getTarget() } setCameraRigMode(e, t) { if (this.cameraRigMode !== e) { for (; this._rigCameras.length > 0;) { const i = this._rigCameras.pop(); i && i.dispose() } if (this.cameraRigMode = e, this._cameraRigParams = {}, this._cameraRigParams.interaxialDistance = t.interaxialDistance || .0637, this._cameraRigParams.stereoHalfAngle = G.ToRadians(this._cameraRigParams.interaxialDistance / .0637), this.cameraRigMode !== Q.RIG_MODE_NONE) { const i = this.createRigCamera(this.name + "_L", 0); i && (i._isLeftCamera = !0); const s = this.createRigCamera(this.name + "_R", 1); s && (s._isRightCamera = !0), i && s && (this._rigCameras.push(i), this._rigCameras.push(s)) } this._setRigMode(t), this._cascadePostProcessesToRigCams(), this.update() } } _setRigMode(e) { } _getVRProjectionMatrix() { return A.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, !0, this.getEngine().isNDCHalfZRange), this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix), this._projectionMatrix } setCameraRigParameter(e, t) { this._cameraRigParams || (this._cameraRigParams = {}), this._cameraRigParams[e] = t, e === "interaxialDistance" && (this._cameraRigParams.stereoHalfAngle = G.ToRadians(t / .0637)) } createRigCamera(e, t) { return null } _updateRigCameras() { for (let e = 0; e < this._rigCameras.length; e++)this._rigCameras[e].minZ = this.minZ, this._rigCameras[e].maxZ = this.maxZ, this._rigCameras[e].fov = this.fov, this._rigCameras[e].upVector.copyFrom(this.upVector); this.cameraRigMode === Q.RIG_MODE_STEREOSCOPIC_ANAGLYPH && (this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport) } _setupInputs() { } serialize() { const e = re.Serialize(this); return e.uniqueId = this.uniqueId, e.type = this.getClassName(), this.parent && this.parent._serializeAsParent(e), this.inputs && this.inputs.serialize(e), re.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.isEnabled = this.isEnabled(), e } clone(e, t = null) { const i = re.Clone(Q.GetConstructorFromName(this.getClassName(), e, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this); return i.name = e, i.parent = t, this.onClonedObservable.notifyObservers(i), i } getDirection(e) { const t = g.Zero(); return this.getDirectionToRef(e, t), t } get absoluteRotation() { return this.getWorldMatrix().decompose(void 0, this._absoluteRotation), this._absoluteRotation } getDirectionToRef(e, t) { g.TransformNormalToRef(e, this.getWorldMatrix(), t) } static GetConstructorFromName(e, t, i, s = 0, r = !0) { const n = We.Construct(e, t, i, { interaxial_distance: s, isStereoscopicSideBySide: r }); return n || (() => Q._CreateDefaultParsedCamera(t, i)) } computeWorldMatrix() { return this.getWorldMatrix() } static Parse(e, t) { const i = e.type, s = Q.GetConstructorFromName(i, e.name, t, e.interaxial_distance, e.isStereoscopicSideBySide), r = re.Parse(s, e, t); if (e.parentId !== void 0 && (r._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (r._waitingParentInstanceIndex = e.parentInstanceIndex), r.inputs && (r.inputs.parse(e), r._setupInputs()), e.upVector && (r.upVector = g.FromArray(e.upVector)), r.setPosition && (r.position.copyFromFloats(0, 0, 0), r.setPosition(g.FromArray(e.position))), e.target && r.setTarget && r.setTarget(g.FromArray(e.target)), e.cameraRigMode) { const n = e.interaxial_distance ? { interaxialDistance: e.interaxial_distance } : {}; r.setCameraRigMode(e.cameraRigMode, n) } if (e.animations) { for (let n = 0; n < e.animations.length; n++) { const a = e.animations[n], o = Yt("BABYLON.Animation"); o && r.animations.push(o.Parse(a)) } We.ParseAnimationRanges(r, e, t) } return e.autoAnimate && t.beginAnimation(r, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), e.isEnabled !== void 0 && r.setEnabled(e.isEnabled), r } _calculateHandednessMultiplier() { let e = this.getScene().useRightHandedSystem ? -1 : 1; return this.parent && this.parent._getWorldMatrixDeterminant() < 0 && (e *= -1), e } } Q._CreateDefaultParsedCamera = (c, e) => { throw K("UniversalCamera") }, Q.PERSPECTIVE_CAMERA = 0, Q.ORTHOGRAPHIC_CAMERA = 1, Q.FOVMODE_VERTICAL_FIXED = 0, Q.FOVMODE_HORIZONTAL_FIXED = 1, Q.RIG_MODE_NONE = 0, Q.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10, Q.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11, Q.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12, Q.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13, Q.RIG_MODE_STEREOSCOPIC_INTERLACED = 14, Q.RIG_MODE_VR = 20, Q.RIG_MODE_CUSTOM = 22, Q.ForceAttachControlToAlwaysPreventDefault = !1, T([Zt("position")], Q.prototype, "_position", void 0), T([Zt("upVector")], Q.prototype, "_upVector", void 0), T([M()], Q.prototype, "orthoLeft", null), T([M()], Q.prototype, "orthoRight", null), T([M()], Q.prototype, "orthoBottom", null), T([M()], Q.prototype, "orthoTop", null), T([M()], Q.prototype, "fov", void 0), T([M()], Q.prototype, "projectionPlaneTilt", void 0), T([M()], Q.prototype, "minZ", void 0), T([M()], Q.prototype, "maxZ", void 0), T([M()], Q.prototype, "inertia", void 0), T([M()], Q.prototype, "mode", null), T([M()], Q.prototype, "layerMask", void 0), T([M()], Q.prototype, "fovMode", void 0), T([M()], Q.prototype, "cameraRigMode", void 0), T([M()], Q.prototype, "interaxialDistance", void 0), T([M()], Q.prototype, "isStereoscopicSideBySide", void 0); class je { set opaqueSortCompareFn(e) { e ? this._opaqueSortCompareFn = e : this._opaqueSortCompareFn = je.PainterSortCompare, this._renderOpaque = this._renderOpaqueSorted } set alphaTestSortCompareFn(e) { e ? this._alphaTestSortCompareFn = e : this._alphaTestSortCompareFn = je.PainterSortCompare, this._renderAlphaTest = this._renderAlphaTestSorted } set transparentSortCompareFn(e) { e ? this._transparentSortCompareFn = e : this._transparentSortCompareFn = je.defaultTransparentSortCompare, this._renderTransparent = this._renderTransparentSorted } constructor(e, t, i = null, s = null, r = null) { this.index = e, this._opaqueSubMeshes = new He(256), this._transparentSubMeshes = new He(256), this._alphaTestSubMeshes = new He(256), this._depthOnlySubMeshes = new He(256), this._particleSystems = new He(256), this._spriteManagers = new He(256), this._empty = !0, this._edgesRenderers = new Ft(16), this._scene = t, this.opaqueSortCompareFn = i, this.alphaTestSortCompareFn = s, this.transparentSortCompareFn = r } render(e, t, i, s) { if (e) { e(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes); return } const r = this._scene.getEngine(); this._depthOnlySubMeshes.length !== 0 && (r.setColorWrite(!1), this._renderAlphaTest(this._depthOnlySubMeshes), r.setColorWrite(!0)), this._opaqueSubMeshes.length !== 0 && this._renderOpaque(this._opaqueSubMeshes), this._alphaTestSubMeshes.length !== 0 && this._renderAlphaTest(this._alphaTestSubMeshes); const n = r.getStencilBuffer(); if (r.setStencilBuffer(!1), t && this._renderSprites(), i && this._renderParticles(s), this.onBeforeTransparentRendering && this.onBeforeTransparentRendering(), this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) { if (r.setStencilBuffer(n), this._scene.useOrderIndependentTransparency) { const a = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes); a.length && this._renderTransparent(a) } else this._renderTransparent(this._transparentSubMeshes); r.setAlphaMode(0) } if (r.setStencilBuffer(!1), this._edgesRenderers.length) { for (let a = 0; a < this._edgesRenderers.length; a++)this._edgesRenderers.data[a].render(); r.setAlphaMode(0) } r.setStencilBuffer(n) } _renderOpaqueSorted(e) { return je._RenderSorted(e, this._opaqueSortCompareFn, this._scene.activeCamera, !1) } _renderAlphaTestSorted(e) { return je._RenderSorted(e, this._alphaTestSortCompareFn, this._scene.activeCamera, !1) } _renderTransparentSorted(e) { return je._RenderSorted(e, this._transparentSortCompareFn, this._scene.activeCamera, !0) } static _RenderSorted(e, t, i, s) { let r = 0, n; const a = i ? i.globalPosition : je._ZeroVector; if (s) for (; r < e.length; r++)n = e.data[r], n._alphaIndex = n.getMesh().alphaIndex, n._distanceToCamera = g.Distance(n.getBoundingInfo().boundingSphere.centerWorld, a); const o = e.length === e.data.length ? e.data : e.data.slice(0, e.length); t && o.sort(t); const l = o[0].getMesh().getScene(); for (r = 0; r < o.length; r++)if (n = o[r], !(l._activeMeshesFrozenButKeepClipping && !n.isInFrustum(l._frustumPlanes))) { if (s) { const h = n.getMaterial(); if (h && h.needDepthPrePass) { const u = h.getScene().getEngine(); u.setColorWrite(!1), u.setAlphaMode(0), n.render(!1), u.setColorWrite(!0) } } n.render(s) } } static defaultTransparentSortCompare(e, t) { return e._alphaIndex > t._alphaIndex ? 1 : e._alphaIndex < t._alphaIndex ? -1 : je.backToFrontSortCompare(e, t) } static backToFrontSortCompare(e, t) { return e._distanceToCamera < t._distanceToCamera ? 1 : e._distanceToCamera > t._distanceToCamera ? -1 : 0 } static frontToBackSortCompare(e, t) { return e._distanceToCamera < t._distanceToCamera ? -1 : e._distanceToCamera > t._distanceToCamera ? 1 : 0 } static PainterSortCompare(e, t) { const i = e.getMesh(), s = t.getMesh(); return i.material && s.material ? i.material.uniqueId - s.material.uniqueId : i.uniqueId - s.uniqueId } prepare() { this._opaqueSubMeshes.reset(), this._transparentSubMeshes.reset(), this._alphaTestSubMeshes.reset(), this._depthOnlySubMeshes.reset(), this._particleSystems.reset(), this.prepareSprites(), this._edgesRenderers.reset(), this._empty = !0 } prepareSprites() { this._spriteManagers.reset() } dispose() { this._opaqueSubMeshes.dispose(), this._transparentSubMeshes.dispose(), this._alphaTestSubMeshes.dispose(), this._depthOnlySubMeshes.dispose(), this._particleSystems.dispose(), this._spriteManagers.dispose(), this._edgesRenderers.dispose() } dispatch(e, t, i) { t === void 0 && (t = e.getMesh()), i === void 0 && (i = e.getMaterial()), i != null && (i.needAlphaBlendingForMesh(t) ? this._transparentSubMeshes.push(e) : i.needAlphaTesting() ? (i.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._alphaTestSubMeshes.push(e)) : (i.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._opaqueSubMeshes.push(e)), t._renderingGroup = this, t._edgesRenderer && t._edgesRenderer.isEnabled && this._edgesRenderers.pushNoDuplicate(t._edgesRenderer), this._empty = !1) } dispatchSprites(e) { this._spriteManagers.push(e), this._empty = !1 } dispatchParticles(e) { this._particleSystems.push(e), this._empty = !1 } _renderParticles(e) { if (this._particleSystems.length === 0) return; const t = this._scene.activeCamera; this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene); for (let i = 0; i < this._particleSystems.length; i++) { const s = this._particleSystems.data[i]; if ((t && t.layerMask & s.layerMask) === 0) continue; const r = s.emitter; (!r.position || !e || e.indexOf(r) !== -1) && this._scene._activeParticles.addCount(s.render(), !1) } this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene) } _renderSprites() { if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) return; const e = this._scene.activeCamera; this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene); for (let t = 0; t < this._spriteManagers.length; t++) { const i = this._spriteManagers.data[t]; (e && e.layerMask & i.layerMask) !== 0 && i.render() } this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene) } } je._ZeroVector = g.Zero(); const As = 500; let xi = null; const kr = 10; let Ss = null; function* Vr(c, e) { let t = 0, i = null; for (; ;) { const s = Date.now(); if (s - t >= e) { t = s; let r = c == null ? void 0 : c.getEngine().getRenderingCanvasClientRect(); r ? i = r : (i && O.Warn("Canvas rect became null.  Returning last known value"), O.Warn("Failed to get canvas rect.")) } yield i } } const Wr = c => (Rs(c), new Promise(e => { let t = 0; const i = setInterval(() => { const s = xi.next(); s.value !== null ? (clearInterval(i), e(s.value)) : (t++, t >= kr && (clearInterval(i), O.Warn("Exceeded maximum number of attempts trying to get canvas rect"), e(null))) }, As) })), Gr = c => (Rs(c), xi.next().value), Rs = c => { (!xi || c !== Ss) && (xi = Vr(c, As), Ss = c) }, Xr = "Failed to update html mesh renderer position due to failure to get canvas rect.  HtmlMesh instances may not render correctly", yt = 100, Wi = c => (e, t) => { const i = e.getMesh(), s = t.getMesh(), r = i.isHtmlMesh, n = s.isHtmlMesh; return r ? n && i.absolutePosition.z <= s.absolutePosition.z ? 1 : -1 : n ? 1 : c(e, t) }; class zr { constructor(e, { parentContainerId: t = null, _containerId: i = "css-container", topContainerZIndex: s = "10000", enableTopRender: r = !0, defaultOpaqueRenderOrder: n = je.PainterSortCompare, defaultAlphaTestRenderOrder: a = je.PainterSortCompare, defaultTransparentRenderOrder: o = je.defaultTransparentSortCompare } = {}) { _e(this, "_maskRootNode"); _e(this, "_containerId"); _e(this, "_insetDomElements"); _e(this, "_topDomElements"); _e(this, "_cache", { cameraData: { fov: 0, position: new g, style: "" }, htmlMeshData: new WeakMap }); _e(this, "_width", 0); _e(this, "_height", 0); _e(this, "_widthHalf", 0); _e(this, "_heightHalf", 0); _e(this, "_cameraViewMatrix"); _e(this, "_projectionMatrix"); _e(this, "_cameraWorldMatrix"); _e(this, "_viewport"); _e(this, "_temp", { meshMinWorld: new g, meshMaxWorld: new g, meshMinScreen: new g, meshMaxScreen: new g, objectMatrix: A.Identity(), cameraWorldMatrix: A.Identity(), cameraRotationMatrix: A.Identity(), cameraWorldMatrixAsArray: new Array(16), vp: new qt(0, 0, 0, 0) }); _e(this, "_lastDevicePixelRatio", window.devicePixelRatio); _e(this, "_cameraMatrixUpdated", !0); _e(this, "_previousCanvasDocumentPosition", { top: 0, left: 0 }); _e(this, "_renderObserver", null); _e(this, "render", (e, t) => { var f, _, p, v, E, m; let i = !1; this.updateContainerPositionIfNeeded(e), this._cameraMatrixUpdated && (this._cameraMatrixUpdated = !1, i = !0), (t.position.x !== this._cache.cameraData.position.x || t.position.y !== this._cache.cameraData.position.y || t.position.z !== this._cache.cameraData.position.z) && (this._cache.cameraData.position.copyFrom(t.position), i = !0), window.devicePixelRatio !== this._lastDevicePixelRatio && (this._lastDevicePixelRatio = window.devicePixelRatio, qe.Logger.Log("In render - dpr changed: ", this._lastDevicePixelRatio), i = !0); const s = e.meshes.filter(x => x.isHtmlMesh && (i || x.requiresUpdate)); if (i = i || s.length > 0, !i) return; const n = t.getProjectionMatrix().m[5] * this._heightHalf; this._cache.cameraData.fov !== n && (t.mode == Q.PERSPECTIVE_CAMERA ? [(f = this._topDomElements) == null ? void 0 : f.domElement, (_ = this._insetDomElements) == null ? void 0 : _.domElement].forEach(x => { x && (x.style.webkitPerspective = n + "px", x.style.perspective = n + "px") }) : [(p = this._topDomElements) == null ? void 0 : p.domElement, (v = this._insetDomElements) == null ? void 0 : v.domElement].forEach(x => { x && (x.style.webkitPerspective = "", x.style.perspective = "") }), this._cache.cameraData.fov = n), t.parent === null && t.computeWorldMatrix(); const a = this._temp.cameraWorldMatrix; a.copyFrom(t.getWorldMatrix()); const o = this._temp.cameraRotationMatrix; a.getRotationMatrix().transposeToRef(o); const l = this._temp.cameraWorldMatrixAsArray; a.copyToArray(l), l[1] = o.m[1], l[2] = -o.m[2], l[4] = -o.m[4], l[6] = -o.m[6], l[8] = -o.m[8], l[9] = -o.m[9], A.FromArrayToRef(l, 0, a); const u = "translateZ(" + n + "px)" + this.getCameraCSSMatrix(a) + "translate(" + this._widthHalf + "px," + this._heightHalf + "px)"; this._cache.cameraData.style !== u && ([(E = this._insetDomElements) == null ? void 0 : E.cameraElement, (m = this._topDomElements) == null ? void 0 : m.cameraElement].forEach(x => { x && (x.style.webkitTransform = u, x.style.transform = u) }), this._cache.cameraData.style = u), s.forEach(x => { this.renderHtmlMesh(x) }) }); _e(this, "onCameraMatrixChanged", e => { this._cameraViewMatrix = e.getViewMatrix(), this._projectionMatrix = e.getProjectionMatrix(), this._cameraWorldMatrix = e.getWorldMatrix(), this._viewport = e.viewport, this._cameraMatrixUpdated = !0 }); typeof document > "u" || (this._containerId = i, this.init(e, t, r, s, n, a, o)) } dispose() { var e, t; this._renderObserver && (this._renderObserver.remove(), this._renderObserver = null), (e = this._topDomElements) == null || e.container.remove(), this._topDomElements = null, (t = this._insetDomElements) == null || t.container.remove(), this._insetDomElements = null } init(e, t, i, s, r, n, a) { if (typeof document > "u") return; let o = t ? document.getElementById(t) : document.body; o || (o = document.body); const l = `${this._containerId}_inset`; if (this._insetDomElements = this.createDomElements(l), o.insertBefore(this._insetDomElements.container, o.firstChild), i) { const x = `${this._containerId}_top`; this._topDomElements = this.createDomElements(x), this._topDomElements.container.style.zIndex = s, this._topDomElements.container.style.pointerEvents = "none", o.insertBefore(this._topDomElements.container, o.firstChild) } this.setSize(e.getEngine().getRenderWidth(), e.getEngine().getRenderHeight()); const h = e.getEngine(), f = (() => { h.resize(), this.setSize(e.getEngine().getRenderWidth(), e.getEngine().getRenderHeight()) }).bind(this); if ("ResizeObserver" in window) { const x = h.getRenderingCanvas(); new ResizeObserver(S => { for (const y of S) y.target === x && f() }).observe(x) } else window.addEventListener("resize", f); const _ = this.onCameraMatrixChanged.bind(this), p = () => { const x = e.activeCamera; x && (x.onProjectionMatrixChangedObservable.add(_), x.onViewMatrixChangedObservable.add(_)) }; e.activeCamera ? p() : e.onActiveCameraChanged.add(p); const v = Wi(r), E = Wi(n), m = Wi(a); e.setRenderingOrder(0, v, E, m), this._renderObserver = e.onAfterRenderObservable.add(() => { this.render(e, e.activeCamera) }) } createDomElements(e) { const t = document.getElementById(e); t && t.remove(); const i = document.createElement("div"); i.id = e, i.style.position = "absolute", i.style.width = "100%", i.style.height = "100%", i.style.zIndex = "-1"; const s = document.createElement("div"); s.style.overflow = "hidden"; const r = document.createElement("div"); return r.style.webkitTransformStyle = "preserve-3d", r.style.transformStyle = "preserve-3d", r.style.pointerEvents = "none", s.appendChild(r), i.appendChild(s), { container: i, domElement: s, cameraElement: r } } getSize() { return { width: this._width, height: this._height } } setSize(e, t) { this._width = e, this._height = t, this._widthHalf = this._width / 2, this._heightHalf = this._height / 2, [this._insetDomElements.domElement, this._topDomElements.domElement, this._insetDomElements.cameraElement, this._topDomElements.cameraElement].forEach(s => { s && (s.style.width = `${e}px`, s.style.height = `${t}px`) }) } getCameraCSSMatrix(e) { const t = e.m; return `matrix3d(${this.epsilon(t[0])},${this.epsilon(-t[1])},${this.epsilon(t[2])},${this.epsilon(t[3])},${this.epsilon(t[4])},${this.epsilon(-t[5])},${this.epsilon(t[6])},${this.epsilon(t[7])},${this.epsilon(t[8])},${this.epsilon(-t[9])},${this.epsilon(t[10])},${this.epsilon(t[11])},${this.epsilon(t[12])},${this.epsilon(-t[13])},${this.epsilon(t[14])},${this.epsilon(t[15])})` } getHtmlContentCSSMatrix(e) { const t = e.m; return `matrix3d(${this.epsilon(t[0])},${this.epsilon(t[1])},${this.epsilon(-t[2])},${this.epsilon(t[3])},${this.epsilon(-t[4])},${this.epsilon(-t[5])},${this.epsilon(t[6])},${this.epsilon(-t[7])},${this.epsilon(-t[8])},${this.epsilon(-t[9])},${this.epsilon(t[10])},${this.epsilon(t[11])},${this.epsilon(t[12])},${this.epsilon(t[13])},${this.epsilon(t[14])},${this.epsilon(t[15])})` } renderHtmlMesh(e) { var o, l, h; if (!e.element) return; let t = this._cache.htmlMeshData.get(e); if (t || (t = { baseScaleFactor: 1, style: "" }, this._cache.htmlMeshData.set(e, t)), this._cameraWorldMatrix || (this._cameraWorldMatrix = (o = e.getScene().activeCamera) == null ? void 0 : o.getWorldMatrix()), !this._cameraWorldMatrix) return; const i = e.top ? (l = this._topDomElements) == null ? void 0 : l.cameraElement : (h = this._insetDomElements) == null ? void 0 : h.cameraElement; e.element.parentNode !== i && i.appendChild(e.element), e.requiresUpdate && this.updateBaseScaleFactor(e); const s = e.getWorldMatrix(), r = this._temp.objectMatrix; r.copyFrom(s); const n = e.getAbsolutePosition(); r.setRowFromFloats(3, (-this._cameraWorldMatrix.m[12] + n.x) * yt, (-this._cameraWorldMatrix.m[13] + n.y) * yt, (this._cameraWorldMatrix.m[14] - n.z) * yt, this._cameraWorldMatrix.m[15] * 1e-5 * yt), r.multiplyAtIndex(3, yt), r.multiplyAtIndex(7, yt), r.multiplyAtIndex(11, yt); const a = `translate(-50%, -50%) ${this.getHtmlContentCSSMatrix(r)} scale3d(${t.baseScaleFactor}, ${t.baseScaleFactor}, 1)`; t.style !== a && (e.element.style.webkitTransform = a, e.element.style.transform = a) } updateBaseScaleFactor(e) { const t = e.getScene(), i = t.activeCamera, s = this._temp.vp; i.viewport.toGlobalToRef(this._width, this._height, s); const r = e.getBoundingInfo(), n = this._temp.meshMinWorld, a = this._temp.meshMaxWorld; n.copyFrom(r.minimum), a.copyFrom(r.maximum), n.z = r.boundingBox.minimumWorld.z, a.z = r.boundingBox.maximumWorld.z; const o = t.getTransformMatrix(), l = this._temp.meshMinScreen, h = this._temp.meshMaxScreen, u = A.IdentityReadOnly; g.ProjectToRef(n, u, o, s, l), g.ProjectToRef(a, u, o, s, h); const f = Math.abs(h.x - l.x), _ = Math.abs(h.y - l.y); let p = this._width, v = this._height; const E = f / _, m = p / v; E > m ? p = v * E : v = p / E, e.setContentSizePx(p, v); let x = Math.min(f / p, _ / v); x > .99 && (x = 1); const C = this._cache.cameraData.fov, y = i.position.subtract(e.absolutePosition).length() * yt / (C * .5); x = x * y / 2; let b = this._cache.htmlMeshData.get(e); b && (b.baseScaleFactor = x) } async updateContainerPositionIfNeeded(e) { var a, o; const t = await Wr(e); if (!t) { qe.Logger.Warn(Xr); return } const i = window.scrollY, s = window.scrollX, r = t.top + i, n = t.left + s; (this._previousCanvasDocumentPosition.top !== r || this._previousCanvasDocumentPosition.left !== n) && (this._previousCanvasDocumentPosition.top = r, this._previousCanvasDocumentPosition.left = n, [(a = this._insetDomElements) == null ? void 0 : a.container, (o = this._topDomElements) == null ? void 0 : o.container].forEach(l => { if (!l) return; const h = l.offsetParent, u = h.getBoundingClientRect(), f = u.top + i, _ = u.left + s, p = this.getAncestorMarginsAndPadding(h), v = window.getComputedStyle(document.body), E = parseInt(v.marginTop, 10), m = parseInt(v.marginLeft, 10); l.style.top = `${r - f - p.marginTop + p.paddingTop + E}px`, l.style.left = `${n - _ - p.marginLeft + p.paddingLeft + m}px` })) } epsilon(e) { return Math.abs(e) < 1e-10 ? 0 : e } getAncestorMarginsAndPadding(e) { let t = 0, i = 0, s = 0, r = 0; for (; e && e !== document.body && e !== document.documentElement;) { const n = window.getComputedStyle(e); t += parseInt(n.marginTop, 10), i += parseInt(n.marginLeft, 10), s += parseInt(n.paddingTop, 10), r += parseInt(n.paddingLeft, 10), e = e.offsetParent } return { marginTop: t, marginLeft: i, paddingTop: s, paddingLeft: r } } } function Gi(c, e, t) { try { const i = c.next(); i.done ? e(i) : i.value ? i.value.then(() => { i.value = void 0, e(i) }, t) : e(i) } catch (i) { t(i) } } function Hr(c = 25) { let e; return (t, i, s) => { const r = performance.now(); e === void 0 || r - e > c ? (e = r, setTimeout(() => { Gi(t, i, s) }, 0)) : Gi(t, i, s) } } function ys(c, e, t, i, s) { const r = () => { let n; const a = o => { o.done ? t(o.value) : n === void 0 ? n = !0 : r() }; do n = void 0, !s || !s.aborted ? e(c, a, i) : i(new Error("Aborted")), n === void 0 && (n = !1); while (n) }; r() } function Xi(c, e) { let t; return ys(c, Gi, i => t = i, i => { throw i }, e), t } function Kr(c, e, t) { return new Promise((i, s) => { ys(c, e, i, s, t) }) } function Yr(c, e) { return (...t) => Xi(c(...t), e) } class Ms { constructor() { this._count = 0, this._data = {} } copyFrom(e) { this.clear(), e.forEach((t, i) => this.add(t, i)) } get(e) { const t = this._data[e]; if (t !== void 0) return t } getOrAddWithFactory(e, t) { let i = this.get(e); return i !== void 0 || (i = t(e), i && this.add(e, i)), i } getOrAdd(e, t) { const i = this.get(e); return i !== void 0 ? i : (this.add(e, t), t) } contains(e) { return this._data[e] !== void 0 } add(e, t) { return this._data[e] !== void 0 ? !1 : (this._data[e] = t, ++this._count, !0) } set(e, t) { return this._data[e] === void 0 ? !1 : (this._data[e] = t, !0) } getAndRemove(e) { const t = this.get(e); return t !== void 0 ? (delete this._data[e], --this._count, t) : null } remove(e) { return this.contains(e) ? (delete this._data[e], --this._count, !0) : !1 } clear() { this._data = {}, this._count = 0 } get count() { return this._count } forEach(e) { for (const t in this._data) { const i = this._data[t]; e(t, i) } } first(e) { for (const t in this._data) { const i = this._data[t], s = e(t, i); if (s) return s } return null } } class zi { constructor() { this.rootNodes = [], this.cameras = [], this.lights = [], this.meshes = [], this.skeletons = [], this.particleSystems = [], this.animations = [], this.animationGroups = [], this.multiMaterials = [], this.materials = [], this.morphTargetManagers = [], this.geometries = [], this.transformNodes = [], this.actionManagers = [], this.textures = [], this._environmentTexture = null, this.postProcesses = [] } static AddParser(e, t) { this._BabylonFileParsers[e] = t } static GetParser(e) { return this._BabylonFileParsers[e] ? this._BabylonFileParsers[e] : null } static AddIndividualParser(e, t) { this._IndividualBabylonFileParsers[e] = t } static GetIndividualParser(e) { return this._IndividualBabylonFileParsers[e] ? this._IndividualBabylonFileParsers[e] : null } static Parse(e, t, i, s) { for (const r in this._BabylonFileParsers) Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, r) && this._BabylonFileParsers[r](e, t, i, s) } get environmentTexture() { return this._environmentTexture } set environmentTexture(e) { this._environmentTexture = e } getNodes() { let e = []; return e = e.concat(this.meshes), e = e.concat(this.lights), e = e.concat(this.cameras), e = e.concat(this.transformNodes), this.skeletons.forEach(t => e = e.concat(t.bones)), e } } zi._BabylonFileParsers = {}, zi._IndividualBabylonFileParsers = {}; class Cs {
        constructor(e) { if (this._keys = [], this._isDirty = !0, this._areLightsDirty = !0, this._areLightsDisposed = !1, this._areAttributesDirty = !0, this._areTexturesDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._arePrePassDirty = !0, this._areImageProcessingDirty = !0, this._normals = !1, this._uvs = !1, this._needNormals = !1, this._needUVs = !1, this._externalProperties = e, e) for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && this._setDefaultValue(t) } get isDirty() { return this._isDirty } markAsProcessed() { this._isDirty = !1, this._areAttributesDirty = !1, this._areTexturesDirty = !1, this._areFresnelDirty = !1, this._areLightsDirty = !1, this._areLightsDisposed = !1, this._areMiscDirty = !1, this._arePrePassDirty = !1, this._areImageProcessingDirty = !1 } markAsUnprocessed() { this._isDirty = !0 } markAllAsDirty() { this._areTexturesDirty = !0, this._areAttributesDirty = !0, this._areLightsDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._arePrePassDirty = !1, this._areImageProcessingDirty = !0, this._isDirty = !0 } markAsImageProcessingDirty() { this._areImageProcessingDirty = !0, this._isDirty = !0 } markAsLightDirty(e = !1) { this._areLightsDirty = !0, this._areLightsDisposed = this._areLightsDisposed || e, this._isDirty = !0 } markAsAttributesDirty() { this._areAttributesDirty = !0, this._isDirty = !0 } markAsTexturesDirty() { this._areTexturesDirty = !0, this._isDirty = !0 } markAsFresnelDirty() { this._areFresnelDirty = !0, this._isDirty = !0 } markAsMiscDirty() { this._areMiscDirty = !0, this._isDirty = !0 } markAsPrePassDirty() { this._arePrePassDirty = !0, this._isDirty = !0 } rebuild() { this._keys.length = 0; for (const e of Object.keys(this)) e[0] !== "_" && this._keys.push(e); if (this._externalProperties) for (const e in this._externalProperties) this._keys.indexOf(e) === -1 && this._keys.push(e) } isEqual(e) { if (this._keys.length !== e._keys.length) return !1; for (let t = 0; t < this._keys.length; t++) { const i = this._keys[t]; if (this[i] !== e[i]) return !1 } return !0 } cloneTo(e) { this._keys.length !== e._keys.length && (e._keys = this._keys.slice(0)); for (let t = 0; t < this._keys.length; t++) { const i = this._keys[t]; e[i] = this[i] } } reset() { this._keys.forEach(e => this._setDefaultValue(e)) } _setDefaultValue(e) { var t, i, s, r, n; const a = (s = (i = (t = this._externalProperties) === null || t === void 0 ? void 0 : t[e]) === null || i === void 0 ? void 0 : i.type) !== null && s !== void 0 ? s : typeof this[e], o = (n = (r = this._externalProperties) === null || r === void 0 ? void 0 : r[e]) === null || n === void 0 ? void 0 : n.default; switch (a) { case "number": this[e] = o ?? 0; break; case "string": this[e] = o ?? ""; break; default: this[e] = o ?? !1; break } } toString() {
            let e = ""; for (let t = 0; t < this._keys.length; t++) {
                const i = this._keys[t], s = this[i]; switch (typeof s) {
                    case "number": case "string": e += "#define " + i + " " + s + `
`; break; default: s && (e += "#define " + i + `
`); break
                }
            } return e
        }
    } class me { constructor() { this._dirty = !0, this._tempColor = new de(0, 0, 0, 0), this._globalCurve = new de(0, 0, 0, 0), this._highlightsCurve = new de(0, 0, 0, 0), this._midtonesCurve = new de(0, 0, 0, 0), this._shadowsCurve = new de(0, 0, 0, 0), this._positiveCurve = new de(0, 0, 0, 0), this._negativeCurve = new de(0, 0, 0, 0), this._globalHue = 30, this._globalDensity = 0, this._globalSaturation = 0, this._globalExposure = 0, this._highlightsHue = 30, this._highlightsDensity = 0, this._highlightsSaturation = 0, this._highlightsExposure = 0, this._midtonesHue = 30, this._midtonesDensity = 0, this._midtonesSaturation = 0, this._midtonesExposure = 0, this._shadowsHue = 30, this._shadowsDensity = 0, this._shadowsSaturation = 0, this._shadowsExposure = 0 } get globalHue() { return this._globalHue } set globalHue(e) { this._globalHue = e, this._dirty = !0 } get globalDensity() { return this._globalDensity } set globalDensity(e) { this._globalDensity = e, this._dirty = !0 } get globalSaturation() { return this._globalSaturation } set globalSaturation(e) { this._globalSaturation = e, this._dirty = !0 } get globalExposure() { return this._globalExposure } set globalExposure(e) { this._globalExposure = e, this._dirty = !0 } get highlightsHue() { return this._highlightsHue } set highlightsHue(e) { this._highlightsHue = e, this._dirty = !0 } get highlightsDensity() { return this._highlightsDensity } set highlightsDensity(e) { this._highlightsDensity = e, this._dirty = !0 } get highlightsSaturation() { return this._highlightsSaturation } set highlightsSaturation(e) { this._highlightsSaturation = e, this._dirty = !0 } get highlightsExposure() { return this._highlightsExposure } set highlightsExposure(e) { this._highlightsExposure = e, this._dirty = !0 } get midtonesHue() { return this._midtonesHue } set midtonesHue(e) { this._midtonesHue = e, this._dirty = !0 } get midtonesDensity() { return this._midtonesDensity } set midtonesDensity(e) { this._midtonesDensity = e, this._dirty = !0 } get midtonesSaturation() { return this._midtonesSaturation } set midtonesSaturation(e) { this._midtonesSaturation = e, this._dirty = !0 } get midtonesExposure() { return this._midtonesExposure } set midtonesExposure(e) { this._midtonesExposure = e, this._dirty = !0 } get shadowsHue() { return this._shadowsHue } set shadowsHue(e) { this._shadowsHue = e, this._dirty = !0 } get shadowsDensity() { return this._shadowsDensity } set shadowsDensity(e) { this._shadowsDensity = e, this._dirty = !0 } get shadowsSaturation() { return this._shadowsSaturation } set shadowsSaturation(e) { this._shadowsSaturation = e, this._dirty = !0 } get shadowsExposure() { return this._shadowsExposure } set shadowsExposure(e) { this._shadowsExposure = e, this._dirty = !0 } getClassName() { return "ColorCurves" } static Bind(e, t, i = "vCameraColorCurvePositive", s = "vCameraColorCurveNeutral", r = "vCameraColorCurveNegative") { e._dirty && (e._dirty = !1, e._getColorGradingDataToRef(e._globalHue, e._globalDensity, e._globalSaturation, e._globalExposure, e._globalCurve), e._getColorGradingDataToRef(e._highlightsHue, e._highlightsDensity, e._highlightsSaturation, e._highlightsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._highlightsCurve), e._getColorGradingDataToRef(e._midtonesHue, e._midtonesDensity, e._midtonesSaturation, e._midtonesExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._midtonesCurve), e._getColorGradingDataToRef(e._shadowsHue, e._shadowsDensity, e._shadowsSaturation, e._shadowsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._shadowsCurve), e._highlightsCurve.subtractToRef(e._midtonesCurve, e._positiveCurve), e._midtonesCurve.subtractToRef(e._shadowsCurve, e._negativeCurve)), t && (t.setFloat4(i, e._positiveCurve.r, e._positiveCurve.g, e._positiveCurve.b, e._positiveCurve.a), t.setFloat4(s, e._midtonesCurve.r, e._midtonesCurve.g, e._midtonesCurve.b, e._midtonesCurve.a), t.setFloat4(r, e._negativeCurve.r, e._negativeCurve.g, e._negativeCurve.b, e._negativeCurve.a)) } static PrepareUniforms(e) { e.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative") } _getColorGradingDataToRef(e, t, i, s, r) { e != null && (e = me._Clamp(e, 0, 360), t = me._Clamp(t, -100, 100), i = me._Clamp(i, -100, 100), s = me._Clamp(s, -100, 100), t = me._ApplyColorGradingSliderNonlinear(t), t *= .5, s = me._ApplyColorGradingSliderNonlinear(s), t < 0 && (t *= -1, e = (e + 180) % 360), me._FromHSBToRef(e, t, 50 + .25 * s, r), r.scaleToRef(2, r), r.a = 1 + .01 * i) } static _ApplyColorGradingSliderNonlinear(e) { e /= 100; let t = Math.abs(e); return t = Math.pow(t, 2), e < 0 && (t *= -1), t *= 100, t } static _FromHSBToRef(e, t, i, s) { let r = me._Clamp(e, 0, 360); const n = me._Clamp(t / 100, 0, 1), a = me._Clamp(i / 100, 0, 1); if (n === 0) s.r = a, s.g = a, s.b = a; else { r /= 60; const o = Math.floor(r), l = r - o, h = a * (1 - n), u = a * (1 - n * l), f = a * (1 - n * (1 - l)); switch (o) { case 0: s.r = a, s.g = f, s.b = h; break; case 1: s.r = u, s.g = a, s.b = h; break; case 2: s.r = h, s.g = a, s.b = f; break; case 3: s.r = h, s.g = u, s.b = a; break; case 4: s.r = f, s.g = h, s.b = a; break; default: s.r = a, s.g = h, s.b = u; break } } s.a = 1 } static _Clamp(e, t, i) { return Math.min(Math.max(e, t), i) } clone() { return re.Clone(() => new me, this) } serialize() { return re.Serialize(this) } static Parse(e) { return re.Parse(() => new me, e, null, null) } } T([M()], me.prototype, "_globalHue", void 0), T([M()], me.prototype, "_globalDensity", void 0), T([M()], me.prototype, "_globalSaturation", void 0), T([M()], me.prototype, "_globalExposure", void 0), T([M()], me.prototype, "_highlightsHue", void 0), T([M()], me.prototype, "_highlightsDensity", void 0), T([M()], me.prototype, "_highlightsSaturation", void 0), T([M()], me.prototype, "_highlightsExposure", void 0), T([M()], me.prototype, "_midtonesHue", void 0), T([M()], me.prototype, "_midtonesDensity", void 0), T([M()], me.prototype, "_midtonesSaturation", void 0), T([M()], me.prototype, "_midtonesExposure", void 0), re._ColorCurvesParser = me.Parse; class oe { constructor() { this.colorCurves = new me, this._colorCurvesEnabled = !1, this._colorGradingEnabled = !1, this._colorGradingWithGreenDepth = !0, this._colorGradingBGR = !0, this._exposure = 1, this._toneMappingEnabled = !1, this._toneMappingType = oe.TONEMAPPING_STANDARD, this._contrast = 1, this.vignetteStretch = 0, this.vignetteCenterX = 0, this.vignetteCenterY = 0, this.vignetteWeight = 1.5, this.vignetteColor = new de(0, 0, 0, 0), this.vignetteCameraFov = .5, this._vignetteBlendMode = oe.VIGNETTEMODE_MULTIPLY, this._vignetteEnabled = !1, this._ditheringEnabled = !1, this._ditheringIntensity = 1 / 255, this._skipFinalColorClamp = !1, this._applyByPostProcess = !1, this._isEnabled = !0, this.onUpdateParameters = new L } get colorCurvesEnabled() { return this._colorCurvesEnabled } set colorCurvesEnabled(e) { this._colorCurvesEnabled !== e && (this._colorCurvesEnabled = e, this._updateParameters()) } get colorGradingTexture() { return this._colorGradingTexture } set colorGradingTexture(e) { this._colorGradingTexture !== e && (this._colorGradingTexture = e, this._updateParameters()) } get colorGradingEnabled() { return this._colorGradingEnabled } set colorGradingEnabled(e) { this._colorGradingEnabled !== e && (this._colorGradingEnabled = e, this._updateParameters()) } get colorGradingWithGreenDepth() { return this._colorGradingWithGreenDepth } set colorGradingWithGreenDepth(e) { this._colorGradingWithGreenDepth !== e && (this._colorGradingWithGreenDepth = e, this._updateParameters()) } get colorGradingBGR() { return this._colorGradingBGR } set colorGradingBGR(e) { this._colorGradingBGR !== e && (this._colorGradingBGR = e, this._updateParameters()) } get exposure() { return this._exposure } set exposure(e) { this._exposure !== e && (this._exposure = e, this._updateParameters()) } get toneMappingEnabled() { return this._toneMappingEnabled } set toneMappingEnabled(e) { this._toneMappingEnabled !== e && (this._toneMappingEnabled = e, this._updateParameters()) } get toneMappingType() { return this._toneMappingType } set toneMappingType(e) { this._toneMappingType !== e && (this._toneMappingType = e, this._updateParameters()) } get contrast() { return this._contrast } set contrast(e) { this._contrast !== e && (this._contrast = e, this._updateParameters()) } get vignetteCentreY() { return this.vignetteCenterY } set vignetteCentreY(e) { this.vignetteCenterY = e } get vignetteCentreX() { return this.vignetteCenterX } set vignetteCentreX(e) { this.vignetteCenterX = e } get vignetteBlendMode() { return this._vignetteBlendMode } set vignetteBlendMode(e) { this._vignetteBlendMode !== e && (this._vignetteBlendMode = e, this._updateParameters()) } get vignetteEnabled() { return this._vignetteEnabled } set vignetteEnabled(e) { this._vignetteEnabled !== e && (this._vignetteEnabled = e, this._updateParameters()) } get ditheringEnabled() { return this._ditheringEnabled } set ditheringEnabled(e) { this._ditheringEnabled !== e && (this._ditheringEnabled = e, this._updateParameters()) } get ditheringIntensity() { return this._ditheringIntensity } set ditheringIntensity(e) { this._ditheringIntensity !== e && (this._ditheringIntensity = e, this._updateParameters()) } get skipFinalColorClamp() { return this._skipFinalColorClamp } set skipFinalColorClamp(e) { this._skipFinalColorClamp !== e && (this._skipFinalColorClamp = e, this._updateParameters()) } get applyByPostProcess() { return this._applyByPostProcess } set applyByPostProcess(e) { this._applyByPostProcess !== e && (this._applyByPostProcess = e, this._updateParameters()) } get isEnabled() { return this._isEnabled } set isEnabled(e) { this._isEnabled !== e && (this._isEnabled = e, this._updateParameters()) } _updateParameters() { this.onUpdateParameters.notifyObservers(this) } getClassName() { return "ImageProcessingConfiguration" } static PrepareUniforms(e, t) { t.EXPOSURE && e.push("exposureLinear"), t.CONTRAST && e.push("contrast"), t.COLORGRADING && e.push("colorTransformSettings"), (t.VIGNETTE || t.DITHER) && e.push("vInverseScreenSize"), t.VIGNETTE && (e.push("vignetteSettings1"), e.push("vignetteSettings2")), t.COLORCURVES && me.PrepareUniforms(e), t.DITHER && e.push("ditherIntensity") } static PrepareSamplers(e, t) { t.COLORGRADING && e.push("txColorTransform") } prepareDefines(e, t = !1) { if (t !== this.applyByPostProcess || !this._isEnabled) { e.VIGNETTE = !1, e.TONEMAPPING = !1, e.TONEMAPPING_ACES = !1, e.CONTRAST = !1, e.EXPOSURE = !1, e.COLORCURVES = !1, e.COLORGRADING = !1, e.COLORGRADING3D = !1, e.DITHER = !1, e.IMAGEPROCESSING = !1, e.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp, e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled; return } switch (e.VIGNETTE = this.vignetteEnabled, e.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === oe._VIGNETTEMODE_MULTIPLY, e.VIGNETTEBLENDMODEOPAQUE = !e.VIGNETTEBLENDMODEMULTIPLY, e.TONEMAPPING = this.toneMappingEnabled, this._toneMappingType) { case oe.TONEMAPPING_ACES: e.TONEMAPPING_ACES = !0; break; default: e.TONEMAPPING_ACES = !1; break }e.CONTRAST = this.contrast !== 1, e.EXPOSURE = this.exposure !== 1, e.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves, e.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture, e.COLORGRADING ? e.COLORGRADING3D = this.colorGradingTexture.is3D : e.COLORGRADING3D = !1, e.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth, e.SAMPLER3DBGRMAP = this.colorGradingBGR, e.DITHER = this._ditheringEnabled, e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess, e.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp, e.IMAGEPROCESSING = e.VIGNETTE || e.TONEMAPPING || e.CONTRAST || e.EXPOSURE || e.COLORCURVES || e.COLORGRADING || e.DITHER } isReady() { return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady() } bind(e, t) { if (this._colorCurvesEnabled && this.colorCurves && me.Bind(this.colorCurves, e), this._vignetteEnabled || this._ditheringEnabled) { const i = 1 / e.getEngine().getRenderWidth(), s = 1 / e.getEngine().getRenderHeight(); if (e.setFloat2("vInverseScreenSize", i, s), this._ditheringEnabled && e.setFloat("ditherIntensity", .5 * this._ditheringIntensity), this._vignetteEnabled) { const r = t ?? s / i; let n = Math.tan(this.vignetteCameraFov * .5), a = n * r; const o = Math.sqrt(a * n); a = G.Mix(a, o, this.vignetteStretch), n = G.Mix(n, o, this.vignetteStretch), e.setFloat4("vignetteSettings1", a, n, -a * this.vignetteCenterX, -n * this.vignetteCenterY); const l = -2 * this.vignetteWeight; e.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, l) } } if (e.setFloat("exposureLinear", this.exposure), e.setFloat("contrast", this.contrast), this.colorGradingTexture) { e.setTexture("txColorTransform", this.colorGradingTexture); const i = this.colorGradingTexture.getSize().height; e.setFloat4("colorTransformSettings", (i - 1) / i, .5 / i, i, this.colorGradingTexture.level) } } clone() { return re.Clone(() => new oe, this) } serialize() { return re.Serialize(this) } static Parse(e) { const t = re.Parse(() => new oe, e, null, null); return e.vignetteCentreX !== void 0 && (t.vignetteCenterX = e.vignetteCentreX), e.vignetteCentreY !== void 0 && (t.vignetteCenterY = e.vignetteCentreY), t } static get VIGNETTEMODE_MULTIPLY() { return this._VIGNETTEMODE_MULTIPLY } static get VIGNETTEMODE_OPAQUE() { return this._VIGNETTEMODE_OPAQUE } } oe.TONEMAPPING_STANDARD = 0, oe.TONEMAPPING_ACES = 1, oe._VIGNETTEMODE_MULTIPLY = 0, oe._VIGNETTEMODE_OPAQUE = 1, T([ur()], oe.prototype, "colorCurves", void 0), T([M()], oe.prototype, "_colorCurvesEnabled", void 0), T([st("colorGradingTexture")], oe.prototype, "_colorGradingTexture", void 0), T([M()], oe.prototype, "_colorGradingEnabled", void 0), T([M()], oe.prototype, "_colorGradingWithGreenDepth", void 0), T([M()], oe.prototype, "_colorGradingBGR", void 0), T([M()], oe.prototype, "_exposure", void 0), T([M()], oe.prototype, "_toneMappingEnabled", void 0), T([M()], oe.prototype, "_toneMappingType", void 0), T([M()], oe.prototype, "_contrast", void 0), T([M()], oe.prototype, "vignetteStretch", void 0), T([M()], oe.prototype, "vignetteCenterX", void 0), T([M()], oe.prototype, "vignetteCenterY", void 0), T([M()], oe.prototype, "vignetteWeight", void 0), T([fr()], oe.prototype, "vignetteColor", void 0), T([M()], oe.prototype, "vignetteCameraFov", void 0), T([M()], oe.prototype, "_vignetteBlendMode", void 0), T([M()], oe.prototype, "_vignetteEnabled", void 0), T([M()], oe.prototype, "_ditheringEnabled", void 0), T([M()], oe.prototype, "_ditheringIntensity", void 0), T([M()], oe.prototype, "_skipFinalColorClamp", void 0), T([M()], oe.prototype, "_applyByPostProcess", void 0), T([M()], oe.prototype, "_isEnabled", void 0), re._ImageProcessingConfigurationParser = oe.Parse, $.prototype.createUniformBuffer = function (c, e) { const t = this._gl.createBuffer(); if (!t) throw new Error("Unable to create uniform buffer"); const i = new ii(t); return this.bindUniformBuffer(i), c instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, c, this._gl.STATIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(c), this._gl.STATIC_DRAW), this.bindUniformBuffer(null), i.references = 1, i }, $.prototype.createDynamicUniformBuffer = function (c, e) { const t = this._gl.createBuffer(); if (!t) throw new Error("Unable to create dynamic uniform buffer"); const i = new ii(t); return this.bindUniformBuffer(i), c instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, c, this._gl.DYNAMIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(c), this._gl.DYNAMIC_DRAW), this.bindUniformBuffer(null), i.references = 1, i }, $.prototype.updateUniformBuffer = function (c, e, t, i) { this.bindUniformBuffer(c), t === void 0 && (t = 0), i === void 0 ? e instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, t, e) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, t, new Float32Array(e)) : e instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, e.subarray(t, t + i)) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(e).subarray(t, t + i)), this.bindUniformBuffer(null) }, $.prototype.bindUniformBuffer = function (c) { this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, c ? c.underlyingResource : null) }, $.prototype.bindUniformBufferBase = function (c, e, t) { this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, e, c ? c.underlyingResource : null) }, $.prototype.bindUniformBlock = function (c, e, t) { const i = c.program, s = this._gl.getUniformBlockIndex(i, e); s !== 4294967295 && this._gl.uniformBlockBinding(i, s, t) }; class U { constructor(e, t, i, s, r = !1) { this._valueCache = {}, this._engine = e, this._noUBO = !e.supportsUniformBuffers || r, this._dynamic = i, this._name = s ?? "no-name", this._data = t || [], this._uniformLocations = {}, this._uniformSizes = {}, this._uniformArraySizes = {}, this._uniformLocationPointer = 0, this._needSync = !1, this._engine._features.trackUbosInFrame && (this._buffers = [], this._bufferIndex = -1, this._createBufferOnWrite = !1, this._currentFrameId = 0), this._noUBO ? (this.updateMatrix3x3 = this._updateMatrix3x3ForEffect, this.updateMatrix2x2 = this._updateMatrix2x2ForEffect, this.updateFloat = this._updateFloatForEffect, this.updateFloat2 = this._updateFloat2ForEffect, this.updateFloat3 = this._updateFloat3ForEffect, this.updateFloat4 = this._updateFloat4ForEffect, this.updateFloatArray = this._updateFloatArrayForEffect, this.updateArray = this._updateArrayForEffect, this.updateIntArray = this._updateIntArrayForEffect, this.updateUIntArray = this._updateUIntArrayForEffect, this.updateMatrix = this._updateMatrixForEffect, this.updateMatrices = this._updateMatricesForEffect, this.updateVector3 = this._updateVector3ForEffect, this.updateVector4 = this._updateVector4ForEffect, this.updateColor3 = this._updateColor3ForEffect, this.updateColor4 = this._updateColor4ForEffect, this.updateDirectColor4 = this._updateDirectColor4ForEffect, this.updateInt = this._updateIntForEffect, this.updateInt2 = this._updateInt2ForEffect, this.updateInt3 = this._updateInt3ForEffect, this.updateInt4 = this._updateInt4ForEffect, this.updateUInt = this._updateUIntForEffect, this.updateUInt2 = this._updateUInt2ForEffect, this.updateUInt3 = this._updateUInt3ForEffect, this.updateUInt4 = this._updateUInt4ForEffect) : (this._engine._uniformBuffers.push(this), this.updateMatrix3x3 = this._updateMatrix3x3ForUniform, this.updateMatrix2x2 = this._updateMatrix2x2ForUniform, this.updateFloat = this._updateFloatForUniform, this.updateFloat2 = this._updateFloat2ForUniform, this.updateFloat3 = this._updateFloat3ForUniform, this.updateFloat4 = this._updateFloat4ForUniform, this.updateFloatArray = this._updateFloatArrayForUniform, this.updateArray = this._updateArrayForUniform, this.updateIntArray = this._updateIntArrayForUniform, this.updateUIntArray = this._updateUIntArrayForUniform, this.updateMatrix = this._updateMatrixForUniform, this.updateMatrices = this._updateMatricesForUniform, this.updateVector3 = this._updateVector3ForUniform, this.updateVector4 = this._updateVector4ForUniform, this.updateColor3 = this._updateColor3ForUniform, this.updateColor4 = this._updateColor4ForUniform, this.updateDirectColor4 = this._updateDirectColor4ForUniform, this.updateInt = this._updateIntForUniform, this.updateInt2 = this._updateInt2ForUniform, this.updateInt3 = this._updateInt3ForUniform, this.updateInt4 = this._updateInt4ForUniform, this.updateUInt = this._updateUIntForUniform, this.updateUInt2 = this._updateUInt2ForUniform, this.updateUInt3 = this._updateUInt3ForUniform, this.updateUInt4 = this._updateUInt4ForUniform) } get useUbo() { return !this._noUBO } get isSync() { return !this._needSync } isDynamic() { return this._dynamic !== void 0 } getData() { return this._bufferData } getBuffer() { return this._buffer } _fillAlignment(e) { let t; if (e <= 2 ? t = e : t = 4, this._uniformLocationPointer % t !== 0) { const i = this._uniformLocationPointer; this._uniformLocationPointer += t - this._uniformLocationPointer % t; const s = this._uniformLocationPointer - i; for (let r = 0; r < s; r++)this._data.push(0) } } addUniform(e, t, i = 0) { if (this._noUBO || this._uniformLocations[e] !== void 0) return; let s; if (i > 0) { if (t instanceof Array) throw "addUniform should not be use with Array in UBO: " + e; if (this._fillAlignment(4), this._uniformArraySizes[e] = { strideSize: t, arraySize: i }, t == 16) t = t * i; else { const n = (4 - t) * i; t = t * i + n } s = []; for (let r = 0; r < t; r++)s.push(0) } else { if (t instanceof Array) s = t, t = s.length; else { t = t, s = []; for (let r = 0; r < t; r++)s.push(0) } this._fillAlignment(t) } this._uniformSizes[e] = t, this._uniformLocations[e] = this._uniformLocationPointer, this._uniformLocationPointer += t; for (let r = 0; r < t; r++)this._data.push(s[r]); this._needSync = !0 } addMatrix(e, t) { this.addUniform(e, Array.prototype.slice.call(t.toArray())) } addFloat2(e, t, i) { const s = [t, i]; this.addUniform(e, s) } addFloat3(e, t, i, s) { const r = [t, i, s]; this.addUniform(e, r) } addColor3(e, t) { const i = [t.r, t.g, t.b]; this.addUniform(e, i) } addColor4(e, t, i) { const s = [t.r, t.g, t.b, i]; this.addUniform(e, s) } addVector3(e, t) { const i = [t.x, t.y, t.z]; this.addUniform(e, i) } addMatrix3x3(e) { this.addUniform(e, 12) } addMatrix2x2(e) { this.addUniform(e, 8) } create() { this._noUBO || this._buffer || (this._fillAlignment(4), this._bufferData = new Float32Array(this._data), this._rebuild(), this._needSync = !0) } _getNames() { const e = []; for (const t in this._uniformLocations) e.push(t); return e.join(",") } _rebuild() { this._noUBO || !this._bufferData || (this._dynamic ? this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + "_UniformList:" + this._getNames()) : this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + "_UniformList:" + this._getNames()), this._engine._features.trackUbosInFrame && (this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]), this._bufferIndex = this._buffers.length - 1, this._createBufferOnWrite = !1)) } get _numBuffers() { return this._buffers.length } get _indexBuffer() { return this._bufferIndex } get name() { return this._name } get currentEffect() { return this._currentEffect } _buffersEqual(e, t) { for (let i = 0; i < e.length; ++i)if (e[i] !== t[i]) return !1; return !0 } _copyBuffer(e, t) { for (let i = 0; i < e.length; ++i)t[i] = e[i] } update() { if (!this._noUBO) { if (this.bindUniformBuffer(), !this._buffer) { this.create(); return } if (!this._dynamic && !this._needSync) { this._createBufferOnWrite = this._engine._features.trackUbosInFrame; return } if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) { this._needSync = !1, this._createBufferOnWrite = this._engine._features.trackUbosInFrame; return } else this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]); this._engine.updateUniformBuffer(this._buffer, this._bufferData), this._engine._features._collectUbosUpdatedInFrame && (U._UpdatedUbosInFrame[this._name] || (U._UpdatedUbosInFrame[this._name] = 0), U._UpdatedUbosInFrame[this._name]++), this._needSync = !1, this._createBufferOnWrite = this._engine._features.trackUbosInFrame } } _createNewBuffer() { this._bufferIndex + 1 < this._buffers.length ? (this._bufferIndex++, this._buffer = this._buffers[this._bufferIndex][0], this._createBufferOnWrite = !1, this._needSync = !0) : this._rebuild() } _checkNewFrame() { this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId && (this._currentFrameId = this._engine.frameId, this._createBufferOnWrite = !1, this._buffers && this._buffers.length > 0 ? (this._needSync = this._bufferIndex !== 0, this._bufferIndex = 0, this._buffer = this._buffers[this._bufferIndex][0]) : this._bufferIndex = -1) } updateUniform(e, t, i) { this._checkNewFrame(); let s = this._uniformLocations[e]; if (s === void 0) { if (this._buffer) { O.Error("Cannot add an uniform after UBO has been created."); return } this.addUniform(e, i), s = this._uniformLocations[e] } if (this._buffer || this.create(), this._dynamic) for (let r = 0; r < i; r++)this._bufferData[s + r] = t[r]; else { let r = !1; for (let n = 0; n < i; n++)(i === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[s + n] !== Math.fround(t[n])) && (r = !0, this._createBufferOnWrite && this._createNewBuffer(), this._bufferData[s + n] = t[n]); this._needSync = this._needSync || r } } updateUniformArray(e, t, i) { this._checkNewFrame(); const s = this._uniformLocations[e]; if (s === void 0) { O.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine."); return } this._buffer || this.create(); const r = this._uniformArraySizes[e]; if (this._dynamic) for (let n = 0; n < i; n++)this._bufferData[s + n] = t[n]; else { let n = !1, a = 0, o = 0; for (let l = 0; l < i; l++)if (this._bufferData[s + o * 4 + a] !== G.FloatRound(t[l]) && (n = !0, this._createBufferOnWrite && this._createNewBuffer(), this._bufferData[s + o * 4 + a] = t[l]), a++, a === r.strideSize) { for (; a < 4; a++)this._bufferData[s + o * 4 + a] = 0; a = 0, o++ } this._needSync = this._needSync || n } } _cacheMatrix(e, t) { this._checkNewFrame(); const i = this._valueCache[e], s = t.updateFlag; return i !== void 0 && i === s ? !1 : (this._valueCache[e] = s, !0) } _updateMatrix3x3ForUniform(e, t) { for (let i = 0; i < 3; i++)U._TempBuffer[i * 4] = t[i * 3], U._TempBuffer[i * 4 + 1] = t[i * 3 + 1], U._TempBuffer[i * 4 + 2] = t[i * 3 + 2], U._TempBuffer[i * 4 + 3] = 0; this.updateUniform(e, U._TempBuffer, 12) } _updateMatrix3x3ForEffect(e, t) { this._currentEffect.setMatrix3x3(e, t) } _updateMatrix2x2ForEffect(e, t) { this._currentEffect.setMatrix2x2(e, t) } _updateMatrix2x2ForUniform(e, t) { for (let i = 0; i < 2; i++)U._TempBuffer[i * 4] = t[i * 2], U._TempBuffer[i * 4 + 1] = t[i * 2 + 1], U._TempBuffer[i * 4 + 2] = 0, U._TempBuffer[i * 4 + 3] = 0; this.updateUniform(e, U._TempBuffer, 8) } _updateFloatForEffect(e, t) { this._currentEffect.setFloat(e, t) } _updateFloatForUniform(e, t) { U._TempBuffer[0] = t, this.updateUniform(e, U._TempBuffer, 1) } _updateFloat2ForEffect(e, t, i, s = "") { this._currentEffect.setFloat2(e + s, t, i) } _updateFloat2ForUniform(e, t, i) { U._TempBuffer[0] = t, U._TempBuffer[1] = i, this.updateUniform(e, U._TempBuffer, 2) } _updateFloat3ForEffect(e, t, i, s, r = "") { this._currentEffect.setFloat3(e + r, t, i, s) } _updateFloat3ForUniform(e, t, i, s) { U._TempBuffer[0] = t, U._TempBuffer[1] = i, U._TempBuffer[2] = s, this.updateUniform(e, U._TempBuffer, 3) } _updateFloat4ForEffect(e, t, i, s, r, n = "") { this._currentEffect.setFloat4(e + n, t, i, s, r) } _updateFloat4ForUniform(e, t, i, s, r) { U._TempBuffer[0] = t, U._TempBuffer[1] = i, U._TempBuffer[2] = s, U._TempBuffer[3] = r, this.updateUniform(e, U._TempBuffer, 4) } _updateFloatArrayForEffect(e, t) { this._currentEffect.setFloatArray(e, t) } _updateFloatArrayForUniform(e, t) { this.updateUniformArray(e, t, t.length) } _updateArrayForEffect(e, t) { this._currentEffect.setArray(e, t) } _updateArrayForUniform(e, t) { this.updateUniformArray(e, t, t.length) } _updateIntArrayForEffect(e, t) { this._currentEffect.setIntArray(e, t) } _updateIntArrayForUniform(e, t) { U._TempBufferInt32View.set(t), this.updateUniformArray(e, U._TempBuffer, t.length) } _updateUIntArrayForEffect(e, t) { this._currentEffect.setUIntArray(e, t) } _updateUIntArrayForUniform(e, t) { U._TempBufferUInt32View.set(t), this.updateUniformArray(e, U._TempBuffer, t.length) } _updateMatrixForEffect(e, t) { this._currentEffect.setMatrix(e, t) } _updateMatrixForUniform(e, t) { this._cacheMatrix(e, t) && this.updateUniform(e, t.toArray(), 16) } _updateMatricesForEffect(e, t) { this._currentEffect.setMatrices(e, t) } _updateMatricesForUniform(e, t) { this.updateUniform(e, t, t.length) } _updateVector3ForEffect(e, t) { this._currentEffect.setVector3(e, t) } _updateVector3ForUniform(e, t) { U._TempBuffer[0] = t.x, U._TempBuffer[1] = t.y, U._TempBuffer[2] = t.z, this.updateUniform(e, U._TempBuffer, 3) } _updateVector4ForEffect(e, t) { this._currentEffect.setVector4(e, t) } _updateVector4ForUniform(e, t) { U._TempBuffer[0] = t.x, U._TempBuffer[1] = t.y, U._TempBuffer[2] = t.z, U._TempBuffer[3] = t.w, this.updateUniform(e, U._TempBuffer, 4) } _updateColor3ForEffect(e, t, i = "") { this._currentEffect.setColor3(e + i, t) } _updateColor3ForUniform(e, t) { U._TempBuffer[0] = t.r, U._TempBuffer[1] = t.g, U._TempBuffer[2] = t.b, this.updateUniform(e, U._TempBuffer, 3) } _updateColor4ForEffect(e, t, i, s = "") { this._currentEffect.setColor4(e + s, t, i) } _updateDirectColor4ForEffect(e, t, i = "") { this._currentEffect.setDirectColor4(e + i, t) } _updateColor4ForUniform(e, t, i) { U._TempBuffer[0] = t.r, U._TempBuffer[1] = t.g, U._TempBuffer[2] = t.b, U._TempBuffer[3] = i, this.updateUniform(e, U._TempBuffer, 4) } _updateDirectColor4ForUniform(e, t) { U._TempBuffer[0] = t.r, U._TempBuffer[1] = t.g, U._TempBuffer[2] = t.b, U._TempBuffer[3] = t.a, this.updateUniform(e, U._TempBuffer, 4) } _updateIntForEffect(e, t, i = "") { this._currentEffect.setInt(e + i, t) } _updateIntForUniform(e, t) { U._TempBufferInt32View[0] = t, this.updateUniform(e, U._TempBuffer, 1) } _updateInt2ForEffect(e, t, i, s = "") { this._currentEffect.setInt2(e + s, t, i) } _updateInt2ForUniform(e, t, i) { U._TempBufferInt32View[0] = t, U._TempBufferInt32View[1] = i, this.updateUniform(e, U._TempBuffer, 2) } _updateInt3ForEffect(e, t, i, s, r = "") { this._currentEffect.setInt3(e + r, t, i, s) } _updateInt3ForUniform(e, t, i, s) { U._TempBufferInt32View[0] = t, U._TempBufferInt32View[1] = i, U._TempBufferInt32View[2] = s, this.updateUniform(e, U._TempBuffer, 3) } _updateInt4ForEffect(e, t, i, s, r, n = "") { this._currentEffect.setInt4(e + n, t, i, s, r) } _updateInt4ForUniform(e, t, i, s, r) { U._TempBufferInt32View[0] = t, U._TempBufferInt32View[1] = i, U._TempBufferInt32View[2] = s, U._TempBufferInt32View[3] = r, this.updateUniform(e, U._TempBuffer, 4) } _updateUIntForEffect(e, t, i = "") { this._currentEffect.setUInt(e + i, t) } _updateUIntForUniform(e, t) { U._TempBufferUInt32View[0] = t, this.updateUniform(e, U._TempBuffer, 1) } _updateUInt2ForEffect(e, t, i, s = "") { this._currentEffect.setUInt2(e + s, t, i) } _updateUInt2ForUniform(e, t, i) { U._TempBufferUInt32View[0] = t, U._TempBufferUInt32View[1] = i, this.updateUniform(e, U._TempBuffer, 2) } _updateUInt3ForEffect(e, t, i, s, r = "") { this._currentEffect.setUInt3(e + r, t, i, s) } _updateUInt3ForUniform(e, t, i, s) { U._TempBufferUInt32View[0] = t, U._TempBufferUInt32View[1] = i, U._TempBufferUInt32View[2] = s, this.updateUniform(e, U._TempBuffer, 3) } _updateUInt4ForEffect(e, t, i, s, r, n = "") { this._currentEffect.setUInt4(e + n, t, i, s, r) } _updateUInt4ForUniform(e, t, i, s, r) { U._TempBufferUInt32View[0] = t, U._TempBufferUInt32View[1] = i, U._TempBufferUInt32View[2] = s, U._TempBufferUInt32View[3] = r, this.updateUniform(e, U._TempBuffer, 4) } setTexture(e, t) { this._currentEffect.setTexture(e, t) } bindTexture(e, t) { this._currentEffect._bindTexture(e, t) } updateUniformDirectly(e, t) { this.updateUniform(e, t, t.length), this.update() } bindToEffect(e, t) { this._currentEffect = e, this._currentEffectName = t } bindUniformBuffer() { !this._noUBO && this._buffer && this._currentEffect && this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName) } unbindEffect() { this._currentEffect = void 0, this._currentEffectName = void 0 } setDataBuffer(e) { if (!this._buffers) return this._buffer === e; for (let t = 0; t < this._buffers.length; ++t)if (this._buffers[t][0] === e) return this._bufferIndex = t, this._buffer = e, this._createBufferOnWrite = !1, this._currentEffect = void 0, !0; return !1 } dispose() { if (this._noUBO) return; const e = this._engine._uniformBuffers, t = e.indexOf(this); if (t !== -1 && (e[t] = e[e.length - 1], e.pop()), this._engine._features.trackUbosInFrame && this._buffers) for (let i = 0; i < this._buffers.length; ++i) { const s = this._buffers[i][0]; this._engine._releaseBuffer(s) } else this._buffer && this._engine._releaseBuffer(this._buffer) && (this._buffer = null) } } U._UpdatedUbosInFrame = {}, U._MAX_UNIFORM_SIZE = 256, U._TempBuffer = new Float32Array(U._MAX_UNIFORM_SIZE), U._TempBufferInt32View = new Int32Array(U._TempBuffer.buffer), U._TempBufferUInt32View = new Uint32Array(U._TempBuffer.buffer); class Ai { get isDisposed() { return this._isDisposed } constructor(e, t, i, s = 0, r = !1, n = !1, a = !1, o, l) { this._isAlreadyOwned = !1, this._isDisposed = !1, e && e.getScene ? this._engine = e.getScene().getEngine() : this._engine = e, this._updatable = i, this._instanced = n, this._divisor = o || 1, this._label = l, t instanceof ti ? (this._data = null, this._buffer = t) : (this._data = t, this._buffer = null), this.byteStride = a ? s : s * Float32Array.BYTES_PER_ELEMENT, r || this.create() } createVertexBuffer(e, t, i, s, r, n = !1, a) { const o = n ? t : t * Float32Array.BYTES_PER_ELEMENT, l = s ? n ? s : s * Float32Array.BYTES_PER_ELEMENT : this.byteStride; return new d(this._engine, this, e, this._updatable, !0, l, r === void 0 ? this._instanced : r, o, i, void 0, void 0, !0, this._divisor || a) } isUpdatable() { return this._updatable } getData() { return this._data } getBuffer() { return this._buffer } getStrideSize() { return this.byteStride / Float32Array.BYTES_PER_ELEMENT } create(e = null) { !e && this._buffer || (e = e || this._data, e && (this._buffer ? this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e), this._data = e) : this._updatable ? (this._buffer = this._engine.createDynamicVertexBuffer(e, this._label), this._data = e) : this._buffer = this._engine.createVertexBuffer(e, void 0, this._label))) } _rebuild() { this._buffer = null, this.create(this._data) } update(e) { this.create(e) } updateDirectly(e, t, i, s = !1) { this._buffer && this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e, s ? t : t * Float32Array.BYTES_PER_ELEMENT, i ? i * this.byteStride : void 0), t === 0 && i === void 0 ? this._data = e : this._data = null) } _increaseReferences() { if (this._buffer) { if (!this._isAlreadyOwned) { this._isAlreadyOwned = !0; return } this._buffer.references++ } } dispose() { this._buffer && this._engine._releaseBuffer(this._buffer) && (this._isDisposed = !0, this._data = null, this._buffer = null) } } class d { get isDisposed() { return this._isDisposed } get instanceDivisor() { return this._instanceDivisor } set instanceDivisor(e) { const t = e != 0; this._instanceDivisor = e, t !== this._instanced && (this._instanced = t, this._computeHashCode()) } get totalVertices() { const e = this.getData(); return e ? Array.isArray(e) ? e.length / (this.byteStride / 4) - this.byteOffset / 4 : (e.byteLength - this.byteOffset) / this.byteStride : 0 } constructor(e, t, i, s, r, n, a, o, l, h, u = !1, f = !1, _ = 1, p = !1) { var v, E, m, x, C; this._isDisposed = !1; let S = !1; if (this.engine = e, typeof s == "object" && s !== null ? (S = (v = s.updatable) !== null && v !== void 0 ? v : !1, r = s.postponeInternalCreation, n = s.stride, a = s.instanced, o = s.offset, l = s.size, h = s.type, u = (E = s.normalized) !== null && E !== void 0 ? E : !1, f = (m = s.useBytes) !== null && m !== void 0 ? m : !1, _ = (x = s.divisor) !== null && x !== void 0 ? x : 1, p = (C = s.takeBufferOwnership) !== null && C !== void 0 ? C : !1, this._label = s.label) : S = !!s, t instanceof Ai ? (this._buffer = t, this._ownsBuffer = p) : (this._buffer = new Ai(e, t, S, n, r, a, f, _, this._label), this._ownsBuffer = !0), this.uniqueId = d._Counter++, this._kind = i, h === void 0) { const b = this.getData(); this.type = b ? d.GetDataType(b) : d.FLOAT } else this.type = h; const y = d.GetTypeByteLength(this.type); f ? (this._size = l || (n ? n / y : d.DeduceStride(i)), this.byteStride = n || this._buffer.byteStride || this._size * y, this.byteOffset = o || 0) : (this._size = l || n || d.DeduceStride(i), this.byteStride = n ? n * y : this._buffer.byteStride || this._size * y, this.byteOffset = (o || 0) * y), this.normalized = u, this._instanced = a !== void 0 ? a : !1, this._instanceDivisor = a ? _ : 0, this._alignBuffer(), this._computeHashCode() } _computeHashCode() { this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12) } _rebuild() { var e; (e = this._buffer) === null || e === void 0 || e._rebuild() } getKind() { return this._kind } isUpdatable() { return this._buffer.isUpdatable() } getData() { return this._buffer.getData() } getFloatData(e, t) { const i = this.getData(); return i ? (e = e ?? this.totalVertices, d.GetFloatData(i, this._size, this.type, this.byteOffset, this.byteStride, this.normalized, e, t)) : null } getBuffer() { return this._buffer.getBuffer() } getStrideSize() { return this.byteStride / d.GetTypeByteLength(this.type) } getOffset() { return this.byteOffset / d.GetTypeByteLength(this.type) } getSize(e = !1) { return e ? this._size * d.GetTypeByteLength(this.type) : this._size } getIsInstanced() { return this._instanced } getInstanceDivisor() { return this._instanceDivisor } create(e) { this._buffer.create(e), this._alignBuffer() } update(e) { this._buffer.update(e), this._alignBuffer() } updateDirectly(e, t, i = !1) { this._buffer.updateDirectly(e, t, void 0, i), this._alignBuffer() } dispose() { this._ownsBuffer && this._buffer.dispose(), this._isDisposed = !0 } forEach(e, t) { d.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, e, this.normalized, t) } _alignBuffer() { } static DeduceStride(e) { switch (e) { case d.UVKind: case d.UV2Kind: case d.UV3Kind: case d.UV4Kind: case d.UV5Kind: case d.UV6Kind: return 2; case d.NormalKind: case d.PositionKind: return 3; case d.ColorKind: case d.ColorInstanceKind: case d.MatricesIndicesKind: case d.MatricesIndicesExtraKind: case d.MatricesWeightsKind: case d.MatricesWeightsExtraKind: case d.TangentKind: return 4; default: throw new Error("Invalid kind '" + e + "'") } } static GetDataType(e) { return e instanceof Int8Array ? d.BYTE : e instanceof Uint8Array ? d.UNSIGNED_BYTE : e instanceof Int16Array ? d.SHORT : e instanceof Uint16Array ? d.UNSIGNED_SHORT : e instanceof Int32Array ? d.INT : e instanceof Uint32Array ? d.UNSIGNED_INT : d.FLOAT } static GetTypeByteLength(e) { switch (e) { case d.BYTE: case d.UNSIGNED_BYTE: return 1; case d.SHORT: case d.UNSIGNED_SHORT: return 2; case d.INT: case d.UNSIGNED_INT: case d.FLOAT: return 4; default: throw new Error(`Invalid type '${e}'`) } } static ForEach(e, t, i, s, r, n, a, o) { if (e instanceof Array) { let l = t / 4; const h = i / 4; for (let u = 0; u < n; u += s) { for (let f = 0; f < s; f++)o(e[l + f], u + f); l += h } } else { const l = e instanceof ArrayBuffer ? new DataView(e) : new DataView(e.buffer, e.byteOffset, e.byteLength), h = d.GetTypeByteLength(r); for (let u = 0; u < n; u += s) { let f = t; for (let _ = 0; _ < s; _++) { const p = d._GetFloatValue(l, r, f, a); o(p, u + _), f += h } t += i } } } static _GetFloatValue(e, t, i, s) { switch (t) { case d.BYTE: { let r = e.getInt8(i); return s && (r = Math.max(r / 127, -1)), r } case d.UNSIGNED_BYTE: { let r = e.getUint8(i); return s && (r = r / 255), r } case d.SHORT: { let r = e.getInt16(i, !0); return s && (r = Math.max(r / 32767, -1)), r } case d.UNSIGNED_SHORT: { let r = e.getUint16(i, !0); return s && (r = r / 65535), r } case d.INT: return e.getInt32(i, !0); case d.UNSIGNED_INT: return e.getUint32(i, !0); case d.FLOAT: return e.getFloat32(i, !0); default: throw new Error(`Invalid component type ${t}`) } } static GetFloatData(e, t, i, s, r, n, a, o) { const l = t * d.GetTypeByteLength(i), h = a * t; if (i !== d.FLOAT || r !== l) { const u = new Float32Array(h); return d.ForEach(e, s, r, t, i, h, n, (f, _) => u[_] = f), u } if (!(e instanceof Array || e instanceof Float32Array) || s !== 0 || e.length !== h) if (e instanceof Array) { const u = s / 4; return e.slice(u, u + h) } else { if (e instanceof ArrayBuffer) return new Float32Array(e, s, h); { let u = e.byteOffset + s; if (o) { const _ = new Float32Array(h), p = new Float32Array(e.buffer, u, h); return _.set(p), _ } const f = u % 4; return f && (u = Math.max(0, u - f)), new Float32Array(e.buffer, u, h) } } return o ? e.slice() : e } } d._Counter = 0, d.BYTE = 5120, d.UNSIGNED_BYTE = 5121, d.SHORT = 5122, d.UNSIGNED_SHORT = 5123, d.INT = 5124, d.UNSIGNED_INT = 5125, d.FLOAT = 5126, d.PositionKind = "position", d.NormalKind = "normal", d.TangentKind = "tangent", d.UVKind = "uv", d.UV2Kind = "uv2", d.UV3Kind = "uv3", d.UV4Kind = "uv4", d.UV5Kind = "uv5", d.UV6Kind = "uv6", d.ColorKind = "color", d.ColorInstanceKind = "instanceColor", d.MatricesIndicesKind = "matricesIndices", d.MatricesWeightsKind = "matricesWeights", d.MatricesIndicesExtraKind = "matricesIndicesExtra", d.MatricesWeightsExtraKind = "matricesWeightsExtra"; class ai { constructor() { this.hit = !1, this.distance = 0, this.pickedPoint = null, this.pickedMesh = null, this.bu = 0, this.bv = 0, this.faceId = -1, this.subMeshFaceId = -1, this.subMeshId = 0, this.pickedSprite = null, this.thinInstanceIndex = -1, this.ray = null, this.originMesh = null, this.aimTransform = null, this.gripTransform = null } getNormal(e = !1, t = !0) { if (!this.pickedMesh || t && !this.pickedMesh.isVerticesDataPresent(d.NormalKind)) return null; let i = this.pickedMesh.getIndices(); (i == null ? void 0 : i.length) === 0 && (i = null); let s; const r = D.Vector3[0], n = D.Vector3[1], a = D.Vector3[2]; if (t) { const l = this.pickedMesh.getVerticesData(d.NormalKind); let h = i ? g.FromArrayToRef(l, i[this.faceId * 3] * 3, r) : r.copyFromFloats(l[this.faceId * 3 * 3], l[this.faceId * 3 * 3 + 1], l[this.faceId * 3 * 3 + 2]), u = i ? g.FromArrayToRef(l, i[this.faceId * 3 + 1] * 3, n) : n.copyFromFloats(l[(this.faceId * 3 + 1) * 3], l[(this.faceId * 3 + 1) * 3 + 1], l[(this.faceId * 3 + 1) * 3 + 2]), f = i ? g.FromArrayToRef(l, i[this.faceId * 3 + 2] * 3, a) : a.copyFromFloats(l[(this.faceId * 3 + 2) * 3], l[(this.faceId * 3 + 2) * 3 + 1], l[(this.faceId * 3 + 2) * 3 + 2]); h = h.scale(this.bu), u = u.scale(this.bv), f = f.scale(1 - this.bu - this.bv), s = new g(h.x + u.x + f.x, h.y + u.y + f.y, h.z + u.z + f.z) } else { const l = this.pickedMesh.getVerticesData(d.PositionKind), h = i ? g.FromArrayToRef(l, i[this.faceId * 3] * 3, r) : r.copyFromFloats(l[this.faceId * 3 * 3], l[this.faceId * 3 * 3 + 1], l[this.faceId * 3 * 3 + 2]), u = i ? g.FromArrayToRef(l, i[this.faceId * 3 + 1] * 3, n) : n.copyFromFloats(l[(this.faceId * 3 + 1) * 3], l[(this.faceId * 3 + 1) * 3 + 1], l[(this.faceId * 3 + 1) * 3 + 2]), f = i ? g.FromArrayToRef(l, i[this.faceId * 3 + 2] * 3, a) : a.copyFromFloats(l[(this.faceId * 3 + 2) * 3], l[(this.faceId * 3 + 2) * 3 + 1], l[(this.faceId * 3 + 2) * 3 + 2]), _ = h.subtract(u), p = f.subtract(u); s = g.Cross(_, p) } const o = (l, h) => { let u = l.getWorldMatrix(); l.nonUniformScaling && (D.Matrix[0].copyFrom(u), u = D.Matrix[0], u.setTranslationFromFloats(0, 0, 0), u.invert(), u.transposeToRef(D.Matrix[1]), u = D.Matrix[1]), g.TransformNormalToRef(h, u, h) }; if (e && o(this.pickedMesh, s), this.ray) { const l = D.Vector3[0].copyFrom(s); e || o(this.pickedMesh, l), g.Dot(l, this.ray.direction) > 0 && s.negateInPlace() } return s.normalize(), s } getTextureCoordinates(e = d.UVKind) { if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(e)) return null; const t = this.pickedMesh.getIndices(); if (!t) return null; const i = this.pickedMesh.getVerticesData(e); if (!i) return null; let s = ge.FromArray(i, t[this.faceId * 3] * 2), r = ge.FromArray(i, t[this.faceId * 3 + 1] * 2), n = ge.FromArray(i, t[this.faceId * 3 + 2] * 2); return s = s.scale(this.bu), r = r.scale(this.bv), n = n.scale(1 - this.bu - this.bv), new ge(s.x + r.x + n.x, s.y + r.y + n.y) } } class De { constructor(e, t, i, s, r, n) { this.source = e, this.pointerX = t, this.pointerY = i, this.meshUnderPointer = s, this.sourceEvent = r, this.additionalData = n } static CreateNew(e, t, i) { const s = e.getScene(); return new De(e, s.pointerX, s.pointerY, s.meshUnderPointer || e, t, i) } static CreateNewFromSprite(e, t, i, s) { return new De(e, t.pointerX, t.pointerY, t.meshUnderPointer, i, s) } static CreateNewFromScene(e, t) { return new De(null, e.pointerX, e.pointerY, e.meshUnderPointer, t) } static CreateNewFromPrimitive(e, t, i, s) { return new De(e, t.x, t.y, null, i, s) } } class Is { constructor(e) { this._vertexBuffers = {}, this._scene = e } _prepareBuffers() { if (this._vertexBuffers[d.PositionKind]) return; const e = []; e.push(1, 1), e.push(-1, 1), e.push(-1, -1), e.push(1, -1), this._vertexBuffers[d.PositionKind] = new d(this._scene.getEngine(), e, d.PositionKind, !1, !1, 2), this._buildIndexBuffer() } _buildIndexBuffer() { const e = []; e.push(0), e.push(1), e.push(2), e.push(0), e.push(2), e.push(3), this._indexBuffer = this._scene.getEngine().createIndexBuffer(e) } _rebuild() { const e = this._vertexBuffers[d.PositionKind]; e && (e._rebuild(), this._buildIndexBuffer()) } _prepareFrame(e = null, t = null) { const i = this._scene.activeCamera; return !i || (t = t || i._postProcesses.filter(s => s != null), !t || t.length === 0 || !this._scene.postProcessesEnabled) ? !1 : (t[0].activate(i, e, t != null), !0) } directRender(e, t = null, i = !1, s = 0, r = 0, n = !1) { var a; const o = this._scene.getEngine(); for (let l = 0; l < e.length; l++) { l < e.length - 1 ? e[l + 1].activate(this._scene.activeCamera, t == null ? void 0 : t.texture) : (t ? o.bindFramebuffer(t, s, void 0, void 0, i, r) : n || o.restoreDefaultFramebuffer(), (a = o._debugInsertMarker) === null || a === void 0 || a.call(o, `post process ${e[l].name} output`)); const h = e[l], u = h.apply(); u && (h.onBeforeRenderObservable.notifyObservers(u), this._prepareBuffers(), o.bindBuffers(this._vertexBuffers, this._indexBuffer, u), o.drawElementsType(0, 0, 6), h.onAfterRenderObservable.notifyObservers(u)) } o.setDepthBuffer(!0), o.setDepthWrite(!0) } _finalizeFrame(e, t, i, s, r = !1) { var n; const a = this._scene.activeCamera; if (!a || (s = s || a._postProcesses.filter(l => l != null), s.length === 0 || !this._scene.postProcessesEnabled)) return; const o = this._scene.getEngine(); for (let l = 0, h = s.length; l < h; l++) { const u = s[l]; if (l < h - 1 ? u._outputTexture = s[l + 1].activate(a, t == null ? void 0 : t.texture) : (t ? (o.bindFramebuffer(t, i, void 0, void 0, r), u._outputTexture = t) : (o.restoreDefaultFramebuffer(), u._outputTexture = null), (n = o._debugInsertMarker) === null || n === void 0 || n.call(o, `post process ${s[l].name} output`)), e) break; const f = u.apply(); f && (u.onBeforeRenderObservable.notifyObservers(f), this._prepareBuffers(), o.bindBuffers(this._vertexBuffers, this._indexBuffer, f), o.drawElementsType(0, 0, 6), u.onAfterRenderObservable.notifyObservers(f)) } o.setDepthBuffer(!0), o.setDepthWrite(!0), o.setAlphaMode(0) } dispose() { const e = this._vertexBuffers[d.PositionKind]; e && (e.dispose(), this._vertexBuffers[d.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null) } } class qr { } class Be { get maintainStateBetweenFrames() { return this._maintainStateBetweenFrames } set maintainStateBetweenFrames(e) { e !== this._maintainStateBetweenFrames && (this._maintainStateBetweenFrames = e, this._maintainStateBetweenFrames || this.restoreDispachedFlags()) } restoreDispachedFlags() { for (const e of this._scene.meshes) if (e.subMeshes) for (const t of e.subMeshes) t._wasDispatched = !1; if (this._scene.spriteManagers) for (const e of this._scene.spriteManagers) e._wasDispatched = !1; for (const e of this._scene.particleSystems) e._wasDispatched = !1 } constructor(e) { this._useSceneAutoClearSetup = !1, this._renderingGroups = new Array, this._autoClearDepthStencil = {}, this._customOpaqueSortCompareFn = {}, this._customAlphaTestSortCompareFn = {}, this._customTransparentSortCompareFn = {}, this._renderingGroupInfo = new qr, this._maintainStateBetweenFrames = !1, this._scene = e; for (let t = Be.MIN_RENDERINGGROUPS; t < Be.MAX_RENDERINGGROUPS; t++)this._autoClearDepthStencil[t] = { autoClear: !0, depth: !0, stencil: !0 } } getRenderingGroup(e) { const t = e || 0; return this._prepareRenderingGroup(t), this._renderingGroups[t] } _clearDepthStencilBuffer(e = !0, t = !0) { this._depthStencilBufferAlreadyCleaned || (this._scene.getEngine().clear(null, !1, e, t), this._depthStencilBufferAlreadyCleaned = !0) } render(e, t, i, s) { const r = this._renderingGroupInfo; if (r.scene = this._scene, r.camera = this._scene.activeCamera, this._scene.spriteManagers && s) for (let n = 0; n < this._scene.spriteManagers.length; n++) { const a = this._scene.spriteManagers[n]; this.dispatchSprites(a) } for (let n = Be.MIN_RENDERINGGROUPS; n < Be.MAX_RENDERINGGROUPS; n++) { this._depthStencilBufferAlreadyCleaned = n === Be.MIN_RENDERINGGROUPS; const a = this._renderingGroups[n]; if (!a || a._empty) continue; const o = Math.pow(2, n); if (r.renderingGroupId = n, this._scene.onBeforeRenderingGroupObservable.notifyObservers(r, o), Be.AUTOCLEAR) { const l = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(n) : this._autoClearDepthStencil[n]; l && l.autoClear && this._clearDepthStencilBuffer(l.depth, l.stencil) } for (const l of this._scene._beforeRenderingGroupDrawStage) l.action(n); a.render(e, s, i, t); for (const l of this._scene._afterRenderingGroupDrawStage) l.action(n); this._scene.onAfterRenderingGroupObservable.notifyObservers(r, o) } } reset() { if (!this.maintainStateBetweenFrames) for (let e = Be.MIN_RENDERINGGROUPS; e < Be.MAX_RENDERINGGROUPS; e++) { const t = this._renderingGroups[e]; t && t.prepare() } } resetSprites() { if (!this.maintainStateBetweenFrames) for (let e = Be.MIN_RENDERINGGROUPS; e < Be.MAX_RENDERINGGROUPS; e++) { const t = this._renderingGroups[e]; t && t.prepareSprites() } } dispose() { this.freeRenderingGroups(), this._renderingGroups.length = 0, this._renderingGroupInfo = null } freeRenderingGroups() { for (let e = Be.MIN_RENDERINGGROUPS; e < Be.MAX_RENDERINGGROUPS; e++) { const t = this._renderingGroups[e]; t && t.dispose() } } _prepareRenderingGroup(e) { this._renderingGroups[e] === void 0 && (this._renderingGroups[e] = new je(e, this._scene, this._customOpaqueSortCompareFn[e], this._customAlphaTestSortCompareFn[e], this._customTransparentSortCompareFn[e])) } dispatchSprites(e) { this.maintainStateBetweenFrames && e._wasDispatched || (e._wasDispatched = !0, this.getRenderingGroup(e.renderingGroupId).dispatchSprites(e)) } dispatchParticles(e) { this.maintainStateBetweenFrames && e._wasDispatched || (e._wasDispatched = !0, this.getRenderingGroup(e.renderingGroupId).dispatchParticles(e)) } dispatch(e, t, i) { t === void 0 && (t = e.getMesh()), !(this.maintainStateBetweenFrames && e._wasDispatched) && (e._wasDispatched = !0, this.getRenderingGroup(t.renderingGroupId).dispatch(e, t, i)) } setRenderingOrder(e, t = null, i = null, s = null) { if (this._customOpaqueSortCompareFn[e] = t, this._customAlphaTestSortCompareFn[e] = i, this._customTransparentSortCompareFn[e] = s, this._renderingGroups[e]) { const r = this._renderingGroups[e]; r.opaqueSortCompareFn = this._customOpaqueSortCompareFn[e], r.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[e], r.transparentSortCompareFn = this._customTransparentSortCompareFn[e] } } setRenderingAutoClearDepthStencil(e, t, i = !0, s = !0) { this._autoClearDepthStencil[e] = { autoClear: t, depth: i, stencil: s } } getAutoClearDepthStencilSetup(e) { return this._autoClearDepthStencil[e] } } Be.MAX_RENDERINGGROUPS = 4, Be.MIN_RENDERINGGROUPS = 0, Be.AUTOCLEAR = !0; class j { } j.NAME_EFFECTLAYER = "EffectLayer", j.NAME_LAYER = "Layer", j.NAME_LENSFLARESYSTEM = "LensFlareSystem", j.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer", j.NAME_PARTICLESYSTEM = "ParticleSystem", j.NAME_GAMEPAD = "Gamepad", j.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue", j.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer", j.NAME_PREPASSRENDERER = "PrePassRenderer", j.NAME_DEPTHRENDERER = "DepthRenderer", j.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer", j.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager", j.NAME_SPRITE = "Sprite", j.NAME_SUBSURFACE = "SubSurface", j.NAME_OUTLINERENDERER = "Outline", j.NAME_PROCEDURALTEXTURE = "ProceduralTexture", j.NAME_SHADOWGENERATOR = "ShadowGenerator", j.NAME_OCTREE = "Octree", j.NAME_PHYSICSENGINE = "PhysicsEngine", j.NAME_AUDIO = "Audio", j.NAME_FLUIDRENDERER = "FluidRenderer", j.STEP_ISREADYFORMESH_EFFECTLAYER = 0, j.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0, j.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0, j.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0, j.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1, j.STEP_BEFORECAMERADRAW_PREPASS = 0, j.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1, j.STEP_BEFORECAMERADRAW_LAYER = 2, j.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0, j.STEP_BEFORERENDERTARGETDRAW_LAYER = 1, j.STEP_BEFORERENDERINGMESH_PREPASS = 0, j.STEP_BEFORERENDERINGMESH_OUTLINE = 1, j.STEP_AFTERRENDERINGMESH_PREPASS = 0, j.STEP_AFTERRENDERINGMESH_OUTLINE = 1, j.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0, j.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1, j.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0, j.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1, j.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0, j.STEP_BEFORECLEAR_PREPASS = 1, j.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0, j.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0, j.STEP_AFTERRENDERTARGETDRAW_LAYER = 1, j.STEP_AFTERCAMERADRAW_PREPASS = 0, j.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1, j.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2, j.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3, j.STEP_AFTERCAMERADRAW_LAYER = 4, j.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5, j.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0, j.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0, j.STEP_AFTERRENDER_AUDIO = 0, j.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0, j.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1, j.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2, j.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3, j.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0, j.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1, j.STEP_POINTERMOVE_SPRITE = 0, j.STEP_POINTERDOWN_SPRITE = 0, j.STEP_POINTERUP_SPRITE = 0; class be extends Array { constructor(e) { super(...e) } static Create() { return Object.create(be.prototype) } registerStep(e, t, i) { let s = 0, r = Number.MAX_VALUE; for (; s < this.length && (r = this[s].index, !(e < r)); s++); this.splice(s, 0, { index: e, component: t, action: i.bind(t) }) } clear() { this.length = 0 } } class he { } he.POINTERDOWN = 1, he.POINTERUP = 2, he.POINTERMOVE = 4, he.POINTERWHEEL = 8, he.POINTERPICK = 16, he.POINTERTAP = 32, he.POINTERDOUBLETAP = 64; class Ps { constructor(e, t) { this.type = e, this.event = t } } class jr extends Ps { constructor(e, t, i, s) { super(e, t), this.ray = null, this.originalPickingInfo = null, this.skipOnPointerObservable = !1, this.localPosition = new ge(i, s) } } class gt extends Ps { get pickInfo() { return this._pickInfo || this._generatePickInfo(), this._pickInfo } constructor(e, t, i, s = null) { super(e, t), this._pickInfo = i, this._inputManager = s } _generatePickInfo() { this._inputManager && (this._pickInfo = this._inputManager._pickMove(this.event), this._inputManager._setRayOnPointerInfo(this._pickInfo, this.event), this._inputManager = null) } } class $e { constructor() { this.hoverCursor = "", this.actions = [], this.isRecursive = !1 } static get HasTriggers() { for (const e in $e.Triggers) if (Object.prototype.hasOwnProperty.call($e.Triggers, e)) return !0; return !1 } static get HasPickTriggers() { for (const e in $e.Triggers) if (Object.prototype.hasOwnProperty.call($e.Triggers, e)) { const t = parseInt(e); if (t >= 1 && t <= 7) return !0 } return !1 } static HasSpecificTrigger(e) { for (const t in $e.Triggers) if (Object.prototype.hasOwnProperty.call($e.Triggers, t) && parseInt(t) === e) return !0; return !1 } } $e.Triggers = {}; class Si { } Si.KEYDOWN = 1, Si.KEYUP = 2; class Hi { constructor(e, t) { this.type = e, this.event = t } } class Ds extends Hi { get skipOnPointerObservable() { return this.skipOnKeyboardObservable } set skipOnPointerObservable(e) { this.skipOnKeyboardObservable = e } constructor(e, t) { super(e, t), this.type = e, this.event = t, this.skipOnKeyboardObservable = !1 } } var W; (function (c) { c[c.Generic = 0] = "Generic", c[c.Keyboard = 1] = "Keyboard", c[c.Mouse = 2] = "Mouse", c[c.Touch = 3] = "Touch", c[c.DualShock = 4] = "DualShock", c[c.Xbox = 5] = "Xbox", c[c.Switch = 6] = "Switch", c[c.DualSense = 7] = "DualSense" })(W || (W = {})); var z; (function (c) { c[c.Horizontal = 0] = "Horizontal", c[c.Vertical = 1] = "Vertical", c[c.LeftClick = 2] = "LeftClick", c[c.MiddleClick = 3] = "MiddleClick", c[c.RightClick = 4] = "RightClick", c[c.BrowserBack = 5] = "BrowserBack", c[c.BrowserForward = 6] = "BrowserForward", c[c.MouseWheelX = 7] = "MouseWheelX", c[c.MouseWheelY = 8] = "MouseWheelY", c[c.MouseWheelZ = 9] = "MouseWheelZ", c[c.Move = 12] = "Move" })(z || (z = {})); var Ri; (function (c) { c[c.Horizontal = 0] = "Horizontal", c[c.Vertical = 1] = "Vertical", c[c.LeftClick = 2] = "LeftClick", c[c.MiddleClick = 3] = "MiddleClick", c[c.RightClick = 4] = "RightClick", c[c.BrowserBack = 5] = "BrowserBack", c[c.BrowserForward = 6] = "BrowserForward", c[c.MouseWheelX = 7] = "MouseWheelX", c[c.MouseWheelY = 8] = "MouseWheelY", c[c.MouseWheelZ = 9] = "MouseWheelZ", c[c.DeltaHorizontal = 10] = "DeltaHorizontal", c[c.DeltaVertical = 11] = "DeltaVertical" })(Ri || (Ri = {})); var Fs; (function (c) { c[c.Cross = 0] = "Cross", c[c.Circle = 1] = "Circle", c[c.Square = 2] = "Square", c[c.Triangle = 3] = "Triangle", c[c.L1 = 4] = "L1", c[c.R1 = 5] = "R1", c[c.L2 = 6] = "L2", c[c.R2 = 7] = "R2", c[c.Share = 8] = "Share", c[c.Options = 9] = "Options", c[c.L3 = 10] = "L3", c[c.R3 = 11] = "R3", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.TouchPad = 17] = "TouchPad", c[c.LStickXAxis = 18] = "LStickXAxis", c[c.LStickYAxis = 19] = "LStickYAxis", c[c.RStickXAxis = 20] = "RStickXAxis", c[c.RStickYAxis = 21] = "RStickYAxis" })(Fs || (Fs = {})); var ws; (function (c) { c[c.Cross = 0] = "Cross", c[c.Circle = 1] = "Circle", c[c.Square = 2] = "Square", c[c.Triangle = 3] = "Triangle", c[c.L1 = 4] = "L1", c[c.R1 = 5] = "R1", c[c.L2 = 6] = "L2", c[c.R2 = 7] = "R2", c[c.Create = 8] = "Create", c[c.Options = 9] = "Options", c[c.L3 = 10] = "L3", c[c.R3 = 11] = "R3", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.TouchPad = 17] = "TouchPad", c[c.LStickXAxis = 18] = "LStickXAxis", c[c.LStickYAxis = 19] = "LStickYAxis", c[c.RStickXAxis = 20] = "RStickXAxis", c[c.RStickYAxis = 21] = "RStickYAxis" })(ws || (ws = {})); var Os; (function (c) { c[c.A = 0] = "A", c[c.B = 1] = "B", c[c.X = 2] = "X", c[c.Y = 3] = "Y", c[c.LB = 4] = "LB", c[c.RB = 5] = "RB", c[c.LT = 6] = "LT", c[c.RT = 7] = "RT", c[c.Back = 8] = "Back", c[c.Start = 9] = "Start", c[c.LS = 10] = "LS", c[c.RS = 11] = "RS", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.LStickXAxis = 17] = "LStickXAxis", c[c.LStickYAxis = 18] = "LStickYAxis", c[c.RStickXAxis = 19] = "RStickXAxis", c[c.RStickYAxis = 20] = "RStickYAxis" })(Os || (Os = {})); var Ls; (function (c) { c[c.B = 0] = "B", c[c.A = 1] = "A", c[c.Y = 2] = "Y", c[c.X = 3] = "X", c[c.L = 4] = "L", c[c.R = 5] = "R", c[c.ZL = 6] = "ZL", c[c.ZR = 7] = "ZR", c[c.Minus = 8] = "Minus", c[c.Plus = 9] = "Plus", c[c.LS = 10] = "LS", c[c.RS = 11] = "RS", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.Capture = 17] = "Capture", c[c.LStickXAxis = 18] = "LStickXAxis", c[c.LStickYAxis = 19] = "LStickYAxis", c[c.RStickXAxis = 20] = "RStickXAxis", c[c.RStickYAxis = 21] = "RStickYAxis" })(Ls || (Ls = {})); var Ns; (function (c) { c[c.PointerMove = 0] = "PointerMove", c[c.PointerDown = 1] = "PointerDown", c[c.PointerUp = 2] = "PointerUp" })(Ns || (Ns = {})); class yi { } yi.DOM_DELTA_PIXEL = 0, yi.DOM_DELTA_LINE = 1, yi.DOM_DELTA_PAGE = 2; class Lt { static CreateDeviceEvent(e, t, i, s, r, n, a) { switch (e) { case W.Keyboard: return this._CreateKeyboardEvent(i, s, r, n); case W.Mouse: if (i === z.MouseWheelX || i === z.MouseWheelY || i === z.MouseWheelZ) return this._CreateWheelEvent(e, t, i, s, r, n); case W.Touch: return this._CreatePointerEvent(e, t, i, s, r, n, a); default: throw `Unable to generate event for device ${W[e]}` } } static _CreatePointerEvent(e, t, i, s, r, n, a) { const o = this._CreateMouseEvent(e, t, i, s, r, n); e === W.Mouse ? (o.deviceType = W.Mouse, o.pointerId = 1, o.pointerType = "mouse") : (o.deviceType = W.Touch, o.pointerId = a ?? t, o.pointerType = "touch"); let l = 0; return l += r.pollInput(e, t, z.LeftClick), l += r.pollInput(e, t, z.RightClick) * 2, l += r.pollInput(e, t, z.MiddleClick) * 4, o.buttons = l, i === z.Move ? o.type = "pointermove" : i >= z.LeftClick && i <= z.RightClick && (o.type = s === 1 ? "pointerdown" : "pointerup", o.button = i - 2), o } static _CreateWheelEvent(e, t, i, s, r, n) { const a = this._CreateMouseEvent(e, t, i, s, r, n); switch (a.pointerId = 1, a.type = "wheel", a.deltaMode = yi.DOM_DELTA_PIXEL, a.deltaX = 0, a.deltaY = 0, a.deltaZ = 0, i) { case z.MouseWheelX: a.deltaX = s; break; case z.MouseWheelY: a.deltaY = s; break; case z.MouseWheelZ: a.deltaZ = s; break }return a } static _CreateMouseEvent(e, t, i, s, r, n) { const a = this._CreateEvent(n), o = r.pollInput(e, t, z.Horizontal), l = r.pollInput(e, t, z.Vertical); return n ? (a.movementX = 0, a.movementY = 0, a.offsetX = a.movementX - n.getBoundingClientRect().x, a.offsetY = a.movementY - n.getBoundingClientRect().y) : (a.movementX = r.pollInput(e, t, Ri.DeltaHorizontal), a.movementY = r.pollInput(e, t, Ri.DeltaVertical), a.offsetX = 0, a.offsetY = 0), this._CheckNonCharacterKeys(a, r), a.clientX = o, a.clientY = l, a.x = o, a.y = l, a.deviceType = e, a.deviceSlot = t, a.inputIndex = i, a } static _CreateKeyboardEvent(e, t, i, s) { const r = this._CreateEvent(s); return this._CheckNonCharacterKeys(r, i), r.deviceType = W.Keyboard, r.deviceSlot = 0, r.inputIndex = e, r.type = t === 1 ? "keydown" : "keyup", r.key = String.fromCharCode(e), r.keyCode = e, r } static _CheckNonCharacterKeys(e, t) { const i = t.isDeviceAvailable(W.Keyboard), s = i && t.pollInput(W.Keyboard, 0, 18) === 1, r = i && t.pollInput(W.Keyboard, 0, 17) === 1, n = i && (t.pollInput(W.Keyboard, 0, 91) === 1 || t.pollInput(W.Keyboard, 0, 92) === 1 || t.pollInput(W.Keyboard, 0, 93) === 1), a = i && t.pollInput(W.Keyboard, 0, 16) === 1; e.altKey = s, e.ctrlKey = r, e.metaKey = n, e.shiftKey = a } static _CreateEvent(e) { const t = {}; return t.preventDefault = () => { }, t.target = e, t } } class Zr { constructor(e, t, i) { this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(e, t, (s, r, n, a) => { const o = Lt.CreateDeviceEvent(s, r, n, a, this); i(s, r, o) }) : this._createDummyNativeInput() } pollInput(e, t, i) { return this._nativeInput.pollInput(e, t, i) } isDeviceAvailable(e) { return e === W.Mouse || e === W.Touch } dispose() { this._nativeInput.dispose() } _createDummyNativeInput() { return { pollInput: () => 0, isDeviceAvailable: () => !1, dispose: () => { } } } } const Bs = 255, Us = Object.keys(z).length / 2; class $r { constructor(e, t, i, s) { this._inputs = [], this._keyboardActive = !1, this._pointerActive = !1, this._usingSafari = G.IsSafari(), this._usingMacOS = $t() && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform), this._keyboardDownEvent = r => { }, this._keyboardUpEvent = r => { }, this._keyboardBlurEvent = r => { }, this._pointerMoveEvent = r => { }, this._pointerDownEvent = r => { }, this._pointerUpEvent = r => { }, this._pointerCancelEvent = r => { }, this._pointerWheelEvent = r => { }, this._pointerBlurEvent = r => { }, this._pointerMacOSChromeOutEvent = r => { }, this._eventsAttached = !1, this._mouseId = -1, this._isUsingFirefox = $t() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1, this._isUsingChromium = $t() && navigator.userAgent && navigator.userAgent.indexOf("Chrome") !== -1, this._maxTouchPoints = 0, this._pointerInputClearObserver = null, this._gamepadConnectedEvent = r => { }, this._gamepadDisconnectedEvent = r => { }, this._eventPrefix = G.GetPointerPrefix(e), this._engine = e, this._onDeviceConnected = t, this._onDeviceDisconnected = i, this._onInputChanged = s, this._mouseId = this._isUsingFirefox ? 0 : 1, this._enableEvents(), this._usingMacOS && (this._metaKeys = []), this._engine._onEngineViewChanged || (this._engine._onEngineViewChanged = () => { this._enableEvents() }) } pollInput(e, t, i) { const s = this._inputs[e][t]; if (!s) throw `Unable to find device ${W[e]}`; e >= W.DualShock && e <= W.DualSense && this._updateDevice(e, t, i); const r = s[i]; if (r === void 0) throw `Unable to find input ${i} for device ${W[e]} in slot ${t}`; return i === z.Move && G.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data."), r } isDeviceAvailable(e) { return this._inputs[e] !== void 0 } dispose() { this._onDeviceConnected = () => { }, this._onDeviceDisconnected = () => { }, this._onInputChanged = () => { }, delete this._engine._onEngineViewChanged, this._elementToAttachTo && this._disableEvents() } _enableEvents() { const e = this === null || this === void 0 ? void 0 : this._engine.getInputElement(); if (e && (!this._eventsAttached || this._elementToAttachTo !== e)) { if (this._disableEvents(), this._inputs) { for (const t of this._inputs) if (t) for (const i in t) { const s = +i, r = t[s]; if (r) for (let n = 0; n < r.length; n++)r[n] = 0 } } this._elementToAttachTo = e, this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex, this._handleKeyActions(), this._handlePointerActions(), this._handleGamepadActions(), this._eventsAttached = !0, this._checkForConnectedDevices() } } _disableEvents() { this._elementToAttachTo && (this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent), this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent), this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent), this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent), this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent), this._usingMacOS && this._isUsingChromium && this._elementToAttachTo.removeEventListener("lostpointercapture", this._pointerMacOSChromeOutEvent), window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent), window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent)), this._pointerInputClearObserver && this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver), this._eventsAttached = !1 } _checkForConnectedDevices() { if (navigator.getGamepads) { const e = navigator.getGamepads(); for (const t of e) t && this._addGamePad(t) } typeof matchMedia == "function" && matchMedia("(pointer:fine)").matches && this._addPointerDevice(W.Mouse, 0, 0, 0) } _addGamePad(e) { const t = this._getGamepadDeviceType(e.id), i = e.index; this._gamepads = this._gamepads || new Array(e.index + 1), this._registerDevice(t, i, e.buttons.length + e.axes.length), this._gamepads[i] = t } _addPointerDevice(e, t, i, s) { this._pointerActive || (this._pointerActive = !0), this._registerDevice(e, t, Us); const r = this._inputs[e][t]; r[0] = i, r[1] = s } _registerDevice(e, t, i) { if (t === void 0) throw `Unable to register device ${W[e]} to undefined slot.`; if (this._inputs[e] || (this._inputs[e] = {}), !this._inputs[e][t]) { const s = new Array(i); s.fill(0), this._inputs[e][t] = s, this._onDeviceConnected(e, t) } } _unregisterDevice(e, t) { this._inputs[e][t] && (delete this._inputs[e][t], this._onDeviceDisconnected(e, t)) } _handleKeyActions() { this._keyboardDownEvent = e => { this._keyboardActive || (this._keyboardActive = !0, this._registerDevice(W.Keyboard, 0, Bs)); const t = this._inputs[W.Keyboard][0]; if (t) { t[e.keyCode] = 1; const i = e; i.inputIndex = e.keyCode, this._usingMacOS && e.metaKey && e.key !== "Meta" && (this._metaKeys.includes(e.keyCode) || this._metaKeys.push(e.keyCode)), this._onInputChanged(W.Keyboard, 0, i) } }, this._keyboardUpEvent = e => { this._keyboardActive || (this._keyboardActive = !0, this._registerDevice(W.Keyboard, 0, Bs)); const t = this._inputs[W.Keyboard][0]; if (t) { t[e.keyCode] = 0; const i = e; if (i.inputIndex = e.keyCode, this._usingMacOS && e.key === "Meta" && this._metaKeys.length > 0) { for (const s of this._metaKeys) { const r = Lt.CreateDeviceEvent(W.Keyboard, 0, s, 0, this, this._elementToAttachTo); t[s] = 0, this._onInputChanged(W.Keyboard, 0, r) } this._metaKeys.splice(0, this._metaKeys.length) } this._onInputChanged(W.Keyboard, 0, i) } }, this._keyboardBlurEvent = () => { if (this._keyboardActive) { const e = this._inputs[W.Keyboard][0]; for (let t = 0; t < e.length; t++)if (e[t] !== 0) { e[t] = 0; const i = Lt.CreateDeviceEvent(W.Keyboard, 0, t, 0, this, this._elementToAttachTo); this._onInputChanged(W.Keyboard, 0, i) } this._usingMacOS && this._metaKeys.splice(0, this._metaKeys.length) } }, this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent), this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent), this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent) } _handlePointerActions() { this._maxTouchPoints = $t() && navigator.maxTouchPoints || 2, this._activeTouchIds || (this._activeTouchIds = new Array(this._maxTouchPoints)); for (let i = 0; i < this._maxTouchPoints; i++)this._activeTouchIds[i] = -1; this._pointerMoveEvent = i => { const s = this._getPointerType(i); let r = s === W.Mouse ? 0 : this._activeTouchIds.indexOf(i.pointerId); if (s === W.Touch && r === -1) { const a = this._activeTouchIds.indexOf(-1); if (a >= 0) r = a, this._activeTouchIds[a] = i.pointerId, this._onDeviceConnected(s, r); else { G.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`); return } } this._inputs[s] || (this._inputs[s] = {}), this._inputs[s][r] || this._addPointerDevice(s, r, i.clientX, i.clientY); const n = this._inputs[s][r]; if (n) { const a = i; a.inputIndex = z.Move, n[z.Horizontal] = i.clientX, n[z.Vertical] = i.clientY, s === W.Touch && n[z.LeftClick] === 0 && (n[z.LeftClick] = 1), i.pointerId === void 0 && (i.pointerId = this._mouseId), this._onInputChanged(s, r, a), !this._usingSafari && i.button !== -1 && (a.inputIndex = i.button + 2, n[i.button + 2] = n[i.button + 2] ? 0 : 1, this._onInputChanged(s, r, a)) } }, this._pointerDownEvent = i => { const s = this._getPointerType(i); let r = s === W.Mouse ? 0 : i.pointerId; if (s === W.Touch) { const a = this._activeTouchIds.indexOf(-1); if (a >= 0) r = a, this._activeTouchIds[a] = i.pointerId; else { G.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`); return } } this._inputs[s] || (this._inputs[s] = {}), this._inputs[s][r] ? s === W.Touch && this._onDeviceConnected(s, r) : this._addPointerDevice(s, r, i.clientX, i.clientY); const n = this._inputs[s][r]; if (n) { const a = n[z.Horizontal], o = n[z.Vertical]; if (s === W.Mouse) { if (i.pointerId === void 0 && (i.pointerId = this._mouseId), !document.pointerLockElement) try { this._elementToAttachTo.setPointerCapture(this._mouseId) } catch { } } else if (i.pointerId && !document.pointerLockElement) try { this._elementToAttachTo.setPointerCapture(i.pointerId) } catch { } n[z.Horizontal] = i.clientX, n[z.Vertical] = i.clientY, n[i.button + 2] = 1; const l = i; l.inputIndex = i.button + 2, this._onInputChanged(s, r, l), (a !== i.clientX || o !== i.clientY) && (l.inputIndex = z.Move, this._onInputChanged(s, r, l)) } }, this._pointerUpEvent = i => { var s, r, n, a, o; const l = this._getPointerType(i), h = l === W.Mouse ? 0 : this._activeTouchIds.indexOf(i.pointerId); if (l === W.Touch) { if (h === -1) return; this._activeTouchIds[h] = -1 } const u = (s = this._inputs[l]) === null || s === void 0 ? void 0 : s[h]; if (u && u[i.button + 2] !== 0) { const f = u[z.Horizontal], _ = u[z.Vertical]; u[z.Horizontal] = i.clientX, u[z.Vertical] = i.clientY, u[i.button + 2] = 0; const p = i; i.pointerId === void 0 && (i.pointerId = this._mouseId), (f !== i.clientX || _ !== i.clientY) && (p.inputIndex = z.Move, this._onInputChanged(l, h, p)), p.inputIndex = i.button + 2, l === W.Mouse && this._mouseId >= 0 && (!((n = (r = this._elementToAttachTo).hasPointerCapture) === null || n === void 0) && n.call(r, this._mouseId)) ? this._elementToAttachTo.releasePointerCapture(this._mouseId) : i.pointerId && (!((o = (a = this._elementToAttachTo).hasPointerCapture) === null || o === void 0) && o.call(a, i.pointerId)) && this._elementToAttachTo.releasePointerCapture(i.pointerId), this._onInputChanged(l, h, p), l === W.Touch && this._onDeviceDisconnected(l, h) } }, this._pointerCancelEvent = i => { var s, r, n, a; if (i.pointerType === "mouse") { const o = this._inputs[W.Mouse][0]; this._mouseId >= 0 && (!((r = (s = this._elementToAttachTo).hasPointerCapture) === null || r === void 0) && r.call(s, this._mouseId)) && this._elementToAttachTo.releasePointerCapture(this._mouseId); for (let l = z.LeftClick; l <= z.BrowserForward; l++)if (o[l] === 1) { o[l] = 0; const h = Lt.CreateDeviceEvent(W.Mouse, 0, l, 0, this, this._elementToAttachTo); this._onInputChanged(W.Mouse, 0, h) } } else { const o = this._activeTouchIds.indexOf(i.pointerId); if (o === -1) return; !((a = (n = this._elementToAttachTo).hasPointerCapture) === null || a === void 0) && a.call(n, i.pointerId) && this._elementToAttachTo.releasePointerCapture(i.pointerId), this._inputs[W.Touch][o][z.LeftClick] = 0; const l = Lt.CreateDeviceEvent(W.Touch, o, z.LeftClick, 0, this, this._elementToAttachTo, i.pointerId); this._onInputChanged(W.Touch, o, l), this._activeTouchIds[o] = -1, this._onDeviceDisconnected(W.Touch, o) } }, this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll"; let e = !1; const t = function () { }; try { const i = Object.defineProperty({}, "passive", { get: function () { e = !0 } }); this._elementToAttachTo.addEventListener("test", t, i), this._elementToAttachTo.removeEventListener("test", t, i) } catch { } this._pointerBlurEvent = () => { var i, s, r, n, a; if (this.isDeviceAvailable(W.Mouse)) { const o = this._inputs[W.Mouse][0]; this._mouseId >= 0 && (!((s = (i = this._elementToAttachTo).hasPointerCapture) === null || s === void 0) && s.call(i, this._mouseId)) && this._elementToAttachTo.releasePointerCapture(this._mouseId); for (let l = z.LeftClick; l <= z.BrowserForward; l++)if (o[l] === 1) { o[l] = 0; const h = Lt.CreateDeviceEvent(W.Mouse, 0, l, 0, this, this._elementToAttachTo); this._onInputChanged(W.Mouse, 0, h) } } if (this.isDeviceAvailable(W.Touch)) { const o = this._inputs[W.Touch]; for (let l = 0; l < this._activeTouchIds.length; l++) { const h = this._activeTouchIds[l]; if (!((n = (r = this._elementToAttachTo).hasPointerCapture) === null || n === void 0) && n.call(r, h) && this._elementToAttachTo.releasePointerCapture(h), h !== -1 && ((a = o[l]) === null || a === void 0 ? void 0 : a[z.LeftClick]) === 1) { o[l][z.LeftClick] = 0; const u = Lt.CreateDeviceEvent(W.Touch, l, z.LeftClick, 0, this, this._elementToAttachTo, h); this._onInputChanged(W.Touch, l, u), this._activeTouchIds[l] = -1, this._onDeviceDisconnected(W.Touch, l) } } } }, this._pointerWheelEvent = i => { const s = W.Mouse, r = 0; this._inputs[s] || (this._inputs[s] = []), this._inputs[s][r] || (this._pointerActive = !0, this._registerDevice(s, r, Us)); const n = this._inputs[s][r]; if (n) { n[z.MouseWheelX] = i.deltaX || 0, n[z.MouseWheelY] = i.deltaY || i.wheelDelta || 0, n[z.MouseWheelZ] = i.deltaZ || 0; const a = i; i.pointerId === void 0 && (i.pointerId = this._mouseId), n[z.MouseWheelX] !== 0 && (a.inputIndex = z.MouseWheelX, this._onInputChanged(s, r, a)), n[z.MouseWheelY] !== 0 && (a.inputIndex = z.MouseWheelY, this._onInputChanged(s, r, a)), n[z.MouseWheelZ] !== 0 && (a.inputIndex = z.MouseWheelZ, this._onInputChanged(s, r, a)) } }, this._usingMacOS && this._isUsingChromium && (this._pointerMacOSChromeOutEvent = i => { i.buttons > 1 && this._pointerCancelEvent(i) }, this._elementToAttachTo.addEventListener("lostpointercapture", this._pointerMacOSChromeOutEvent)), this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent), this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent), this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, e ? { passive: !1 } : !1), this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => { if (this.isDeviceAvailable(W.Mouse)) { const i = this._inputs[W.Mouse][0]; i[z.MouseWheelX] = 0, i[z.MouseWheelY] = 0, i[z.MouseWheelZ] = 0 } }) } _handleGamepadActions() { this._gamepadConnectedEvent = e => { this._addGamePad(e.gamepad) }, this._gamepadDisconnectedEvent = e => { if (this._gamepads) { const t = this._getGamepadDeviceType(e.gamepad.id), i = e.gamepad.index; this._unregisterDevice(t, i), delete this._gamepads[i] } }, window.addEventListener("gamepadconnected", this._gamepadConnectedEvent), window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent) } _updateDevice(e, t, i) { const s = navigator.getGamepads()[t]; if (s && e === this._gamepads[t]) { const r = this._inputs[e][t]; i >= s.buttons.length ? r[i] = s.axes[i - s.buttons.length].valueOf() : r[i] = s.buttons[i].value } } _getGamepadDeviceType(e) { return e.indexOf("054c") !== -1 ? e.indexOf("0ce6") !== -1 ? W.DualSense : W.DualShock : e.indexOf("Xbox One") !== -1 || e.search("Xbox 360") !== -1 || e.search("xinput") !== -1 ? W.Xbox : e.indexOf("057e") !== -1 ? W.Switch : W.Generic } _getPointerType(e) { let t = W.Mouse; return (e.pointerType === "touch" || e.pointerType === "pen" || e.touches) && (t = W.Touch), t } } class ks { constructor(e, t, i = 0) { this.deviceType = t, this.deviceSlot = i, this.onInputChangedObservable = new L, this._deviceInputSystem = e } getInput(e) { return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, e) } } class Qr { constructor(e) { this._registeredManagers = new Array, this._refCount = 0, this.registerManager = n => { for (let a = 0; a < this._devices.length; a++) { const o = this._devices[a]; for (const l in o) { const h = +l; n._addDevice(new ks(this._deviceInputSystem, a, h)) } } this._registeredManagers.push(n) }, this.unregisterManager = n => { const a = this._registeredManagers.indexOf(n); a > -1 && this._registeredManagers.splice(a, 1) }; const t = Object.keys(W).length / 2; this._devices = new Array(t); const i = (n, a) => { this._devices[n] || (this._devices[n] = new Array), this._devices[n][a] || (this._devices[n][a] = a); for (const o of this._registeredManagers) { const l = new ks(this._deviceInputSystem, n, a); o._addDevice(l) } }, s = (n, a) => { var o; !((o = this._devices[n]) === null || o === void 0) && o[a] && delete this._devices[n][a]; for (const l of this._registeredManagers) l._removeDevice(n, a) }, r = (n, a, o) => { if (o) for (const l of this._registeredManagers) l._onInputChanged(n, a, o) }; typeof _native < "u" ? this._deviceInputSystem = new Zr(i, s, r) : this._deviceInputSystem = new $r(e, i, s, r) } dispose() { this._deviceInputSystem.dispose() } } class Jr { getDeviceSource(e, t) { if (t === void 0) { if (this._firstDevice[e] === void 0) return null; t = this._firstDevice[e] } return !this._devices[e] || this._devices[e][t] === void 0 ? null : this._devices[e][t] } getDeviceSources(e) { return this._devices[e] ? this._devices[e].filter(t => !!t) : [] } constructor(e) { const t = Object.keys(W).length / 2; this._devices = new Array(t), this._firstDevice = new Array(t), this._engine = e, this._engine._deviceSourceManager || (this._engine._deviceSourceManager = new Qr(e)), this._engine._deviceSourceManager._refCount++, this.onDeviceConnectedObservable = new L(i => { for (const s of this._devices) if (s) for (const r of s) r && this.onDeviceConnectedObservable.notifyObserver(i, r) }), this.onDeviceDisconnectedObservable = new L, this._engine._deviceSourceManager.registerManager(this), this._onDisposeObserver = e.onDisposeObservable.add(() => { this.dispose() }) } dispose() { this.onDeviceConnectedObservable.clear(), this.onDeviceDisconnectedObservable.clear(), this._engine._deviceSourceManager && (this._engine._deviceSourceManager.unregisterManager(this), --this._engine._deviceSourceManager._refCount < 1 && (this._engine._deviceSourceManager.dispose(), delete this._engine._deviceSourceManager)), this._engine.onDisposeObservable.remove(this._onDisposeObserver) } _addDevice(e) { this._devices[e.deviceType] || (this._devices[e.deviceType] = new Array), this._devices[e.deviceType][e.deviceSlot] || (this._devices[e.deviceType][e.deviceSlot] = e, this._updateFirstDevices(e.deviceType)), this.onDeviceConnectedObservable.notifyObservers(e) } _removeDevice(e, t) { var i, s; const r = (i = this._devices[e]) === null || i === void 0 ? void 0 : i[t]; this.onDeviceDisconnectedObservable.notifyObservers(r), !((s = this._devices[e]) === null || s === void 0) && s[t] && delete this._devices[e][t], this._updateFirstDevices(e) } _onInputChanged(e, t, i) { var s, r; (r = (s = this._devices[e]) === null || s === void 0 ? void 0 : s[t]) === null || r === void 0 || r.onInputChangedObservable.notifyObservers(i) } _updateFirstDevices(e) { switch (e) { case W.Keyboard: case W.Mouse: this._firstDevice[e] = 0; break; case W.Touch: case W.DualSense: case W.DualShock: case W.Xbox: case W.Switch: case W.Generic: { delete this._firstDevice[e]; const t = this._devices[e]; if (t) { for (let i = 0; i < t.length; i++)if (t[i]) { this._firstDevice[e] = i; break } } break } } } } class Vs { constructor() { this._singleClick = !1, this._doubleClick = !1, this._hasSwiped = !1, this._ignore = !1 } get singleClick() { return this._singleClick } get doubleClick() { return this._doubleClick } get hasSwiped() { return this._hasSwiped } get ignore() { return this._ignore } set singleClick(e) { this._singleClick = e } set doubleClick(e) { this._doubleClick = e } set hasSwiped(e) { this._hasSwiped = e } set ignore(e) { this._ignore = e } } class Te { constructor(e) { this._alreadyAttached = !1, this._meshPickProceed = !1, this._currentPickResult = null, this._previousPickResult = null, this._totalPointersPressed = 0, this._doubleClickOccured = !1, this._isSwiping = !1, this._swipeButtonPressed = -1, this._skipPointerTap = !1, this._isMultiTouchGesture = !1, this._pointerX = 0, this._pointerY = 0, this._startingPointerPosition = new ge(0, 0), this._previousStartingPointerPosition = new ge(0, 0), this._startingPointerTime = 0, this._previousStartingPointerTime = 0, this._pointerCaptures = {}, this._meshUnderPointerId = {}, this._movePointerInfo = null, this._cameraObserverCount = 0, this._delayedClicks = [null, null, null, null, null], this._deviceSourceManager = null, this._scene = e || ce.LastCreatedScene, this._scene } get meshUnderPointer() { return this._movePointerInfo && (this._movePointerInfo._generatePickInfo(), this._movePointerInfo = null), this._pointerOverMesh } getMeshUnderPointerByPointerId(e) { return this._meshUnderPointerId[e] || null } get unTranslatedPointer() { return new ge(this._unTranslatedPointerX, this._unTranslatedPointerY) } get pointerX() { return this._pointerX } set pointerX(e) { this._pointerX = e } get pointerY() { return this._pointerY } set pointerY(e) { this._pointerY = e } _updatePointerPosition(e) { const t = this._scene.getEngine().getInputElementClientRect(); t && (this._pointerX = e.clientX - t.left, this._pointerY = e.clientY - t.top, this._unTranslatedPointerX = this._pointerX, this._unTranslatedPointerY = this._pointerY) } _processPointerMove(e, t) { const i = this._scene, s = i.getEngine(), r = s.getInputElement(); r && (r.tabIndex = s.canvasTabIndex, i.doNotHandleCursors || (r.style.cursor = i.defaultCursor)), this._setCursorAndPointerOverMesh(e, t, i); for (const o of i._pointerMoveStage) { e = e || this._pickMove(t); const l = !!(e != null && e.pickedMesh); e = o.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, l, r) } const n = t.inputIndex >= z.MouseWheelX && t.inputIndex <= z.MouseWheelZ ? he.POINTERWHEEL : he.POINTERMOVE; i.onPointerMove && (e = e || this._pickMove(t), i.onPointerMove(t, e, n)); let a; e ? (a = new gt(n, t, e), this._setRayOnPointerInfo(e, t)) : (a = new gt(n, t, null, this), this._movePointerInfo = a), i.onPointerObservable.hasObservers() && i.onPointerObservable.notifyObservers(a, n) } _setRayOnPointerInfo(e, t) { const i = this._scene; e && i._pickingAvailable && (e.ray || (e.ray = i.createPickingRay(t.offsetX, t.offsetY, A.Identity(), i.activeCamera))) } _addCameraPointerObserver(e, t) { return this._cameraObserverCount++, this._scene.onPointerObservable.add(e, t) } _removeCameraPointerObserver(e) { return this._cameraObserverCount--, this._scene.onPointerObservable.remove(e) } _checkForPicking() { return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick) } _checkPrePointerObservable(e, t, i) { const s = this._scene, r = new jr(i, t, this._unTranslatedPointerX, this._unTranslatedPointerY); return e && (r.originalPickingInfo = e, r.ray = e.ray, e.originMesh && (r.nearInteractionPickingInfo = e)), s.onPrePointerObservable.notifyObservers(r, i), !!r.skipOnPointerObservable } _pickMove(e) { const t = this._scene, i = t.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, t.pointerMovePredicate, t.pointerMoveFastCheck, t.cameraToUseForPointers, t.pointerMoveTrianglePredicate); return this._setCursorAndPointerOverMesh(i, e, t), i } _setCursorAndPointerOverMesh(e, t, i) { const r = i.getEngine().getInputElement(); if (e != null && e.pickedMesh) { if (this.setPointerOverMesh(e.pickedMesh, t.pointerId, e, t), !i.doNotHandleCursors && r && this._pointerOverMesh) { const n = this._pointerOverMesh._getActionManagerForTrigger(); n && n.hasPointerTriggers && (r.style.cursor = n.hoverCursor || i.hoverCursor) } } else this.setPointerOverMesh(null, t.pointerId, e, t) } simulatePointerMove(e, t) { const i = new PointerEvent("pointermove", t); i.inputIndex = z.Move, !this._checkPrePointerObservable(e, i, he.POINTERMOVE) && this._processPointerMove(e, i) } simulatePointerDown(e, t) { const i = new PointerEvent("pointerdown", t); i.inputIndex = i.button + 2, !this._checkPrePointerObservable(e, i, he.POINTERDOWN) && this._processPointerDown(e, i) } _processPointerDown(e, t) { const i = this._scene; if (e != null && e.pickedMesh) { this._pickedDownMesh = e.pickedMesh; const n = e.pickedMesh._getActionManagerForTrigger(); if (n) { if (n.hasPickTriggers) switch (n.processTrigger(5, De.CreateNew(e.pickedMesh, t, e)), t.button) { case 0: n.processTrigger(2, De.CreateNew(e.pickedMesh, t, e)); break; case 1: n.processTrigger(4, De.CreateNew(e.pickedMesh, t, e)); break; case 2: n.processTrigger(3, De.CreateNew(e.pickedMesh, t, e)); break }n.hasSpecificTrigger(8) && window.setTimeout(() => { const a = i.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, o => o.isPickable && o.isVisible && o.isReady() && o.actionManager && o.actionManager.hasSpecificTrigger(8) && o === this._pickedDownMesh, !1, i.cameraToUseForPointers); a != null && a.pickedMesh && n && this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > Te.LongPressDelay && !this._isPointerSwiping() && (this._startingPointerTime = 0, n.processTrigger(8, De.CreateNew(a.pickedMesh, t))) }, Te.LongPressDelay) } } else for (const n of i._pointerDownStage) e = n.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t, !1); let s; const r = he.POINTERDOWN; e ? (i.onPointerDown && i.onPointerDown(t, e, r), s = new gt(r, t, e), this._setRayOnPointerInfo(e, t)) : s = new gt(r, t, null, this), i.onPointerObservable.hasObservers() && i.onPointerObservable.notifyObservers(s, r) } _isPointerSwiping() { return this._isSwiping } simulatePointerUp(e, t, i) { const s = new PointerEvent("pointerup", t); s.inputIndex = z.Move; const r = new Vs; i ? r.doubleClick = !0 : r.singleClick = !0, !this._checkPrePointerObservable(e, s, he.POINTERUP) && this._processPointerUp(e, s, r) } _processPointerUp(e, t, i) { const s = this._scene; if (e != null && e.pickedMesh) { if (this._pickedUpMesh = e.pickedMesh, this._pickedDownMesh === this._pickedUpMesh && (s.onPointerPick && s.onPointerPick(t, e), i.singleClick && !i.ignore && s.onPointerObservable.observers.length > this._cameraObserverCount)) { const n = he.POINTERPICK, a = new gt(n, t, e); this._setRayOnPointerInfo(e, t), s.onPointerObservable.notifyObservers(a, n) } const r = e.pickedMesh._getActionManagerForTrigger(); if (r && !i.ignore) { r.processTrigger(7, De.CreateNew(e.pickedMesh, t, e)), !i.hasSwiped && i.singleClick && r.processTrigger(1, De.CreateNew(e.pickedMesh, t, e)); const n = e.pickedMesh._getActionManagerForTrigger(6); i.doubleClick && n && n.processTrigger(6, De.CreateNew(e.pickedMesh, t, e)) } } else if (!i.ignore) for (const r of s._pointerUpStage) e = r.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t, i.doubleClick); if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) { const r = this._pickedDownMesh._getActionManagerForTrigger(16); r && r.processTrigger(16, De.CreateNew(this._pickedDownMesh, t)) } if (!i.ignore) { const r = new gt(he.POINTERUP, t, e); if (this._setRayOnPointerInfo(e, t), s.onPointerObservable.notifyObservers(r, he.POINTERUP), s.onPointerUp && s.onPointerUp(t, e, he.POINTERUP), !i.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) { let n = 0; if (i.singleClick ? n = he.POINTERTAP : i.doubleClick && (n = he.POINTERDOUBLETAP), n) { const a = new gt(n, t, e); s.onPointerObservable.hasObservers() && s.onPointerObservable.hasSpecificMask(n) && s.onPointerObservable.notifyObservers(a, n) } } } } isPointerCaptured(e = 0) { return this._pointerCaptures[e] } attachControl(e = !0, t = !0, i = !0, s = null) { const r = this._scene, n = r.getEngine(); s || (s = n.getInputElement()), this._alreadyAttached && this.detachControl(), s && (this._alreadyAttachedTo = s), this._deviceSourceManager = new Jr(n), this._initActionManager = a => { if (!this._meshPickProceed) { const o = r.skipPointerUpPicking || r._registeredActions === 0 && !this._checkForPicking() && !r.onPointerUp ? null : r.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, r.pointerUpPredicate, r.pointerUpFastCheck, r.cameraToUseForPointers); this._currentPickResult = o, o && (a = o.hit && o.pickedMesh ? o.pickedMesh._getActionManagerForTrigger() : null), this._meshPickProceed = !0 } return a }, this._delayedSimpleClick = (a, o, l) => { if ((Date.now() - this._previousStartingPointerTime > Te.DoubleClickDelay && !this._doubleClickOccured || a !== this._previousButtonPressed) && (this._doubleClickOccured = !1, o.singleClick = !0, o.ignore = !1, this._delayedClicks[a])) { const h = this._delayedClicks[a].evt, u = he.POINTERTAP, f = new gt(u, h, this._currentPickResult); r.onPointerObservable.hasObservers() && r.onPointerObservable.hasSpecificMask(u) && r.onPointerObservable.notifyObservers(f, u), this._delayedClicks[a] = null } }, this._initClickEvent = (a, o, l, h) => { var u, f; const _ = new Vs; this._currentPickResult = null; let p = null, v = a.hasSpecificMask(he.POINTERPICK) || o.hasSpecificMask(he.POINTERPICK) || a.hasSpecificMask(he.POINTERTAP) || o.hasSpecificMask(he.POINTERTAP) || a.hasSpecificMask(he.POINTERDOUBLETAP) || o.hasSpecificMask(he.POINTERDOUBLETAP); !v && $e && (p = this._initActionManager(p, _), p && (v = p.hasPickTriggers)); let E = !1; if (v) { const m = l.button; if (_.hasSwiped = this._isPointerSwiping(), !_.hasSwiped) { let x = !Te.ExclusiveDoubleClickMode; if (x || (x = !a.hasSpecificMask(he.POINTERDOUBLETAP) && !o.hasSpecificMask(he.POINTERDOUBLETAP), x && !$e.HasSpecificTrigger(6) && (p = this._initActionManager(p, _), p && (x = !p.hasSpecificTrigger(6)))), x) (Date.now() - this._previousStartingPointerTime > Te.DoubleClickDelay || m !== this._previousButtonPressed) && (_.singleClick = !0, h(_, this._currentPickResult), E = !0); else { const S = { evt: l, clickInfo: _, timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, m, _, h), Te.DoubleClickDelay) }; this._delayedClicks[m] = S } let C = a.hasSpecificMask(he.POINTERDOUBLETAP) || o.hasSpecificMask(he.POINTERDOUBLETAP); !C && $e.HasSpecificTrigger(6) && (p = this._initActionManager(p, _), p && (C = p.hasSpecificTrigger(6))), C && (m === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < Te.DoubleClickDelay && !this._doubleClickOccured ? (!_.hasSwiped && !this._isPointerSwiping() ? (this._previousStartingPointerTime = 0, this._doubleClickOccured = !0, _.doubleClick = !0, _.ignore = !1, Te.ExclusiveDoubleClickMode && this._delayedClicks[m] && (clearTimeout((u = this._delayedClicks[m]) === null || u === void 0 ? void 0 : u.timeoutId), this._delayedClicks[m] = null), h(_, this._currentPickResult)) : (this._doubleClickOccured = !1, this._previousStartingPointerTime = this._startingPointerTime, this._previousStartingPointerPosition.x = this._startingPointerPosition.x, this._previousStartingPointerPosition.y = this._startingPointerPosition.y, this._previousButtonPressed = m, Te.ExclusiveDoubleClickMode ? (this._delayedClicks[m] && (clearTimeout((f = this._delayedClicks[m]) === null || f === void 0 ? void 0 : f.timeoutId), this._delayedClicks[m] = null), h(_, this._previousPickResult)) : h(_, this._currentPickResult)), E = !0) : (this._doubleClickOccured = !1, this._previousStartingPointerTime = this._startingPointerTime, this._previousStartingPointerPosition.x = this._startingPointerPosition.x, this._previousStartingPointerPosition.y = this._startingPointerPosition.y, this._previousButtonPressed = m)) } } E || h(_, this._currentPickResult) }, this._onPointerMove = a => { if (this._updatePointerPosition(a), !this._isSwiping && this._swipeButtonPressed !== -1 && (this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > Te.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > Te.DragMovementThreshold), n.isPointerLock && n._verifyPointerLock(), this._checkPrePointerObservable(null, a, a.inputIndex >= z.MouseWheelX && a.inputIndex <= z.MouseWheelZ ? he.POINTERWHEEL : he.POINTERMOVE) || !r.cameraToUseForPointers && !r.activeCamera) return; if (r.skipPointerMovePicking) { this._processPointerMove(new ai, a); return } r.pointerMovePredicate || (r.pointerMovePredicate = l => l.isPickable && l.isVisible && l.isReady() && l.isEnabled() && (l.enablePointerMoveEvents || r.constantlyUpdateMeshUnderPointer || l._getActionManagerForTrigger() !== null) && (!r.cameraToUseForPointers || (r.cameraToUseForPointers.layerMask & l.layerMask) !== 0)); const o = r._registeredActions > 0 || r.constantlyUpdateMeshUnderPointer ? this._pickMove(a) : null; this._processPointerMove(o, a) }, this._onPointerDown = a => { var o; if (this._totalPointersPressed++, this._pickedDownMesh = null, this._meshPickProceed = !1, Te.ExclusiveDoubleClickMode) { for (let h = 0; h < this._delayedClicks.length; h++)if (this._delayedClicks[h]) if (a.button === h) clearTimeout((o = this._delayedClicks[h]) === null || o === void 0 ? void 0 : o.timeoutId); else { const u = this._delayedClicks[h].clickInfo; this._doubleClickOccured = !1, u.singleClick = !0, u.ignore = !1; const f = this._delayedClicks[h].evt, _ = he.POINTERTAP, p = new gt(_, f, this._currentPickResult); r.onPointerObservable.hasObservers() && r.onPointerObservable.hasSpecificMask(_) && r.onPointerObservable.notifyObservers(p, _), this._delayedClicks[h] = null } } if (this._updatePointerPosition(a), this._swipeButtonPressed === -1 && (this._swipeButtonPressed = a.button), r.preventDefaultOnPointerDown && s && (a.preventDefault(), s.focus()), this._startingPointerPosition.x = this._pointerX, this._startingPointerPosition.y = this._pointerY, this._startingPointerTime = Date.now(), this._checkPrePointerObservable(null, a, he.POINTERDOWN) || !r.cameraToUseForPointers && !r.activeCamera) return; this._pointerCaptures[a.pointerId] = !0, r.pointerDownPredicate || (r.pointerDownPredicate = h => h.isPickable && h.isVisible && h.isReady() && h.isEnabled() && (!r.cameraToUseForPointers || (r.cameraToUseForPointers.layerMask & h.layerMask) !== 0)), this._pickedDownMesh = null; let l; r.skipPointerDownPicking || r._registeredActions === 0 && !this._checkForPicking() && !r.onPointerDown ? l = new ai : l = r.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, r.pointerDownPredicate, r.pointerDownFastCheck, r.cameraToUseForPointers), this._processPointerDown(l, a) }, this._onPointerUp = a => { this._totalPointersPressed !== 0 && (this._totalPointersPressed--, this._pickedUpMesh = null, this._meshPickProceed = !1, this._updatePointerPosition(a), r.preventDefaultOnPointerUp && s && (a.preventDefault(), s.focus()), this._initClickEvent(r.onPrePointerObservable, r.onPointerObservable, a, (o, l) => { if (r.onPrePointerObservable.hasObservers() && (this._skipPointerTap = !1, !o.ignore)) { if (this._checkPrePointerObservable(null, a, he.POINTERUP)) { this._swipeButtonPressed === a.button && (this._isSwiping = !1, this._swipeButtonPressed = -1), a.buttons === 0 && (this._pointerCaptures[a.pointerId] = !1); return } o.hasSwiped || (o.singleClick && r.onPrePointerObservable.hasSpecificMask(he.POINTERTAP) && this._checkPrePointerObservable(null, a, he.POINTERTAP) && (this._skipPointerTap = !0), o.doubleClick && r.onPrePointerObservable.hasSpecificMask(he.POINTERDOUBLETAP) && this._checkPrePointerObservable(null, a, he.POINTERDOUBLETAP) && (this._skipPointerTap = !0)) } if (!this._pointerCaptures[a.pointerId]) { this._swipeButtonPressed === a.button && (this._isSwiping = !1, this._swipeButtonPressed = -1); return } a.buttons === 0 && (this._pointerCaptures[a.pointerId] = !1), !(!r.cameraToUseForPointers && !r.activeCamera) && (r.pointerUpPredicate || (r.pointerUpPredicate = h => h.isPickable && h.isVisible && h.isReady() && h.isEnabled() && (!r.cameraToUseForPointers || (r.cameraToUseForPointers.layerMask & h.layerMask) !== 0)), !this._meshPickProceed && ($e && $e.HasTriggers || this._checkForPicking() || r.onPointerUp) && this._initActionManager(null, o), l || (l = this._currentPickResult), this._processPointerUp(l, a, o), this._previousPickResult = this._currentPickResult, this._swipeButtonPressed === a.button && (this._isSwiping = !1, this._swipeButtonPressed = -1)) })) }, this._onKeyDown = a => { const o = Si.KEYDOWN; if (r.onPreKeyboardObservable.hasObservers()) { const l = new Ds(o, a); if (r.onPreKeyboardObservable.notifyObservers(l, o), l.skipOnKeyboardObservable) return } if (r.onKeyboardObservable.hasObservers()) { const l = new Hi(o, a); r.onKeyboardObservable.notifyObservers(l, o) } r.actionManager && r.actionManager.processTrigger(14, De.CreateNewFromScene(r, a)) }, this._onKeyUp = a => { const o = Si.KEYUP; if (r.onPreKeyboardObservable.hasObservers()) { const l = new Ds(o, a); if (r.onPreKeyboardObservable.notifyObservers(l, o), l.skipOnKeyboardObservable) return } if (r.onKeyboardObservable.hasObservers()) { const l = new Hi(o, a); r.onKeyboardObservable.notifyObservers(l, o) } r.actionManager && r.actionManager.processTrigger(15, De.CreateNewFromScene(r, a)) }, this._deviceSourceManager.onDeviceConnectedObservable.add(a => { a.deviceType === W.Mouse ? a.onInputChangedObservable.add(o => { o.inputIndex === z.LeftClick || o.inputIndex === z.MiddleClick || o.inputIndex === z.RightClick || o.inputIndex === z.BrowserBack || o.inputIndex === z.BrowserForward ? t && a.getInput(o.inputIndex) === 1 ? this._onPointerDown(o) : e && a.getInput(o.inputIndex) === 0 && this._onPointerUp(o) : i && (o.inputIndex === z.Move ? this._onPointerMove(o) : (o.inputIndex === z.MouseWheelX || o.inputIndex === z.MouseWheelY || o.inputIndex === z.MouseWheelZ) && this._onPointerMove(o)) }) : a.deviceType === W.Touch ? a.onInputChangedObservable.add(o => { o.inputIndex === z.LeftClick && (t && a.getInput(o.inputIndex) === 1 ? (this._onPointerDown(o), this._totalPointersPressed > 1 && (this._isMultiTouchGesture = !0)) : e && a.getInput(o.inputIndex) === 0 && (this._onPointerUp(o), this._totalPointersPressed === 0 && (this._isMultiTouchGesture = !1))), i && o.inputIndex === z.Move && this._onPointerMove(o) }) : a.deviceType === W.Keyboard && a.onInputChangedObservable.add(o => { o.type === "keydown" ? this._onKeyDown(o) : o.type === "keyup" && this._onKeyUp(o) }) }), this._alreadyAttached = !0 } detachControl() { this._alreadyAttached && (this._deviceSourceManager.dispose(), this._deviceSourceManager = null, this._alreadyAttachedTo && !this._scene.doNotHandleCursors && (this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor), this._alreadyAttached = !1, this._alreadyAttachedTo = null) } setPointerOverMesh(e, t = 0, i, s) { if (this._meshUnderPointerId[t] === e && (!e || !e._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) return; const r = this._meshUnderPointerId[t]; let n; r && (n = r._getActionManagerForTrigger(10), n && n.processTrigger(10, De.CreateNew(r, s, { pointerId: t }))), e ? (this._meshUnderPointerId[t] = e, this._pointerOverMesh = e, n = e._getActionManagerForTrigger(9), n && n.processTrigger(9, De.CreateNew(e, s, { pointerId: t, pickResult: i }))) : (delete this._meshUnderPointerId[t], this._pointerOverMesh = null) } getPointerOverMesh() { return this.meshUnderPointer } _invalidateMesh(e) { this._pointerOverMesh === e && (this._pointerOverMesh = null), this._pickedDownMesh === e && (this._pickedDownMesh = null), this._pickedUpMesh === e && (this._pickedUpMesh = null); for (const t in this._meshUnderPointerId) this._meshUnderPointerId[t] === e && delete this._meshUnderPointerId[t] } } Te.DragMovementThreshold = 10, Te.LongPressDelay = 500, Te.DoubleClickDelay = 300, Te.ExclusiveDoubleClickMode = !1; class ct { get min() { return this._min } get max() { return this._max } get average() { return this._average } get lastSecAverage() { return this._lastSecAverage } get current() { return this._current } get total() { return this._totalAccumulated } get count() { return this._totalValueCount } constructor() { this._startMonitoringTime = 0, this._min = 0, this._max = 0, this._average = 0, this._lastSecAverage = 0, this._current = 0, this._totalValueCount = 0, this._totalAccumulated = 0, this._lastSecAccumulated = 0, this._lastSecTime = 0, this._lastSecValueCount = 0 } fetchNewFrame() { this._totalValueCount++, this._current = 0, this._lastSecValueCount++ } addCount(e, t) { ct.Enabled && (this._current += e, t && this._fetchResult()) } beginMonitoring() { ct.Enabled && (this._startMonitoringTime = wt.Now) } endMonitoring(e = !0) { if (!ct.Enabled) return; e && this.fetchNewFrame(); const t = wt.Now; this._current = t - this._startMonitoringTime, e && this._fetchResult() } endFrame() { this._fetchResult() } _fetchResult() { this._totalAccumulated += this._current, this._lastSecAccumulated += this._current, this._min = Math.min(this._min, this._current), this._max = Math.max(this._max, this._current), this._average = this._totalAccumulated / this._totalValueCount; const e = wt.Now; e - this._lastSecTime > 1e3 && (this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount, this._lastSecTime = e, this._lastSecAccumulated = 0, this._lastSecValueCount = 0) } } ct.Enabled = !0; class Ws { static get UniqueId() { const e = this._UniqueIdCounter; return this._UniqueIdCounter++, e } } Ws._UniqueIdCounter = 1; class Ce { static CompareLightsPriority(e, t) { return e.shadowEnabled !== t.shadowEnabled ? (t.shadowEnabled ? 1 : 0) - (e.shadowEnabled ? 1 : 0) : t.renderPriority - e.renderPriority } } Ce.FALLOFF_DEFAULT = 0, Ce.FALLOFF_PHYSICAL = 1, Ce.FALLOFF_GLTF = 2, Ce.FALLOFF_STANDARD = 3, Ce.LIGHTMAP_DEFAULT = 0, Ce.LIGHTMAP_SPECULAR = 1, Ce.LIGHTMAP_SHADOWSONLY = 2, Ce.INTENSITYMODE_AUTOMATIC = 0, Ce.INTENSITYMODE_LUMINOUSPOWER = 1, Ce.INTENSITYMODE_LUMINOUSINTENSITY = 2, Ce.INTENSITYMODE_ILLUMINANCE = 3, Ce.INTENSITYMODE_LUMINANCE = 4, Ce.LIGHTTYPEID_POINTLIGHT = 0, Ce.LIGHTTYPEID_DIRECTIONALLIGHT = 1, Ce.LIGHTTYPEID_SPOTLIGHT = 2, Ce.LIGHTTYPEID_HEMISPHERICLIGHT = 3; class en { constructor() { this.pointerDownFastCheck = !1, this.pointerUpFastCheck = !1, this.pointerMoveFastCheck = !1, this.skipPointerMovePicking = !1, this.skipPointerDownPicking = !1, this.skipPointerUpPicking = !1 } } var ut; (function (c) { c[c.BackwardCompatible = 0] = "BackwardCompatible", c[c.Intermediate = 1] = "Intermediate", c[c.Aggressive = 2] = "Aggressive" })(ut || (ut = {})); class Le extends zi { static DefaultMaterialFactory(e) { throw K("StandardMaterial") } static CollisionCoordinatorFactory() { throw K("DefaultCollisionCoordinator") } get environmentTexture() { return this._environmentTexture } set environmentTexture(e) { this._environmentTexture !== e && (this._environmentTexture = e, this.markAllMaterialsAsDirty(1)) } get imageProcessingConfiguration() { return this._imageProcessingConfiguration } get performancePriority() { return this._performancePriority } set performancePriority(e) { if (e !== this._performancePriority) { switch (this._performancePriority = e, e) { case ut.BackwardCompatible: this.skipFrustumClipping = !1, this._renderingManager.maintainStateBetweenFrames = !1, this.skipPointerMovePicking = !1, this.autoClear = !0; break; case ut.Intermediate: this.skipFrustumClipping = !1, this._renderingManager.maintainStateBetweenFrames = !1, this.skipPointerMovePicking = !0, this.autoClear = !1; break; case ut.Aggressive: this.skipFrustumClipping = !0, this._renderingManager.maintainStateBetweenFrames = !0, this.skipPointerMovePicking = !0, this.autoClear = !1; break }this.onScenePerformancePriorityChangedObservable.notifyObservers(e) } } set forceWireframe(e) { this._forceWireframe !== e && (this._forceWireframe = e, this.markAllMaterialsAsDirty(16)) } get forceWireframe() { return this._forceWireframe } set skipFrustumClipping(e) { this._skipFrustumClipping !== e && (this._skipFrustumClipping = e) } get skipFrustumClipping() { return this._skipFrustumClipping } set forcePointsCloud(e) { this._forcePointsCloud !== e && (this._forcePointsCloud = e, this.markAllMaterialsAsDirty(16)) } get forcePointsCloud() { return this._forcePointsCloud } get animationPropertiesOverride() { return this._animationPropertiesOverride } set animationPropertiesOverride(e) { this._animationPropertiesOverride = e } set onDispose(e) { this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e) } set beforeRender(e) { this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), e && (this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e)) } set afterRender(e) { this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), e && (this._onAfterRenderObserver = this.onAfterRenderObservable.add(e)) } set beforeCameraRender(e) { this._onBeforeCameraRenderObserver && this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver), this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(e) } set afterCameraRender(e) { this._onAfterCameraRenderObserver && this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver), this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(e) } get pointerDownPredicate() { return this._pointerPickingConfiguration.pointerDownPredicate } set pointerDownPredicate(e) { this._pointerPickingConfiguration.pointerDownPredicate = e } get pointerUpPredicate() { return this._pointerPickingConfiguration.pointerUpPredicate } set pointerUpPredicate(e) { this._pointerPickingConfiguration.pointerUpPredicate = e } get pointerMovePredicate() { return this._pointerPickingConfiguration.pointerMovePredicate } set pointerMovePredicate(e) { this._pointerPickingConfiguration.pointerMovePredicate = e } get pointerDownFastCheck() { return this._pointerPickingConfiguration.pointerDownFastCheck } set pointerDownFastCheck(e) { this._pointerPickingConfiguration.pointerDownFastCheck = e } get pointerUpFastCheck() { return this._pointerPickingConfiguration.pointerUpFastCheck } set pointerUpFastCheck(e) { this._pointerPickingConfiguration.pointerUpFastCheck = e } get pointerMoveFastCheck() { return this._pointerPickingConfiguration.pointerMoveFastCheck } set pointerMoveFastCheck(e) { this._pointerPickingConfiguration.pointerMoveFastCheck = e } get skipPointerMovePicking() { return this._pointerPickingConfiguration.skipPointerMovePicking } set skipPointerMovePicking(e) { this._pointerPickingConfiguration.skipPointerMovePicking = e } get skipPointerDownPicking() { return this._pointerPickingConfiguration.skipPointerDownPicking } set skipPointerDownPicking(e) { this._pointerPickingConfiguration.skipPointerDownPicking = e } get skipPointerUpPicking() { return this._pointerPickingConfiguration.skipPointerUpPicking } set skipPointerUpPicking(e) { this._pointerPickingConfiguration.skipPointerUpPicking = e } get unTranslatedPointer() { return this._inputManager.unTranslatedPointer } static get DragMovementThreshold() { return Te.DragMovementThreshold } static set DragMovementThreshold(e) { Te.DragMovementThreshold = e } static get LongPressDelay() { return Te.LongPressDelay } static set LongPressDelay(e) { Te.LongPressDelay = e } static get DoubleClickDelay() { return Te.DoubleClickDelay } static set DoubleClickDelay(e) { Te.DoubleClickDelay = e } static get ExclusiveDoubleClickMode() { return Te.ExclusiveDoubleClickMode } static set ExclusiveDoubleClickMode(e) { Te.ExclusiveDoubleClickMode = e } bindEyePosition(e, t = "vEyePosition", i = !1) { const s = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : this.activeCamera.globalPosition, r = this.useRightHandedSystem === (this._mirroredCameraPosition != null); return D.Vector4[0].set(s.x, s.y, s.z, r ? -1 : 1), e && (i ? e.setFloat3(t, D.Vector4[0].x, D.Vector4[0].y, D.Vector4[0].z) : e.setVector4(t, D.Vector4[0])), D.Vector4[0] } finalizeSceneUbo() { const e = this.getSceneUniformBuffer(), t = this.bindEyePosition(null); return e.updateFloat4("vEyePosition", t.x, t.y, t.z, t.w), e.update(), e } set useRightHandedSystem(e) { this._useRightHandedSystem !== e && (this._useRightHandedSystem = e, this.markAllMaterialsAsDirty(16)) } get useRightHandedSystem() { return this._useRightHandedSystem } setStepId(e) { this._currentStepId = e } getStepId() { return this._currentStepId } getInternalStep() { return this._currentInternalStep } set fogEnabled(e) { this._fogEnabled !== e && (this._fogEnabled = e, this.markAllMaterialsAsDirty(16)) } get fogEnabled() { return this._fogEnabled } set fogMode(e) { this._fogMode !== e && (this._fogMode = e, this.markAllMaterialsAsDirty(16)) } get fogMode() { return this._fogMode } get prePass() { return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled } set shadowsEnabled(e) { this._shadowsEnabled !== e && (this._shadowsEnabled = e, this.markAllMaterialsAsDirty(2)) } get shadowsEnabled() { return this._shadowsEnabled } set lightsEnabled(e) { this._lightsEnabled !== e && (this._lightsEnabled = e, this.markAllMaterialsAsDirty(2)) } get lightsEnabled() { return this._lightsEnabled } get activeCameras() { return this._activeCameras } set activeCameras(e) { this._unObserveActiveCameras && (this._unObserveActiveCameras(), this._unObserveActiveCameras = null), e && (this._unObserveActiveCameras = ar(e, () => { this.onActiveCamerasChanged.notifyObservers(this) })), this._activeCameras = e } get activeCamera() { return this._activeCamera } set activeCamera(e) { e !== this._activeCamera && (this._activeCamera = e, this.onActiveCameraChanged.notifyObservers(this)) } get defaultMaterial() { return this._defaultMaterial || (this._defaultMaterial = Le.DefaultMaterialFactory(this)), this._defaultMaterial } set defaultMaterial(e) { this._defaultMaterial = e } set texturesEnabled(e) { this._texturesEnabled !== e && (this._texturesEnabled = e, this.markAllMaterialsAsDirty(1)) } get texturesEnabled() { return this._texturesEnabled } set skeletonsEnabled(e) { this._skeletonsEnabled !== e && (this._skeletonsEnabled = e, this.markAllMaterialsAsDirty(8)) } get skeletonsEnabled() { return this._skeletonsEnabled } get collisionCoordinator() { return this._collisionCoordinator || (this._collisionCoordinator = Le.CollisionCoordinatorFactory(), this._collisionCoordinator.init(this)), this._collisionCoordinator } get renderingManager() { return this._renderingManager } get frustumPlanes() { return this._frustumPlanes } _registerTransientComponents() { if (this._transientComponents.length > 0) { for (const e of this._transientComponents) e.register(); this._transientComponents.length = 0 } } _addComponent(e) { this._components.push(e), this._transientComponents.push(e); const t = e; t.addFromContainer && t.serialize && this._serializableComponents.push(t) } _getComponent(e) { for (const t of this._components) if (t.name === e) return t; return null } constructor(e, t) { super(), this._inputManager = new Te(this), this.cameraToUseForPointers = null, this._isScene = !0, this._blockEntityCollection = !1, this.autoClear = !0, this.autoClearDepthAndStencil = !0, this.clearColor = new de(.2, .2, .3, 1), this.ambientColor = new te(0, 0, 0), this.environmentIntensity = 1, this._performancePriority = ut.BackwardCompatible, this.onScenePerformancePriorityChangedObservable = new L, this._forceWireframe = !1, this._skipFrustumClipping = !1, this._forcePointsCloud = !1, this.animationsEnabled = !0, this._animationPropertiesOverride = null, this.useConstantAnimationDeltaTime = !1, this.constantlyUpdateMeshUnderPointer = !1, this.hoverCursor = "pointer", this.defaultCursor = "", this.doNotHandleCursors = !1, this.preventDefaultOnPointerDown = !0, this.preventDefaultOnPointerUp = !0, this.metadata = null, this.reservedDataStore = null, this.disableOfflineSupportExceptionRules = [], this.onDisposeObservable = new L, this._onDisposeObserver = null, this.onBeforeRenderObservable = new L, this._onBeforeRenderObserver = null, this.onAfterRenderObservable = new L, this.onAfterRenderCameraObservable = new L, this._onAfterRenderObserver = null, this.onBeforeAnimationsObservable = new L, this.onAfterAnimationsObservable = new L, this.onBeforeDrawPhaseObservable = new L, this.onAfterDrawPhaseObservable = new L, this.onReadyObservable = new L, this.onBeforeCameraRenderObservable = new L, this._onBeforeCameraRenderObserver = null, this.onAfterCameraRenderObservable = new L, this._onAfterCameraRenderObserver = null, this.onBeforeActiveMeshesEvaluationObservable = new L, this.onAfterActiveMeshesEvaluationObservable = new L, this.onBeforeParticlesRenderingObservable = new L, this.onAfterParticlesRenderingObservable = new L, this.onDataLoadedObservable = new L, this.onNewCameraAddedObservable = new L, this.onCameraRemovedObservable = new L, this.onNewLightAddedObservable = new L, this.onLightRemovedObservable = new L, this.onNewGeometryAddedObservable = new L, this.onGeometryRemovedObservable = new L, this.onNewTransformNodeAddedObservable = new L, this.onTransformNodeRemovedObservable = new L, this.onNewMeshAddedObservable = new L, this.onMeshRemovedObservable = new L, this.onNewSkeletonAddedObservable = new L, this.onSkeletonRemovedObservable = new L, this.onNewMaterialAddedObservable = new L, this.onNewMultiMaterialAddedObservable = new L, this.onMaterialRemovedObservable = new L, this.onMultiMaterialRemovedObservable = new L, this.onNewTextureAddedObservable = new L, this.onTextureRemovedObservable = new L, this.onBeforeRenderTargetsRenderObservable = new L, this.onAfterRenderTargetsRenderObservable = new L, this.onBeforeStepObservable = new L, this.onAfterStepObservable = new L, this.onActiveCameraChanged = new L, this.onActiveCamerasChanged = new L, this.onBeforeRenderingGroupObservable = new L, this.onAfterRenderingGroupObservable = new L, this.onMeshImportedObservable = new L, this.onAnimationFileImportedObservable = new L, this._registeredForLateAnimationBindings = new Ft(256), this._pointerPickingConfiguration = new en, this.onPrePointerObservable = new L, this.onPointerObservable = new L, this.onPreKeyboardObservable = new L, this.onKeyboardObservable = new L, this._useRightHandedSystem = !1, this._timeAccumulator = 0, this._currentStepId = 0, this._currentInternalStep = 0, this._fogEnabled = !0, this._fogMode = Le.FOGMODE_NONE, this.fogColor = new te(.2, .2, .3), this.fogDensity = .1, this.fogStart = 0, this.fogEnd = 1e3, this.needsPreviousWorldMatrices = !1, this._shadowsEnabled = !0, this._lightsEnabled = !0, this._unObserveActiveCameras = null, this._texturesEnabled = !0, this.physicsEnabled = !0, this.particlesEnabled = !0, this.spritesEnabled = !0, this._skeletonsEnabled = !0, this.lensFlaresEnabled = !0, this.collisionsEnabled = !0, this.gravity = new g(0, -9.807, 0), this.postProcessesEnabled = !0, this.renderTargetsEnabled = !0, this.dumpNextRenderTargets = !1, this.customRenderTargets = [], this.importedMeshesFiles = [], this.probesEnabled = !0, this._meshesForIntersections = new Ft(256), this.proceduralTexturesEnabled = !0, this._totalVertices = new ct, this._activeIndices = new ct, this._activeParticles = new ct, this._activeBones = new ct, this._animationTime = 0, this.animationTimeScale = 1, this._renderId = 0, this._frameId = 0, this._executeWhenReadyTimeoutId = null, this._intermediateRendering = !1, this._defaultFrameBufferCleared = !1, this._viewUpdateFlag = -1, this._projectionUpdateFlag = -1, this._toBeDisposed = new Array(256), this._activeRequests = new Array, this._pendingData = new Array, this._isDisposed = !1, this.dispatchAllSubMeshesOfActiveMeshes = !1, this._activeMeshes = new He(256), this._processedMaterials = new He(256), this._renderTargets = new Ft(256), this._materialsRenderTargets = new Ft(256), this._activeParticleSystems = new He(256), this._activeSkeletons = new Ft(32), this._softwareSkinnedMeshes = new Ft(32), this._activeAnimatables = new Array, this._transformMatrix = A.Zero(), this.requireLightSorting = !1, this._components = [], this._serializableComponents = [], this._transientComponents = [], this._beforeCameraUpdateStage = be.Create(), this._beforeClearStage = be.Create(), this._beforeRenderTargetClearStage = be.Create(), this._gatherRenderTargetsStage = be.Create(), this._gatherActiveCameraRenderTargetsStage = be.Create(), this._isReadyForMeshStage = be.Create(), this._beforeEvaluateActiveMeshStage = be.Create(), this._evaluateSubMeshStage = be.Create(), this._preActiveMeshStage = be.Create(), this._cameraDrawRenderTargetStage = be.Create(), this._beforeCameraDrawStage = be.Create(), this._beforeRenderTargetDrawStage = be.Create(), this._beforeRenderingGroupDrawStage = be.Create(), this._beforeRenderingMeshStage = be.Create(), this._afterRenderingMeshStage = be.Create(), this._afterRenderingGroupDrawStage = be.Create(), this._afterCameraDrawStage = be.Create(), this._afterCameraPostProcessStage = be.Create(), this._afterRenderTargetDrawStage = be.Create(), this._afterRenderTargetPostProcessStage = be.Create(), this._afterRenderStage = be.Create(), this._pointerMoveStage = be.Create(), this._pointerDownStage = be.Create(), this._pointerUpStage = be.Create(), this._geometriesByUniqueId = null, this._defaultMeshCandidates = { data: [], length: 0 }, this._defaultSubMeshCandidates = { data: [], length: 0 }, this._preventFreeActiveMeshesAndRenderingGroups = !1, this._activeMeshesFrozen = !1, this._activeMeshesFrozenButKeepClipping = !1, this._skipEvaluateActiveMeshesCompletely = !1, this._allowPostProcessClearColor = !0, this.getDeterministicFrameTime = () => this._engine.getTimeStep(), this._registeredActions = 0, this._blockMaterialDirtyMechanism = !1, this._perfCollector = null, this.activeCameras = []; const i = Object.assign({ useGeometryUniqueIdsMap: !0, useMaterialMeshMap: !0, useClonedMeshMap: !0, virtual: !1 }, t); e = this._engine = e || ce.LastCreatedEngine, i.virtual ? e._virtualScenes.push(this) : (ce._LastCreatedScene = this, e.scenes.push(this)), this._uid = null, this._renderingManager = new Be(this), Is && (this.postProcessManager = new Is(this)), Fe() && this.attachControl(), this._createUbo(), oe && (this._imageProcessingConfiguration = new oe), this.setDefaultCandidateProviders(), i.useGeometryUniqueIdsMap && (this._geometriesByUniqueId = {}), this.useMaterialMeshMap = i.useMaterialMeshMap, this.useClonedMeshMap = i.useClonedMeshMap, (!t || !t.virtual) && e.onNewSceneAddedObservable.notifyObservers(this) } getClassName() { return "Scene" } _getDefaultMeshCandidates() { return this._defaultMeshCandidates.data = this.meshes, this._defaultMeshCandidates.length = this.meshes.length, this._defaultMeshCandidates } _getDefaultSubMeshCandidates(e) { return this._defaultSubMeshCandidates.data = e.subMeshes, this._defaultSubMeshCandidates.length = e.subMeshes.length, this._defaultSubMeshCandidates } setDefaultCandidateProviders() { this.getActiveMeshCandidates = () => this._getDefaultMeshCandidates(), this.getActiveSubMeshCandidates = e => this._getDefaultSubMeshCandidates(e), this.getIntersectingSubMeshCandidates = (e, t) => this._getDefaultSubMeshCandidates(e), this.getCollidingSubMeshCandidates = (e, t) => this._getDefaultSubMeshCandidates(e) } get meshUnderPointer() { return this._inputManager.meshUnderPointer } get pointerX() { return this._inputManager.pointerX } set pointerX(e) { this._inputManager.pointerX = e } get pointerY() { return this._inputManager.pointerY } set pointerY(e) { this._inputManager.pointerY = e } getCachedMaterial() { return this._cachedMaterial } getCachedEffect() { return this._cachedEffect } getCachedVisibility() { return this._cachedVisibility } isCachedMaterialInvalid(e, t, i = 1) { return this._cachedEffect !== t || this._cachedMaterial !== e || this._cachedVisibility !== i } getEngine() { return this._engine } getTotalVertices() { return this._totalVertices.current } get totalVerticesPerfCounter() { return this._totalVertices } getActiveIndices() { return this._activeIndices.current } get totalActiveIndicesPerfCounter() { return this._activeIndices } getActiveParticles() { return this._activeParticles.current } get activeParticlesPerfCounter() { return this._activeParticles } getActiveBones() { return this._activeBones.current } get activeBonesPerfCounter() { return this._activeBones } getActiveMeshes() { return this._activeMeshes } getAnimationRatio() { return this._animationRatio !== void 0 ? this._animationRatio : 1 } getRenderId() { return this._renderId } getFrameId() { return this._frameId } incrementRenderId() { this._renderId++ } _createUbo() { this.setSceneUniformBuffer(this.createSceneUniformBuffer()) } simulatePointerMove(e, t) { return this._inputManager.simulatePointerMove(e, t), this } simulatePointerDown(e, t) { return this._inputManager.simulatePointerDown(e, t), this } simulatePointerUp(e, t, i) { return this._inputManager.simulatePointerUp(e, t, i), this } isPointerCaptured(e = 0) { return this._inputManager.isPointerCaptured(e) } attachControl(e = !0, t = !0, i = !0) { this._inputManager.attachControl(e, t, i) } detachControl() { this._inputManager.detachControl() } isReady(e = !0) { var t, i, s; if (this._isDisposed) return !1; let r; const n = this.getEngine(), a = n.currentRenderPassId; n.currentRenderPassId = (i = (t = this.activeCamera) === null || t === void 0 ? void 0 : t.renderPassId) !== null && i !== void 0 ? i : a; let o = !0; for (this._pendingData.length > 0 && (o = !1), (s = this.prePassRenderer) === null || s === void 0 || s.update(), this.useOrderIndependentTransparency && this.depthPeelingRenderer && o && (o = this.depthPeelingRenderer.isReady()), e && (this._processedMaterials.reset(), this._materialsRenderTargets.reset()), r = 0; r < this.meshes.length; r++) { const l = this.meshes[r]; if (!l.subMeshes || l.subMeshes.length === 0) continue; if (!l.isReady(!0)) { o = !1; continue } const h = l.hasThinInstances || l.getClassName() === "InstancedMesh" || l.getClassName() === "InstancedLinesMesh" || n.getCaps().instancedArrays && l.instances.length > 0; for (const f of this._isReadyForMeshStage) f.action(l, h) || (o = !1); if (!e) continue; const u = l.material || this.defaultMaterial; if (u) if (u._storeEffectOnSubMeshes) for (const f of l.subMeshes) { const _ = f.getMaterial(); _ && _.hasRenderTargetTextures && _.getRenderTargetTextures != null && this._processedMaterials.indexOf(_) === -1 && (this._processedMaterials.push(_), this._materialsRenderTargets.concatWithNoDuplicate(_.getRenderTargetTextures())) } else u.hasRenderTargetTextures && u.getRenderTargetTextures != null && this._processedMaterials.indexOf(u) === -1 && (this._processedMaterials.push(u), this._materialsRenderTargets.concatWithNoDuplicate(u.getRenderTargetTextures())) } if (e) for (r = 0; r < this._materialsRenderTargets.length; ++r)this._materialsRenderTargets.data[r].isReadyForRendering() || (o = !1); for (r = 0; r < this.geometries.length; r++)this.geometries[r].delayLoadState === 2 && (o = !1); if (this.activeCameras && this.activeCameras.length > 0) for (const l of this.activeCameras) l.isReady(!0) || (o = !1); else this.activeCamera && (this.activeCamera.isReady(!0) || (o = !1)); for (const l of this.particleSystems) l.isReady() || (o = !1); if (this.layers) for (const l of this.layers) l.isReady() || (o = !1); return n.areAllEffectsReady() || (o = !1), n.currentRenderPassId = a, o } resetCachedMaterial() { this._cachedMaterial = null, this._cachedEffect = null, this._cachedVisibility = null } registerBeforeRender(e) { this.onBeforeRenderObservable.add(e) } unregisterBeforeRender(e) { this.onBeforeRenderObservable.removeCallback(e) } registerAfterRender(e) { this.onAfterRenderObservable.add(e) } unregisterAfterRender(e) { this.onAfterRenderObservable.removeCallback(e) } _executeOnceBeforeRender(e) { const t = () => { e(), setTimeout(() => { this.unregisterBeforeRender(t) }) }; this.registerBeforeRender(t) } executeOnceBeforeRender(e, t) { t !== void 0 ? setTimeout(() => { this._executeOnceBeforeRender(e) }, t) : this._executeOnceBeforeRender(e) } addPendingData(e) { this._pendingData.push(e) } removePendingData(e) { const t = this.isLoading, i = this._pendingData.indexOf(e); i !== -1 && this._pendingData.splice(i, 1), t && !this.isLoading && this.onDataLoadedObservable.notifyObservers(this) } getWaitingItemsCount() { return this._pendingData.length } get isLoading() { return this._pendingData.length > 0 } executeWhenReady(e, t = !1) { this.onReadyObservable.addOnce(e), this._executeWhenReadyTimeoutId === null && this._checkIsReady(t) } whenReadyAsync(e = !1) { return new Promise(t => { this.executeWhenReady(() => { t() }, e) }) } _checkIsReady(e = !1) { if (this._registerTransientComponents(), this.isReady(e)) { this.onReadyObservable.notifyObservers(this), this.onReadyObservable.clear(), this._executeWhenReadyTimeoutId = null; return } if (this._isDisposed) { this.onReadyObservable.clear(), this._executeWhenReadyTimeoutId = null; return } this._executeWhenReadyTimeoutId = setTimeout(() => { this.incrementRenderId(), this._checkIsReady(e) }, 100) } get animatables() { return this._activeAnimatables } resetLastAnimationTimeFrame() { this._animationTimeLast = wt.Now } getViewMatrix() { return this._viewMatrix } getProjectionMatrix() { return this._projectionMatrix } getTransformMatrix() { return this._transformMatrix } setTransformMatrix(e, t, i, s) { !i && !s && this._multiviewSceneUbo && (this._multiviewSceneUbo.dispose(), this._multiviewSceneUbo = null), !(this._viewUpdateFlag === e.updateFlag && this._projectionUpdateFlag === t.updateFlag) && (this._viewUpdateFlag = e.updateFlag, this._projectionUpdateFlag = t.updateFlag, this._viewMatrix = e, this._projectionMatrix = t, this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._frustumPlanes ? it.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = it.GetPlanes(this._transformMatrix), this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo ? this._updateMultiviewUbo(i, s) : this._sceneUbo.useUbo && (this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix), this._sceneUbo.updateMatrix("view", this._viewMatrix), this._sceneUbo.updateMatrix("projection", this._projectionMatrix))) } getSceneUniformBuffer() { return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo } createSceneUniformBuffer(e) { const t = new U(this._engine, void 0, !1, e ?? "scene"); return t.addUniform("viewProjection", 16), t.addUniform("view", 16), t.addUniform("projection", 16), t.addUniform("vEyePosition", 4), t } setSceneUniformBuffer(e) { this._sceneUbo = e, this._viewUpdateFlag = -1, this._projectionUpdateFlag = -1 } getUniqueId() { return Ws.UniqueId } addMesh(e, t = !1) { this._blockEntityCollection || (this.meshes.push(e), e._resyncLightSources(), e.parent || e._addToSceneRootNodes(), this.onNewMeshAddedObservable.notifyObservers(e), t && e.getChildMeshes().forEach(i => { this.addMesh(i) })) } removeMesh(e, t = !1) { const i = this.meshes.indexOf(e); return i !== -1 && (this.meshes[i] = this.meshes[this.meshes.length - 1], this.meshes.pop(), e.parent || e._removeFromSceneRootNodes()), this._inputManager._invalidateMesh(e), this.onMeshRemovedObservable.notifyObservers(e), t && e.getChildMeshes().forEach(s => { this.removeMesh(s) }), i } addTransformNode(e) { this._blockEntityCollection || e.getScene() === this && e._indexInSceneTransformNodesArray !== -1 || (e._indexInSceneTransformNodesArray = this.transformNodes.length, this.transformNodes.push(e), e.parent || e._addToSceneRootNodes(), this.onNewTransformNodeAddedObservable.notifyObservers(e)) } removeTransformNode(e) { const t = e._indexInSceneTransformNodesArray; if (t !== -1) { if (t !== this.transformNodes.length - 1) { const i = this.transformNodes[this.transformNodes.length - 1]; this.transformNodes[t] = i, i._indexInSceneTransformNodesArray = t } e._indexInSceneTransformNodesArray = -1, this.transformNodes.pop(), e.parent || e._removeFromSceneRootNodes() } return this.onTransformNodeRemovedObservable.notifyObservers(e), t } removeSkeleton(e) { const t = this.skeletons.indexOf(e); return t !== -1 && (this.skeletons.splice(t, 1), this.onSkeletonRemovedObservable.notifyObservers(e), this._executeActiveContainerCleanup(this._activeSkeletons)), t } removeMorphTargetManager(e) { const t = this.morphTargetManagers.indexOf(e); return t !== -1 && this.morphTargetManagers.splice(t, 1), t } removeLight(e) { const t = this.lights.indexOf(e); if (t !== -1) { for (const i of this.meshes) i._removeLightSource(e, !1); this.lights.splice(t, 1), this.sortLightsByPriority(), e.parent || e._removeFromSceneRootNodes() } return this.onLightRemovedObservable.notifyObservers(e), t } removeCamera(e) { const t = this.cameras.indexOf(e); if (t !== -1 && (this.cameras.splice(t, 1), e.parent || e._removeFromSceneRootNodes()), this.activeCameras) { const i = this.activeCameras.indexOf(e); i !== -1 && this.activeCameras.splice(i, 1) } return this.activeCamera === e && (this.cameras.length > 0 ? this.activeCamera = this.cameras[0] : this.activeCamera = null), this.onCameraRemovedObservable.notifyObservers(e), t } removeParticleSystem(e) { const t = this.particleSystems.indexOf(e); return t !== -1 && (this.particleSystems.splice(t, 1), this._executeActiveContainerCleanup(this._activeParticleSystems)), t } removeAnimation(e) { const t = this.animations.indexOf(e); return t !== -1 && this.animations.splice(t, 1), t } stopAnimation(e, t, i) { } removeAnimationGroup(e) { const t = this.animationGroups.indexOf(e); return t !== -1 && this.animationGroups.splice(t, 1), t } removeMultiMaterial(e) { const t = this.multiMaterials.indexOf(e); return t !== -1 && this.multiMaterials.splice(t, 1), this.onMultiMaterialRemovedObservable.notifyObservers(e), t } removeMaterial(e) { const t = e._indexInSceneMaterialArray; if (t !== -1 && t < this.materials.length) { if (t !== this.materials.length - 1) { const i = this.materials[this.materials.length - 1]; this.materials[t] = i, i._indexInSceneMaterialArray = t } e._indexInSceneMaterialArray = -1, this.materials.pop() } return this.onMaterialRemovedObservable.notifyObservers(e), t } removeActionManager(e) { const t = this.actionManagers.indexOf(e); return t !== -1 && this.actionManagers.splice(t, 1), t } removeTexture(e) { const t = this.textures.indexOf(e); return t !== -1 && this.textures.splice(t, 1), this.onTextureRemovedObservable.notifyObservers(e), t } addLight(e) { if (!this._blockEntityCollection) { this.lights.push(e), this.sortLightsByPriority(), e.parent || e._addToSceneRootNodes(); for (const t of this.meshes) t.lightSources.indexOf(e) === -1 && (t.lightSources.push(e), t._resyncLightSources()); this.onNewLightAddedObservable.notifyObservers(e) } } sortLightsByPriority() { this.requireLightSorting && this.lights.sort(Ce.CompareLightsPriority) } addCamera(e) { this._blockEntityCollection || (this.cameras.push(e), this.onNewCameraAddedObservable.notifyObservers(e), e.parent || e._addToSceneRootNodes()) } addSkeleton(e) { this._blockEntityCollection || (this.skeletons.push(e), this.onNewSkeletonAddedObservable.notifyObservers(e)) } addParticleSystem(e) { this._blockEntityCollection || this.particleSystems.push(e) } addAnimation(e) { this._blockEntityCollection || this.animations.push(e) } addAnimationGroup(e) { this._blockEntityCollection || this.animationGroups.push(e) } addMultiMaterial(e) { this._blockEntityCollection || (this.multiMaterials.push(e), this.onNewMultiMaterialAddedObservable.notifyObservers(e)) } addMaterial(e) { this._blockEntityCollection || e.getScene() === this && e._indexInSceneMaterialArray !== -1 || (e._indexInSceneMaterialArray = this.materials.length, this.materials.push(e), this.onNewMaterialAddedObservable.notifyObservers(e)) } addMorphTargetManager(e) { this._blockEntityCollection || this.morphTargetManagers.push(e) } addGeometry(e) { this._blockEntityCollection || (this._geometriesByUniqueId && (this._geometriesByUniqueId[e.uniqueId] = this.geometries.length), this.geometries.push(e)) } addActionManager(e) { this.actionManagers.push(e) } addTexture(e) { this._blockEntityCollection || (this.textures.push(e), this.onNewTextureAddedObservable.notifyObservers(e)) } switchActiveCamera(e, t = !0) { this._engine.getInputElement() && (this.activeCamera && this.activeCamera.detachControl(), this.activeCamera = e, t && e.attachControl()) } setActiveCameraById(e) { const t = this.getCameraById(e); return t ? (this.activeCamera = t, t) : null } setActiveCameraByName(e) { const t = this.getCameraByName(e); return t ? (this.activeCamera = t, t) : null } getAnimationGroupByName(e) { for (let t = 0; t < this.animationGroups.length; t++)if (this.animationGroups[t].name === e) return this.animationGroups[t]; return null } _getMaterial(e, t) { for (let i = 0; i < this.materials.length; i++) { const s = this.materials[i]; if (t(s)) return s } if (e) for (let i = 0; i < this.multiMaterials.length; i++) { const s = this.multiMaterials[i]; if (t(s)) return s } return null } getMaterialByUniqueID(e, t = !1) { return this._getMaterial(t, i => i.uniqueId === e) } getMaterialById(e, t = !1) { return this._getMaterial(t, i => i.id === e) } getMaterialByName(e, t = !1) { return this._getMaterial(t, i => i.name === e) } getLastMaterialById(e, t = !1) { for (let i = this.materials.length - 1; i >= 0; i--)if (this.materials[i].id === e) return this.materials[i]; if (t) { for (let i = this.multiMaterials.length - 1; i >= 0; i--)if (this.multiMaterials[i].id === e) return this.multiMaterials[i] } return null } getTextureByUniqueId(e) { for (let t = 0; t < this.textures.length; t++)if (this.textures[t].uniqueId === e) return this.textures[t]; return null } getTextureByName(e) { for (let t = 0; t < this.textures.length; t++)if (this.textures[t].name === e) return this.textures[t]; return null } getCameraById(e) { for (let t = 0; t < this.cameras.length; t++)if (this.cameras[t].id === e) return this.cameras[t]; return null } getCameraByUniqueId(e) { for (let t = 0; t < this.cameras.length; t++)if (this.cameras[t].uniqueId === e) return this.cameras[t]; return null } getCameraByName(e) { for (let t = 0; t < this.cameras.length; t++)if (this.cameras[t].name === e) return this.cameras[t]; return null } getBoneById(e) { for (let t = 0; t < this.skeletons.length; t++) { const i = this.skeletons[t]; for (let s = 0; s < i.bones.length; s++)if (i.bones[s].id === e) return i.bones[s] } return null } getBoneByName(e) { for (let t = 0; t < this.skeletons.length; t++) { const i = this.skeletons[t]; for (let s = 0; s < i.bones.length; s++)if (i.bones[s].name === e) return i.bones[s] } return null } getLightByName(e) { for (let t = 0; t < this.lights.length; t++)if (this.lights[t].name === e) return this.lights[t]; return null } getLightById(e) { for (let t = 0; t < this.lights.length; t++)if (this.lights[t].id === e) return this.lights[t]; return null } getLightByUniqueId(e) { for (let t = 0; t < this.lights.length; t++)if (this.lights[t].uniqueId === e) return this.lights[t]; return null } getParticleSystemById(e) { for (let t = 0; t < this.particleSystems.length; t++)if (this.particleSystems[t].id === e) return this.particleSystems[t]; return null } getGeometryById(e) { for (let t = 0; t < this.geometries.length; t++)if (this.geometries[t].id === e) return this.geometries[t]; return null } _getGeometryByUniqueId(e) { if (this._geometriesByUniqueId) { const t = this._geometriesByUniqueId[e]; if (t !== void 0) return this.geometries[t] } else for (let t = 0; t < this.geometries.length; t++)if (this.geometries[t].uniqueId === e) return this.geometries[t]; return null } pushGeometry(e, t) { return !t && this._getGeometryByUniqueId(e.uniqueId) ? !1 : (this.addGeometry(e), this.onNewGeometryAddedObservable.notifyObservers(e), !0) } removeGeometry(e) { let t; if (this._geometriesByUniqueId) { if (t = this._geometriesByUniqueId[e.uniqueId], t === void 0) return !1 } else if (t = this.geometries.indexOf(e), t < 0) return !1; if (t !== this.geometries.length - 1) { const i = this.geometries[this.geometries.length - 1]; i && (this.geometries[t] = i, this._geometriesByUniqueId && (this._geometriesByUniqueId[i.uniqueId] = t)) } return this._geometriesByUniqueId && (this._geometriesByUniqueId[e.uniqueId] = void 0), this.geometries.pop(), this.onGeometryRemovedObservable.notifyObservers(e), !0 } getGeometries() { return this.geometries } getMeshById(e) { for (let t = 0; t < this.meshes.length; t++)if (this.meshes[t].id === e) return this.meshes[t]; return null } getMeshesById(e) { return this.meshes.filter(function (t) { return t.id === e }) } getTransformNodeById(e) { for (let t = 0; t < this.transformNodes.length; t++)if (this.transformNodes[t].id === e) return this.transformNodes[t]; return null } getTransformNodeByUniqueId(e) { for (let t = 0; t < this.transformNodes.length; t++)if (this.transformNodes[t].uniqueId === e) return this.transformNodes[t]; return null } getTransformNodesById(e) { return this.transformNodes.filter(function (t) { return t.id === e }) } getMeshByUniqueId(e) { for (let t = 0; t < this.meshes.length; t++)if (this.meshes[t].uniqueId === e) return this.meshes[t]; return null } getLastMeshById(e) { for (let t = this.meshes.length - 1; t >= 0; t--)if (this.meshes[t].id === e) return this.meshes[t]; return null } getLastTransformNodeById(e) { for (let t = this.transformNodes.length - 1; t >= 0; t--)if (this.transformNodes[t].id === e) return this.transformNodes[t]; return null } getLastEntryById(e) { let t; for (t = this.meshes.length - 1; t >= 0; t--)if (this.meshes[t].id === e) return this.meshes[t]; for (t = this.transformNodes.length - 1; t >= 0; t--)if (this.transformNodes[t].id === e) return this.transformNodes[t]; for (t = this.cameras.length - 1; t >= 0; t--)if (this.cameras[t].id === e) return this.cameras[t]; for (t = this.lights.length - 1; t >= 0; t--)if (this.lights[t].id === e) return this.lights[t]; return null } getNodeById(e) { const t = this.getMeshById(e); if (t) return t; const i = this.getTransformNodeById(e); if (i) return i; const s = this.getLightById(e); if (s) return s; const r = this.getCameraById(e); if (r) return r; const n = this.getBoneById(e); return n || null } getNodeByName(e) { const t = this.getMeshByName(e); if (t) return t; const i = this.getTransformNodeByName(e); if (i) return i; const s = this.getLightByName(e); if (s) return s; const r = this.getCameraByName(e); if (r) return r; const n = this.getBoneByName(e); return n || null } getMeshByName(e) { for (let t = 0; t < this.meshes.length; t++)if (this.meshes[t].name === e) return this.meshes[t]; return null } getTransformNodeByName(e) { for (let t = 0; t < this.transformNodes.length; t++)if (this.transformNodes[t].name === e) return this.transformNodes[t]; return null } getLastSkeletonById(e) { for (let t = this.skeletons.length - 1; t >= 0; t--)if (this.skeletons[t].id === e) return this.skeletons[t]; return null } getSkeletonByUniqueId(e) { for (let t = 0; t < this.skeletons.length; t++)if (this.skeletons[t].uniqueId === e) return this.skeletons[t]; return null } getSkeletonById(e) { for (let t = 0; t < this.skeletons.length; t++)if (this.skeletons[t].id === e) return this.skeletons[t]; return null } getSkeletonByName(e) { for (let t = 0; t < this.skeletons.length; t++)if (this.skeletons[t].name === e) return this.skeletons[t]; return null } getMorphTargetManagerById(e) { for (let t = 0; t < this.morphTargetManagers.length; t++)if (this.morphTargetManagers[t].uniqueId === e) return this.morphTargetManagers[t]; return null } getMorphTargetById(e) { for (let t = 0; t < this.morphTargetManagers.length; ++t) { const i = this.morphTargetManagers[t]; for (let s = 0; s < i.numTargets; ++s) { const r = i.getTarget(s); if (r.id === e) return r } } return null } getMorphTargetByName(e) { for (let t = 0; t < this.morphTargetManagers.length; ++t) { const i = this.morphTargetManagers[t]; for (let s = 0; s < i.numTargets; ++s) { const r = i.getTarget(s); if (r.name === e) return r } } return null } getPostProcessByName(e) { for (let t = 0; t < this.postProcesses.length; ++t) { const i = this.postProcesses[t]; if (i.name === e) return i } return null } isActiveMesh(e) { return this._activeMeshes.indexOf(e) !== -1 } get uid() { return this._uid || (this._uid = G.RandomId()), this._uid } addExternalData(e, t) { return this._externalData || (this._externalData = new Ms), this._externalData.add(e, t) } getExternalData(e) { return this._externalData ? this._externalData.get(e) : null } getOrAddExternalDataWithFactory(e, t) { return this._externalData || (this._externalData = new Ms), this._externalData.getOrAddWithFactory(e, t) } removeExternalData(e) { return this._externalData.remove(e) } _evaluateSubMesh(e, t, i, s) { if (s || e.isInFrustum(this._frustumPlanes)) { for (const n of this._evaluateSubMeshStage) n.action(t, e); const r = e.getMaterial(); r != null && (r.hasRenderTargetTextures && r.getRenderTargetTextures != null && this._processedMaterials.indexOf(r) === -1 && (this._processedMaterials.push(r), this._materialsRenderTargets.concatWithNoDuplicate(r.getRenderTargetTextures())), this._renderingManager.dispatch(e, t, r)) } } freeProcessedMaterials() { this._processedMaterials.dispose() } get blockfreeActiveMeshesAndRenderingGroups() { return this._preventFreeActiveMeshesAndRenderingGroups } set blockfreeActiveMeshesAndRenderingGroups(e) { this._preventFreeActiveMeshesAndRenderingGroups !== e && (e && (this.freeActiveMeshes(), this.freeRenderingGroups()), this._preventFreeActiveMeshesAndRenderingGroups = e) } freeActiveMeshes() { if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._activeMeshes.dispose(), this.activeCamera && this.activeCamera._activeMeshes && this.activeCamera._activeMeshes.dispose(), this.activeCameras)) for (let e = 0; e < this.activeCameras.length; e++) { const t = this.activeCameras[e]; t && t._activeMeshes && t._activeMeshes.dispose() } } freeRenderingGroups() { if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._renderingManager && this._renderingManager.freeRenderingGroups(), this.textures)) for (let e = 0; e < this.textures.length; e++) { const t = this.textures[e]; t && t.renderList && t.freeRenderingGroups() } } _isInIntermediateRendering() { return this._intermediateRendering } freezeActiveMeshes(e = !1, t, i, s = !0, r = !1) { return this.executeWhenReady(() => { if (!this.activeCamera) { i && i("No active camera found"); return } if (this._frustumPlanes || this.updateTransformMatrix(), this._evaluateActiveMeshes(), this._activeMeshesFrozen = !0, this._activeMeshesFrozenButKeepClipping = r, this._skipEvaluateActiveMeshesCompletely = e, s) for (let n = 0; n < this._activeMeshes.length; n++)this._activeMeshes.data[n]._freeze(); t && t() }), this } unfreezeActiveMeshes() { for (let e = 0; e < this.meshes.length; e++) { const t = this.meshes[e]; t._internalAbstractMeshDataInfo && (t._internalAbstractMeshDataInfo._isActive = !1) } for (let e = 0; e < this._activeMeshes.length; e++)this._activeMeshes.data[e]._unFreeze(); return this._activeMeshesFrozen = !1, this } _executeActiveContainerCleanup(e) { !(this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) && this._activeMeshesFrozen && this._activeMeshes.length || this.onBeforeRenderObservable.addOnce(() => e.dispose()) } _evaluateActiveMeshes() { var e; if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) { this._activeMeshes.length > 0 && ((e = this.activeCamera) === null || e === void 0 || e._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset()); return } if (this._activeMeshesFrozen && this._activeMeshes.length) { if (!this._skipEvaluateActiveMeshesCompletely) { const s = this._activeMeshes.length; for (let r = 0; r < s; r++)this._activeMeshes.data[r].computeWorldMatrix() } if (this._activeParticleSystems) { const s = this._activeParticleSystems.length; for (let r = 0; r < s; r++)this._activeParticleSystems.data[r].animate() } this._renderingManager.resetSprites(); return } if (!this.activeCamera) return; this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this), this.activeCamera._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset(), this._materialsRenderTargets.reset(); for (const s of this._beforeEvaluateActiveMeshStage) s.action(); const t = this.getActiveMeshCandidates(), i = t.length; for (let s = 0; s < i; s++) { const r = t.data[s]; if (r._internalAbstractMeshDataInfo._currentLODIsUpToDate = !1, r.isBlocked || (this._totalVertices.addCount(r.getTotalVertices(), !1), !r.isReady() || !r.isEnabled() || r.scaling.hasAZeroComponent)) continue; r.computeWorldMatrix(), r.actionManager && r.actionManager.hasSpecificTriggers2(12, 13) && this._meshesForIntersections.pushNoDuplicate(r); let n = this.customLODSelector ? this.customLODSelector(r, this.activeCamera) : r.getLOD(this.activeCamera); if (r._internalAbstractMeshDataInfo._currentLOD = n, r._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0, n != null && (n !== r && n.billboardMode !== 0 && n.computeWorldMatrix(), r._preActivate(), r.isVisible && r.visibility > 0 && r.layerMask & this.activeCamera.layerMask && (this._skipFrustumClipping || r.alwaysSelectAsActiveMesh || r.isInFrustum(this._frustumPlanes)))) { this._activeMeshes.push(r), this.activeCamera._activeMeshes.push(r), n !== r && n._activate(this._renderId, !1); for (const a of this._preActiveMeshStage) a.action(r); r._activate(this._renderId, !1) && (r.isAnInstance ? r._internalAbstractMeshDataInfo._actAsRegularMesh && (n = r) : n._internalAbstractMeshDataInfo._onlyForInstances = !1, n._internalAbstractMeshDataInfo._isActive = !0, this._activeMesh(r, n)), r._postActivate() } } if (this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this), this.particlesEnabled) { this.onBeforeParticlesRenderingObservable.notifyObservers(this); for (let s = 0; s < this.particleSystems.length; s++) { const r = this.particleSystems[s]; if (!r.isStarted() || !r.emitter) continue; const n = r.emitter; (!n.position || n.isEnabled()) && (this._activeParticleSystems.push(r), r.animate(), this._renderingManager.dispatchParticles(r)) } this.onAfterParticlesRenderingObservable.notifyObservers(this) } } _activeMesh(e, t) { this._skeletonsEnabled && t.skeleton !== null && t.skeleton !== void 0 && (this._activeSkeletons.pushNoDuplicate(t.skeleton) && (t.skeleton.prepare(), this._activeBones.addCount(t.skeleton.bones.length, !1)), t.computeBonesUsingShaders || this._softwareSkinnedMeshes.pushNoDuplicate(t)); let i = e.hasInstances || e.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || t.alwaysSelectAsActiveMesh; if (t && t.subMeshes && t.subMeshes.length > 0) { const s = this.getActiveSubMeshCandidates(t), r = s.length; i = i || r === 1; for (let n = 0; n < r; n++) { const a = s.data[n]; this._evaluateSubMesh(a, t, e, i) } } } updateTransformMatrix(e) { const t = this.activeCamera; if (t) if (t._renderingMultiview) { const i = t._rigCameras[0], s = t._rigCameras[1]; this.setTransformMatrix(i.getViewMatrix(), i.getProjectionMatrix(e), s.getViewMatrix(), s.getProjectionMatrix(e)) } else this.setTransformMatrix(t.getViewMatrix(), t.getProjectionMatrix(e)) } _bindFrameBuffer(e, t = !0) { e && e._multiviewTexture ? e._multiviewTexture._bindFrameBuffer() : e && e.outputRenderTarget ? e.outputRenderTarget._bindFrameBuffer() : this._engine._currentFrameBufferIsDefaultFrameBuffer() || this._engine.restoreDefaultFramebuffer(), t && this._clearFrameBuffer(e) } _clearFrameBuffer(e) { if (!(e && e._multiviewTexture)) if (e && e.outputRenderTarget && !e._renderingMultiview) { const t = e.outputRenderTarget; t.onClearObservable.hasObservers() ? t.onClearObservable.notifyObservers(this._engine) : t.skipInitialClear || (this.autoClear && this._engine.clear(t.clearColor || this.clearColor, !t._cleared, !0, !0), t._cleared = !0) } else this._defaultFrameBufferCleared ? this._engine.clear(null, !1, !0, !0) : (this._defaultFrameBufferCleared = !0, this._clear()) } _renderForCamera(e, t, i = !0) { var s, r, n; if (e && e._skipRendering) return; const a = this._engine; if (this._activeCamera = e, !this.activeCamera) throw new Error("Active camera not set"); if (a.setViewport(this.activeCamera.viewport), this.resetCachedMaterial(), this._renderId++, !this.prePass && i) { let l = !0; e._renderingMultiview && e.outputRenderTarget && (l = e.outputRenderTarget.skipInitialClear, this.autoClear && (this._defaultFrameBufferCleared = !1, e.outputRenderTarget.skipInitialClear = !1)), this._bindFrameBuffer(this._activeCamera), e._renderingMultiview && e.outputRenderTarget && (e.outputRenderTarget.skipInitialClear = l) } this.updateTransformMatrix(), this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera), this._evaluateActiveMeshes(); for (let l = 0; l < this._softwareSkinnedMeshes.length; l++) { const h = this._softwareSkinnedMeshes.data[l]; h.applySkeleton(h.skeleton) } this.onBeforeRenderTargetsRenderObservable.notifyObservers(this), this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets), e.customRenderTargets && e.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(e.customRenderTargets), t && t.customRenderTargets && t.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(t.customRenderTargets), this.environmentTexture && this.environmentTexture.isRenderTarget && this._renderTargets.pushNoDuplicate(this.environmentTexture); for (const l of this._gatherActiveCameraRenderTargetsStage) l.action(this._renderTargets); let o = !1; if (this.renderTargetsEnabled) { if (this._intermediateRendering = !0, this._renderTargets.length > 0) { G.StartPerformanceCounter("Render targets", this._renderTargets.length > 0); for (let l = 0; l < this._renderTargets.length; l++) { const h = this._renderTargets.data[l]; if (h._shouldRender()) { this._renderId++; const u = h.activeCamera && h.activeCamera !== this.activeCamera; h.render(u, this.dumpNextRenderTargets), o = !0 } } G.EndPerformanceCounter("Render targets", this._renderTargets.length > 0), this._renderId++ } for (const l of this._cameraDrawRenderTargetStage) o = l.action(this.activeCamera) || o; this._intermediateRendering = !1 } this._engine.currentRenderPassId = (n = (r = (s = e.outputRenderTarget) === null || s === void 0 ? void 0 : s.renderPassId) !== null && r !== void 0 ? r : e.renderPassId) !== null && n !== void 0 ? n : 0, o && !this.prePass && this._bindFrameBuffer(this._activeCamera, !1), this.onAfterRenderTargetsRenderObservable.notifyObservers(this), this.postProcessManager && !e._multiviewTexture && !this.prePass && this.postProcessManager._prepareFrame(); for (const l of this._beforeCameraDrawStage) l.action(this.activeCamera); this.onBeforeDrawPhaseObservable.notifyObservers(this), a.snapshotRendering && a.snapshotRenderingMode === 1 && this.finalizeSceneUbo(), this._renderingManager.render(null, null, !0, !0), this.onAfterDrawPhaseObservable.notifyObservers(this); for (const l of this._afterCameraDrawStage) l.action(this.activeCamera); if (this.postProcessManager && !e._multiviewTexture) { const l = e.outputRenderTarget ? e.outputRenderTarget.renderTarget : void 0; this.postProcessManager._finalizeFrame(e.isIntermediate, l) } for (const l of this._afterCameraPostProcessStage) l.action(this.activeCamera); this._renderTargets.reset(), this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera) } _processSubCameras(e, t = !0) { if (e.cameraRigMode === 0 || e._renderingMultiview) { e._renderingMultiview && !this._multiviewSceneUbo && this._createMultiviewUbo(), this._renderForCamera(e, void 0, t), this.onAfterRenderCameraObservable.notifyObservers(e); return } if (e._useMultiviewToSingleView) this._renderMultiviewToSingleView(e); else { this.onBeforeCameraRenderObservable.notifyObservers(e); for (let i = 0; i < e._rigCameras.length; i++)this._renderForCamera(e._rigCameras[i], e) } this._activeCamera = e, this.updateTransformMatrix(), this.onAfterRenderCameraObservable.notifyObservers(e) } _checkIntersections() { for (let e = 0; e < this._meshesForIntersections.length; e++) { const t = this._meshesForIntersections.data[e]; if (t.actionManager) for (let i = 0; t.actionManager && i < t.actionManager.actions.length; i++) { const s = t.actionManager.actions[i]; if (s.trigger === 12 || s.trigger === 13) { const r = s.getTriggerParameter(), n = r.mesh ? r.mesh : r, a = n.intersectsMesh(t, r.usePreciseIntersection), o = t._intersectionsInProgress.indexOf(n); a && o === -1 ? s.trigger === 12 ? (s._executeCurrent(De.CreateNew(t, void 0, n)), t._intersectionsInProgress.push(n)) : s.trigger === 13 && t._intersectionsInProgress.push(n) : !a && o > -1 && (s.trigger === 13 && s._executeCurrent(De.CreateNew(t, void 0, n)), (!t.actionManager.hasSpecificTrigger(13, l => { const h = l.mesh ? l.mesh : l; return n === h }) || s.trigger === 13) && t._intersectionsInProgress.splice(o, 1)) } } } } _advancePhysicsEngineStep(e) { } _animate() { } animate() { if (this._engine.isDeterministicLockStep()) { let e = Math.max(Le.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Le.MaxDeltaTime)) + this._timeAccumulator; const t = this._engine.getTimeStep(), i = 1e3 / t / 1e3; let s = 0; const r = this._engine.getLockstepMaxSteps(); let n = Math.floor(e / t); for (n = Math.min(n, r); e > 0 && s < n;)this.onBeforeStepObservable.notifyObservers(this), this._animationRatio = t * i, this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this.physicsEnabled && this._advancePhysicsEngineStep(t), this.onAfterStepObservable.notifyObservers(this), this._currentStepId++, s++, e -= t; this._timeAccumulator = e < 0 ? 0 : e } else { const e = this.useConstantAnimationDeltaTime ? 16 : Math.max(Le.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Le.MaxDeltaTime)); this._animationRatio = e * (60 / 1e3), this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this.physicsEnabled && this._advancePhysicsEngineStep(e) } } _clear() { (this.autoClearDepthAndStencil || this.autoClear) && this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil) } _checkCameraRenderTarget(e) { var t; if (e != null && e.outputRenderTarget && !(e != null && e.isRigCamera) && (e.outputRenderTarget._cleared = !1), !((t = e == null ? void 0 : e.rigCameras) === null || t === void 0) && t.length) for (let i = 0; i < e.rigCameras.length; ++i) { const s = e.rigCameras[i].outputRenderTarget; s && (s._cleared = !1) } } resetDrawCache(e) { if (this.meshes) for (const t of this.meshes) t.resetDrawCache(e) } render(e = !0, t = !1) { var i, s, r; if (this.isDisposed) return; this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null && this._checkIsReady(), this._frameId++, this._defaultFrameBufferCleared = !1, this._checkCameraRenderTarget(this.activeCamera), !((i = this.activeCameras) === null || i === void 0) && i.length && this.activeCameras.forEach(this._checkCameraRenderTarget), this._registerTransientComponents(), this._activeParticles.fetchNewFrame(), this._totalVertices.fetchNewFrame(), this._activeIndices.fetchNewFrame(), this._activeBones.fetchNewFrame(), this._meshesForIntersections.reset(), this.resetCachedMaterial(), this.onBeforeAnimationsObservable.notifyObservers(this), this.actionManager && this.actionManager.processTrigger(11), t || this.animate(); for (const o of this._beforeCameraUpdateStage) o.action(); if (e) { if (this.activeCameras && this.activeCameras.length > 0) for (let o = 0; o < this.activeCameras.length; o++) { const l = this.activeCameras[o]; if (l.update(), l.cameraRigMode !== 0) for (let h = 0; h < l._rigCameras.length; h++)l._rigCameras[h].update() } else if (this.activeCamera && (this.activeCamera.update(), this.activeCamera.cameraRigMode !== 0)) for (let o = 0; o < this.activeCamera._rigCameras.length; o++)this.activeCamera._rigCameras[o].update() } this.onBeforeRenderObservable.notifyObservers(this); const n = this.getEngine(); this.onBeforeRenderTargetsRenderObservable.notifyObservers(this); const a = !((s = this.activeCameras) === null || s === void 0) && s.length ? this.activeCameras[0] : this.activeCamera; if (this.renderTargetsEnabled) { G.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._intermediateRendering = !0; for (let o = 0; o < this.customRenderTargets.length; o++) { const l = this.customRenderTargets[o]; if (l._shouldRender()) { if (this._renderId++, this.activeCamera = l.activeCamera || this.activeCamera, !this.activeCamera) throw new Error("Active camera not set"); n.setViewport(this.activeCamera.viewport), this.updateTransformMatrix(), l.render(a !== this.activeCamera, this.dumpNextRenderTargets) } } G.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._intermediateRendering = !1, this._renderId++ } this._engine.currentRenderPassId = (r = a == null ? void 0 : a.renderPassId) !== null && r !== void 0 ? r : 0, this.activeCamera = a, this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass && this._bindFrameBuffer(this._activeCamera, !1), this.onAfterRenderTargetsRenderObservable.notifyObservers(this); for (const o of this._beforeClearStage) o.action(); this._clearFrameBuffer(this.activeCamera); for (const o of this._gatherRenderTargetsStage) o.action(this._renderTargets); if (this.activeCameras && this.activeCameras.length > 0) for (let o = 0; o < this.activeCameras.length; o++)this._processSubCameras(this.activeCameras[o], o > 0); else { if (!this.activeCamera) throw new Error("No camera defined"); this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget) } this._checkIntersections(); for (const o of this._afterRenderStage) o.action(); if (this.afterRender && this.afterRender(), this.onAfterRenderObservable.notifyObservers(this), this._toBeDisposed.length) { for (let o = 0; o < this._toBeDisposed.length; o++) { const l = this._toBeDisposed[o]; l && l.dispose() } this._toBeDisposed.length = 0 } this.dumpNextRenderTargets && (this.dumpNextRenderTargets = !1), this._activeBones.addCount(0, !0), this._activeIndices.addCount(0, !0), this._activeParticles.addCount(0, !0), this._engine.restoreDefaultFramebuffer() } freezeMaterials() { for (let e = 0; e < this.materials.length; e++)this.materials[e].freeze() } unfreezeMaterials() { for (let e = 0; e < this.materials.length; e++)this.materials[e].unfreeze() } dispose() { if (this.isDisposed) return; this.beforeRender = null, this.afterRender = null, this.metadata = null, this.skeletons.length = 0, this.morphTargetManagers.length = 0, this._transientComponents.length = 0, this._isReadyForMeshStage.clear(), this._beforeEvaluateActiveMeshStage.clear(), this._evaluateSubMeshStage.clear(), this._preActiveMeshStage.clear(), this._cameraDrawRenderTargetStage.clear(), this._beforeCameraDrawStage.clear(), this._beforeRenderTargetDrawStage.clear(), this._beforeRenderingGroupDrawStage.clear(), this._beforeRenderingMeshStage.clear(), this._afterRenderingMeshStage.clear(), this._afterRenderingGroupDrawStage.clear(), this._afterCameraDrawStage.clear(), this._afterRenderTargetDrawStage.clear(), this._afterRenderStage.clear(), this._beforeCameraUpdateStage.clear(), this._beforeClearStage.clear(), this._gatherRenderTargetsStage.clear(), this._gatherActiveCameraRenderTargetsStage.clear(), this._pointerMoveStage.clear(), this._pointerDownStage.clear(), this._pointerUpStage.clear(), this.importedMeshesFiles = [], this.stopAllAnimations && (this._activeAnimatables.forEach(r => { r.onAnimationEndObservable.clear(), r.onAnimationEnd = null }), this.stopAllAnimations()), this.resetCachedMaterial(), this.activeCamera && (this.activeCamera._activeMeshes.dispose(), this.activeCamera = null), this.activeCameras = null, this._activeMeshes.dispose(), this._renderingManager.dispose(), this._processedMaterials.dispose(), this._activeParticleSystems.dispose(), this._activeSkeletons.dispose(), this._softwareSkinnedMeshes.dispose(), this._renderTargets.dispose(), this._materialsRenderTargets.dispose(), this._registeredForLateAnimationBindings.dispose(), this._meshesForIntersections.dispose(), this._toBeDisposed.length = 0; const e = this._activeRequests.slice(); for (const r of e) r.abort(); this._activeRequests.length = 0; try { this.onDisposeObservable.notifyObservers(this) } catch (r) { console.error("An error occurred while calling onDisposeObservable!", r) } if (this.detachControl(), this._engine.getInputElement()) for (let r = 0; r < this.cameras.length; r++)this.cameras[r].detachControl(); this._disposeList(this.animationGroups), this._disposeList(this.lights), this._disposeList(this.meshes, r => r.dispose(!0)), this._disposeList(this.transformNodes, r => r.dispose(!0)); const i = this.cameras; this._disposeList(i), this._defaultMaterial && this._defaultMaterial.dispose(), this._disposeList(this.multiMaterials), this._disposeList(this.materials), this._disposeList(this.particleSystems), this._disposeList(this.postProcesses), this._disposeList(this.textures), this._disposeList(this.morphTargetManagers), this._sceneUbo.dispose(), this._multiviewSceneUbo && this._multiviewSceneUbo.dispose(), this.postProcessManager.dispose(), this._disposeList(this._components); let s = this._engine.scenes.indexOf(this); s > -1 && this._engine.scenes.splice(s, 1), ce._LastCreatedScene === this && (this._engine.scenes.length > 0 ? ce._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1] : ce._LastCreatedScene = null), s = this._engine._virtualScenes.indexOf(this), s > -1 && this._engine._virtualScenes.splice(s, 1), this._engine.wipeCaches(!0), this.onDisposeObservable.clear(), this.onBeforeRenderObservable.clear(), this.onAfterRenderObservable.clear(), this.onBeforeRenderTargetsRenderObservable.clear(), this.onAfterRenderTargetsRenderObservable.clear(), this.onAfterStepObservable.clear(), this.onBeforeStepObservable.clear(), this.onBeforeActiveMeshesEvaluationObservable.clear(), this.onAfterActiveMeshesEvaluationObservable.clear(), this.onBeforeParticlesRenderingObservable.clear(), this.onAfterParticlesRenderingObservable.clear(), this.onBeforeDrawPhaseObservable.clear(), this.onAfterDrawPhaseObservable.clear(), this.onBeforeAnimationsObservable.clear(), this.onAfterAnimationsObservable.clear(), this.onDataLoadedObservable.clear(), this.onBeforeRenderingGroupObservable.clear(), this.onAfterRenderingGroupObservable.clear(), this.onMeshImportedObservable.clear(), this.onBeforeCameraRenderObservable.clear(), this.onAfterCameraRenderObservable.clear(), this.onAfterRenderCameraObservable.clear(), this.onReadyObservable.clear(), this.onNewCameraAddedObservable.clear(), this.onCameraRemovedObservable.clear(), this.onNewLightAddedObservable.clear(), this.onLightRemovedObservable.clear(), this.onNewGeometryAddedObservable.clear(), this.onGeometryRemovedObservable.clear(), this.onNewTransformNodeAddedObservable.clear(), this.onTransformNodeRemovedObservable.clear(), this.onNewMeshAddedObservable.clear(), this.onMeshRemovedObservable.clear(), this.onNewSkeletonAddedObservable.clear(), this.onSkeletonRemovedObservable.clear(), this.onNewMaterialAddedObservable.clear(), this.onNewMultiMaterialAddedObservable.clear(), this.onMaterialRemovedObservable.clear(), this.onMultiMaterialRemovedObservable.clear(), this.onNewTextureAddedObservable.clear(), this.onTextureRemovedObservable.clear(), this.onPrePointerObservable.clear(), this.onPointerObservable.clear(), this.onPreKeyboardObservable.clear(), this.onKeyboardObservable.clear(), this.onActiveCameraChanged.clear(), this.onScenePerformancePriorityChangedObservable.clear(), this._isDisposed = !0 } _disposeList(e, t) { const i = e.slice(0); t = t ?? (s => s.dispose()); for (const s of i) t(s); e.length = 0 } get isDisposed() { return this._isDisposed } clearCachedVertexData() { for (let e = 0; e < this.meshes.length; e++) { const i = this.meshes[e].geometry; i && i.clearCachedData() } } cleanCachedTextureBuffer() { for (const e of this.textures) e._buffer && (e._buffer = null) } getWorldExtends(e) { const t = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), i = new g(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE); return e = e || (() => !0), this.meshes.filter(e).forEach(s => { if (s.computeWorldMatrix(!0), !s.subMeshes || s.subMeshes.length === 0 || s.infiniteDistance) return; const r = s.getBoundingInfo(), n = r.boundingBox.minimumWorld, a = r.boundingBox.maximumWorld; g.CheckExtends(n, t, i), g.CheckExtends(a, t, i) }), { min: t, max: i } } createPickingRay(e, t, i, s, r = !1) { throw K("Ray") } createPickingRayToRef(e, t, i, s, r, n = !1, a = !1) { throw K("Ray") } createPickingRayInCameraSpace(e, t, i) { throw K("Ray") } createPickingRayInCameraSpaceToRef(e, t, i, s) { throw K("Ray") } get _pickingAvailable() { return !1 } pick(e, t, i, s, r, n) { const a = K("Ray", !0); return a && O.Warn(a), new ai } pickWithBoundingInfo(e, t, i, s, r) { const n = K("Ray", !0); return n && O.Warn(n), new ai } pickWithRay(e, t, i, s) { throw K("Ray") } multiPick(e, t, i, s, r) { throw K("Ray") } multiPickWithRay(e, t, i) { throw K("Ray") } setPointerOverMesh(e, t, i) { this._inputManager.setPointerOverMesh(e, t, i) } getPointerOverMesh() { return this._inputManager.getPointerOverMesh() } _rebuildGeometries() { for (const e of this.geometries) e._rebuild(); for (const e of this.meshes) e._rebuild(); this.postProcessManager && this.postProcessManager._rebuild(); for (const e of this._components) e.rebuild(); for (const e of this.particleSystems) e.rebuild(); if (this.spriteManagers) for (const e of this.spriteManagers) e.rebuild() } _rebuildTextures() { for (const e of this.textures) e._rebuild(); this.markAllMaterialsAsDirty(1) } _getByTags(e, t, i) { if (t === void 0) return e; const s = []; for (const r in e) { const n = e[r]; ne && ne.MatchesQuery(n, t) && (!i || i(n)) && s.push(n) } return s } getMeshesByTags(e, t) { return this._getByTags(this.meshes, e, t) } getCamerasByTags(e, t) { return this._getByTags(this.cameras, e, t) } getLightsByTags(e, t) { return this._getByTags(this.lights, e, t) } getMaterialByTags(e, t) { return this._getByTags(this.materials, e, t).concat(this._getByTags(this.multiMaterials, e, t)) } getTransformNodesByTags(e, t) { return this._getByTags(this.transformNodes, e, t) } setRenderingOrder(e, t = null, i = null, s = null) { this._renderingManager.setRenderingOrder(e, t, i, s) } setRenderingAutoClearDepthStencil(e, t, i = !0, s = !0) { this._renderingManager.setRenderingAutoClearDepthStencil(e, t, i, s) } getAutoClearDepthStencilSetup(e) { return this._renderingManager.getAutoClearDepthStencilSetup(e) } _forceBlockMaterialDirtyMechanism(e) { this._blockMaterialDirtyMechanism = e } get blockMaterialDirtyMechanism() { return this._blockMaterialDirtyMechanism } set blockMaterialDirtyMechanism(e) { this._blockMaterialDirtyMechanism !== e && (this._blockMaterialDirtyMechanism = e, e || this.markAllMaterialsAsDirty(63)) } markAllMaterialsAsDirty(e, t) { if (!this._blockMaterialDirtyMechanism) for (const i of this.materials) t && !t(i) || i.markAsDirty(e) } _loadFile(e, t, i, s, r, n, a) { const o = Rt(e, t, i, s ? this.offlineProvider : void 0, r, n, a); return this._activeRequests.push(o), o.onCompleteObservable.add(l => { this._activeRequests.splice(this._activeRequests.indexOf(l), 1) }), o } _loadFileAsync(e, t, i, s, r) { return new Promise((n, a) => { this._loadFile(e, o => { n(o) }, t, i, s, (o, l) => { a(l) }, r) }) } _requestFile(e, t, i, s, r, n, a) { const o = ki(e, t, i, s ? this.offlineProvider : void 0, r, n, a); return this._activeRequests.push(o), o.onCompleteObservable.add(l => { this._activeRequests.splice(this._activeRequests.indexOf(l), 1) }), o } _requestFileAsync(e, t, i, s, r) { return new Promise((n, a) => { this._requestFile(e, o => { n(o) }, t, i, s, o => { a(o) }, r) }) } _readFile(e, t, i, s, r) { const n = si(e, t, i, s, r); return this._activeRequests.push(n), n.onCompleteObservable.add(a => { this._activeRequests.splice(this._activeRequests.indexOf(a), 1) }), n } _readFileAsync(e, t, i) { return new Promise((s, r) => { this._readFile(e, n => { s(n) }, t, i, n => { r(n) }) }) } getPerfCollector() { throw K("performanceViewerSceneExtension") } setActiveCameraByID(e) { return this.setActiveCameraById(e) } getMaterialByID(e) { return this.getMaterialById(e) } getLastMaterialByID(e) { return this.getLastMaterialById(e) } getTextureByUniqueID(e) { return this.getTextureByUniqueId(e) } getCameraByID(e) { return this.getCameraById(e) } getCameraByUniqueID(e) { return this.getCameraByUniqueId(e) } getBoneByID(e) { return this.getBoneById(e) } getLightByID(e) { return this.getLightById(e) } getLightByUniqueID(e) { return this.getLightByUniqueId(e) } getParticleSystemByID(e) { return this.getParticleSystemById(e) } getGeometryByID(e) { return this.getGeometryById(e) } getMeshByID(e) { return this.getMeshById(e) } getMeshByUniqueID(e) { return this.getMeshByUniqueId(e) } getLastMeshByID(e) { return this.getLastMeshById(e) } getMeshesByID(e) { return this.getMeshesById(e) } getTransformNodeByID(e) { return this.getTransformNodeById(e) } getTransformNodeByUniqueID(e) { return this.getTransformNodeByUniqueId(e) } getTransformNodesByID(e) { return this.getTransformNodesById(e) } getNodeByID(e) { return this.getNodeById(e) } getLastEntryByID(e) { return this.getLastEntryById(e) } getLastSkeletonByID(e) { return this.getLastSkeletonById(e) } } Le.FOGMODE_NONE = 0, Le.FOGMODE_EXP = 1, Le.FOGMODE_EXP2 = 2, Le.FOGMODE_LINEAR = 3, Le.MinDeltaTime = 1, Le.MaxDeltaTime = 1e3; class Gs { constructor(e, t, i) { this.bu = e, this.bv = t, this.distance = i, this.faceId = 0, this.subMeshId = 0 } } class mt { constructor(e, t, i) { this.vectors = Oe.BuildArray(8, g.Zero), this.center = g.Zero(), this.centerWorld = g.Zero(), this.extendSize = g.Zero(), this.extendSizeWorld = g.Zero(), this.directions = Oe.BuildArray(3, g.Zero), this.vectorsWorld = Oe.BuildArray(8, g.Zero), this.minimumWorld = g.Zero(), this.maximumWorld = g.Zero(), this.minimum = g.Zero(), this.maximum = g.Zero(), this._drawWrapperFront = null, this._drawWrapperBack = null, this.reConstruct(e, t, i) } reConstruct(e, t, i) { const s = e.x, r = e.y, n = e.z, a = t.x, o = t.y, l = t.z, h = this.vectors; this.minimum.copyFromFloats(s, r, n), this.maximum.copyFromFloats(a, o, l), h[0].copyFromFloats(s, r, n), h[1].copyFromFloats(a, o, l), h[2].copyFromFloats(a, r, n), h[3].copyFromFloats(s, o, n), h[4].copyFromFloats(s, r, l), h[5].copyFromFloats(a, o, n), h[6].copyFromFloats(s, o, l), h[7].copyFromFloats(a, r, l), t.addToRef(e, this.center).scaleInPlace(.5), t.subtractToRef(e, this.extendSize).scaleInPlace(.5), this._worldMatrix = i || A.IdentityReadOnly, this._update(this._worldMatrix) } scale(e) { const t = mt._TmpVector3, i = this.maximum.subtractToRef(this.minimum, t[0]), s = i.length(); i.normalizeFromLength(s); const r = s * e, n = i.scaleInPlace(r * .5), a = this.center.subtractToRef(n, t[1]), o = this.center.addToRef(n, t[2]); return this.reConstruct(a, o, this._worldMatrix), this } getWorldMatrix() { return this._worldMatrix } _update(e) { const t = this.minimumWorld, i = this.maximumWorld, s = this.directions, r = this.vectorsWorld, n = this.vectors; if (e.isIdentity()) { t.copyFrom(this.minimum), i.copyFrom(this.maximum); for (let a = 0; a < 8; ++a)r[a].copyFrom(n[a]); this.extendSizeWorld.copyFrom(this.extendSize), this.centerWorld.copyFrom(this.center) } else { t.setAll(Number.MAX_VALUE), i.setAll(-Number.MAX_VALUE); for (let a = 0; a < 8; ++a) { const o = r[a]; g.TransformCoordinatesToRef(n[a], e, o), t.minimizeInPlace(o), i.maximizeInPlace(o) } i.subtractToRef(t, this.extendSizeWorld).scaleInPlace(.5), i.addToRef(t, this.centerWorld).scaleInPlace(.5) } g.FromArrayToRef(e.m, 0, s[0]), g.FromArrayToRef(e.m, 4, s[1]), g.FromArrayToRef(e.m, 8, s[2]), this._worldMatrix = e } isInFrustum(e) { return mt.IsInFrustum(this.vectorsWorld, e) } isCompletelyInFrustum(e) { return mt.IsCompletelyInFrustum(this.vectorsWorld, e) } intersectsPoint(e) { const t = this.minimumWorld, i = this.maximumWorld, s = t.x, r = t.y, n = t.z, a = i.x, o = i.y, l = i.z, h = e.x, u = e.y, f = e.z, _ = -Ie; return !(a - h < _ || _ > h - s || o - u < _ || _ > u - r || l - f < _ || _ > f - n) } intersectsSphere(e) { return mt.IntersectsSphere(this.minimumWorld, this.maximumWorld, e.centerWorld, e.radiusWorld) } intersectsMinMax(e, t) { const i = this.minimumWorld, s = this.maximumWorld, r = i.x, n = i.y, a = i.z, o = s.x, l = s.y, h = s.z, u = e.x, f = e.y, _ = e.z, p = t.x, v = t.y, E = t.z; return !(o < u || r > p || l < f || n > v || h < _ || a > E) } dispose() { var e, t; (e = this._drawWrapperFront) === null || e === void 0 || e.dispose(), (t = this._drawWrapperBack) === null || t === void 0 || t.dispose() } static Intersects(e, t) { return e.intersectsMinMax(t.minimumWorld, t.maximumWorld) } static IntersectsSphere(e, t, i, s) { const r = mt._TmpVector3[0]; return g.ClampToRef(i, e, t, r), g.DistanceSquared(i, r) <= s * s } static IsCompletelyInFrustum(e, t) { for (let i = 0; i < 6; ++i) { const s = t[i]; for (let r = 0; r < 8; ++r)if (s.dotCoordinate(e[r]) < 0) return !1 } return !0 } static IsInFrustum(e, t) { for (let i = 0; i < 6; ++i) { let s = !0; const r = t[i]; for (let n = 0; n < 8; ++n)if (r.dotCoordinate(e[n]) >= 0) { s = !1; break } if (s) return !1 } return !0 } } mt._TmpVector3 = Oe.BuildArray(3, g.Zero); class Nt { constructor(e, t, i) { this.center = g.Zero(), this.centerWorld = g.Zero(), this.minimum = g.Zero(), this.maximum = g.Zero(), this.reConstruct(e, t, i) } reConstruct(e, t, i) { this.minimum.copyFrom(e), this.maximum.copyFrom(t); const s = g.Distance(e, t); t.addToRef(e, this.center).scaleInPlace(.5), this.radius = s * .5, this._update(i || A.IdentityReadOnly) } scale(e) { const t = this.radius * e, i = Nt._TmpVector3, s = i[0].setAll(t), r = this.center.subtractToRef(s, i[1]), n = this.center.addToRef(s, i[2]); return this.reConstruct(r, n, this._worldMatrix), this } getWorldMatrix() { return this._worldMatrix } _update(e) { if (e.isIdentity()) this.centerWorld.copyFrom(this.center), this.radiusWorld = this.radius; else { g.TransformCoordinatesToRef(this.center, e, this.centerWorld); const t = Nt._TmpVector3[0]; g.TransformNormalFromFloatsToRef(1, 1, 1, e, t), this.radiusWorld = Math.max(Math.abs(t.x), Math.abs(t.y), Math.abs(t.z)) * this.radius } } isInFrustum(e) { const t = this.centerWorld, i = this.radiusWorld; for (let s = 0; s < 6; s++)if (e[s].dotCoordinate(t) <= -i) return !1; return !0 } isCenterInFrustum(e) { const t = this.centerWorld; for (let i = 0; i < 6; i++)if (e[i].dotCoordinate(t) < 0) return !1; return !0 } intersectsPoint(e) { const t = g.DistanceSquared(this.centerWorld, e); return !(this.radiusWorld * this.radiusWorld < t) } static Intersects(e, t) { const i = g.DistanceSquared(e.centerWorld, t.centerWorld), s = e.radiusWorld + t.radiusWorld; return !(s * s < i) } static CreateFromCenterAndRadius(e, t, i) { this._TmpVector3[0].copyFrom(e), this._TmpVector3[1].copyFromFloats(0, 0, t), this._TmpVector3[2].copyFrom(e), this._TmpVector3[0].addInPlace(this._TmpVector3[1]), this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]); const s = new Nt(this._TmpVector3[0], this._TmpVector3[2]); return i ? s._worldMatrix = i : s._worldMatrix = A.Identity(), s } } Nt._TmpVector3 = Oe.BuildArray(3, g.Zero); const Ki = { min: 0, max: 0 }, Yi = { min: 0, max: 0 }, Xs = (c, e, t) => { const i = g.Dot(e.centerWorld, c), s = Math.abs(g.Dot(e.directions[0], c)) * e.extendSize.x, r = Math.abs(g.Dot(e.directions[1], c)) * e.extendSize.y, n = Math.abs(g.Dot(e.directions[2], c)) * e.extendSize.z, a = s + r + n; t.min = i - a, t.max = i + a }, Ke = (c, e, t) => (Xs(c, e, Ki), Xs(c, t, Yi), !(Ki.min > Yi.max || Yi.min > Ki.max)); class rt { constructor(e, t, i) { this._isLocked = !1, this.boundingBox = new mt(e, t, i), this.boundingSphere = new Nt(e, t, i) } reConstruct(e, t, i) { this.boundingBox.reConstruct(e, t, i), this.boundingSphere.reConstruct(e, t, i) } get minimum() { return this.boundingBox.minimum } get maximum() { return this.boundingBox.maximum } get isLocked() { return this._isLocked } set isLocked(e) { this._isLocked = e } update(e) { this._isLocked || (this.boundingBox._update(e), this.boundingSphere._update(e)) } centerOn(e, t) { const i = rt._TmpVector3[0].copyFrom(e).subtractInPlace(t), s = rt._TmpVector3[1].copyFrom(e).addInPlace(t); return this.boundingBox.reConstruct(i, s, this.boundingBox.getWorldMatrix()), this.boundingSphere.reConstruct(i, s, this.boundingBox.getWorldMatrix()), this } encapsulate(e) { const t = g.Minimize(this.minimum, e), i = g.Maximize(this.maximum, e); return this.reConstruct(t, i, this.boundingBox.getWorldMatrix()), this } encapsulateBoundingInfo(e) { const t = D.Matrix[0]; this.boundingBox.getWorldMatrix().invertToRef(t); const i = D.Vector3[0]; return g.TransformCoordinatesToRef(e.boundingBox.minimumWorld, t, i), this.encapsulate(i), g.TransformCoordinatesToRef(e.boundingBox.maximumWorld, t, i), this.encapsulate(i), this } scale(e) { return this.boundingBox.scale(e), this.boundingSphere.scale(e), this } isInFrustum(e, t = 0) { return (t === 2 || t === 3) && this.boundingSphere.isCenterInFrustum(e) ? !0 : this.boundingSphere.isInFrustum(e) ? t === 1 || t === 3 ? !0 : this.boundingBox.isInFrustum(e) : !1 } get diagonalLength() { const e = this.boundingBox; return e.maximumWorld.subtractToRef(e.minimumWorld, rt._TmpVector3[0]).length() } isCompletelyInFrustum(e) { return this.boundingBox.isCompletelyInFrustum(e) } _checkCollision(e) { return e._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld) } intersectsPoint(e) { return !(!this.boundingSphere.centerWorld || !this.boundingSphere.intersectsPoint(e) || !this.boundingBox.intersectsPoint(e)) } intersects(e, t) { if (!Nt.Intersects(this.boundingSphere, e.boundingSphere) || !mt.Intersects(this.boundingBox, e.boundingBox)) return !1; if (!t) return !0; const i = this.boundingBox, s = e.boundingBox; return !(!Ke(i.directions[0], i, s) || !Ke(i.directions[1], i, s) || !Ke(i.directions[2], i, s) || !Ke(s.directions[0], i, s) || !Ke(s.directions[1], i, s) || !Ke(s.directions[2], i, s) || !Ke(g.Cross(i.directions[0], s.directions[0]), i, s) || !Ke(g.Cross(i.directions[0], s.directions[1]), i, s) || !Ke(g.Cross(i.directions[0], s.directions[2]), i, s) || !Ke(g.Cross(i.directions[1], s.directions[0]), i, s) || !Ke(g.Cross(i.directions[1], s.directions[1]), i, s) || !Ke(g.Cross(i.directions[1], s.directions[2]), i, s) || !Ke(g.Cross(i.directions[2], s.directions[0]), i, s) || !Ke(g.Cross(i.directions[2], s.directions[1]), i, s) || !Ke(g.Cross(i.directions[2], s.directions[2]), i, s)) } } rt._TmpVector3 = Oe.BuildArray(2, g.Zero); class Mi { static extractMinAndMaxIndexed(e, t, i, s, r, n) { for (let a = i; a < i + s; a++) { const o = t[a] * 3, l = e[o], h = e[o + 1], u = e[o + 2]; r.minimizeInPlaceFromFloats(l, h, u), n.maximizeInPlaceFromFloats(l, h, u) } } static extractMinAndMax(e, t, i, s, r, n) { for (let a = t, o = t * s; a < t + i; a++, o += s) { const l = e[o], h = e[o + 1], u = e[o + 2]; r.minimizeInPlaceFromFloats(l, h, u), n.maximizeInPlaceFromFloats(l, h, u) } } } T([St.filter((...[c, e]) => !Array.isArray(c) && !Array.isArray(e))], Mi, "extractMinAndMaxIndexed", null), T([St.filter((...[c]) => !Array.isArray(c))], Mi, "extractMinAndMax", null); function tn(c, e, t, i, s = null) { const r = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n = new g(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE); return Mi.extractMinAndMaxIndexed(c, e, t, i, r, n), s && (r.x -= r.x * s.x + s.y, r.y -= r.y * s.x + s.y, r.z -= r.z * s.x + s.y, n.x += n.x * s.x + s.y, n.y += n.y * s.x + s.y, n.z += n.z * s.x + s.y), { minimum: r, maximum: n } } function zs(c, e, t, i = null, s) { const r = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n = new g(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE); return s || (s = 3), Mi.extractMinAndMax(c, e, t, s, r, n), i && (r.x -= r.x * i.x + i.y, r.y -= r.y * i.x + i.y, r.z -= r.z * i.x + i.y, n.x += n.x * i.x + i.y, n.y += n.y * i.x + i.y, n.z += n.z * i.x + i.y), { minimum: r, maximum: n } } class nt { get materialDefines() { var e; return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (e = this._getDrawWrapper()) === null || e === void 0 ? void 0 : e.defines } set materialDefines(e) { var t; const i = (t = this._mainDrawWrapperOverride) !== null && t !== void 0 ? t : this._getDrawWrapper(void 0, !0); i.defines = e } _getDrawWrapper(e, t = !1) { e = e ?? this._engine.currentRenderPassId; let i = this._drawWrappers[e]; return !i && t && (this._drawWrappers[e] = i = new Li(this._mesh.getScene().getEngine())), i } _removeDrawWrapper(e, t = !0) { var i; t && ((i = this._drawWrappers[e]) === null || i === void 0 || i.dispose()), this._drawWrappers[e] = void 0 } get effect() { var e, t; return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (t = (e = this._getDrawWrapper()) === null || e === void 0 ? void 0 : e.effect) !== null && t !== void 0 ? t : null } get _drawWrapper() { var e; return (e = this._mainDrawWrapperOverride) !== null && e !== void 0 ? e : this._getDrawWrapper(void 0, !0) } get _drawWrapperOverride() { return this._mainDrawWrapperOverride } _setMainDrawWrapperOverride(e) { this._mainDrawWrapperOverride = e } setEffect(e, t = null, i, s = !0) { const r = this._drawWrapper; r.setEffect(e, t, s), i !== void 0 && (r.materialContext = i), e || (r.defines = null, r.materialContext = void 0) } resetDrawCache(e) { if (this._drawWrappers) if (e !== void 0) { this._removeDrawWrapper(e); return } else for (const t of this._drawWrappers) t == null || t.dispose(); this._drawWrappers = [] } static AddToMesh(e, t, i, s, r, n, a, o = !0) { return new nt(e, t, i, s, r, n, a, o) } constructor(e, t, i, s, r, n, a, o = !0, l = !0) { this.materialIndex = e, this.verticesStart = t, this.verticesCount = i, this.indexStart = s, this.indexCount = r, this._mainDrawWrapperOverride = null, this._linesIndexCount = 0, this._linesIndexBuffer = null, this._lastColliderWorldVertices = null, this._lastColliderTransformMatrix = null, this._wasDispatched = !1, this._renderId = 0, this._alphaIndex = 0, this._distanceToCamera = 0, this._currentMaterial = null, this._mesh = n, this._renderingMesh = a || n, l && n.subMeshes.push(this), this._engine = this._mesh.getScene().getEngine(), this.resetDrawCache(), this._trianglePlanes = [], this._id = n.subMeshes.length - 1, o && (this.refreshBoundingInfo(), n.computeWorldMatrix(!0)) } get IsGlobal() { return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices() } getBoundingInfo() { return this.IsGlobal || this._mesh.hasThinInstances ? this._mesh.getBoundingInfo() : this._boundingInfo } setBoundingInfo(e) { return this._boundingInfo = e, this } getMesh() { return this._mesh } getRenderingMesh() { return this._renderingMesh } getReplacementMesh() { return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null } getEffectiveMesh() { const e = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null; return e || this._renderingMesh } getMaterial(e = !0) { var t; const i = (t = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && t !== void 0 ? t : this._renderingMesh.material; if (i) { if (this._isMultiMaterial(i)) { const s = i.getSubMaterial(this.materialIndex); return this._currentMaterial !== s && (this._currentMaterial = s, this.resetDrawCache()), s } } else return e ? this._mesh.getScene().defaultMaterial : null; return i } _isMultiMaterial(e) { return e.getSubMaterial !== void 0 } refreshBoundingInfo(e = null) { if (this._lastColliderWorldVertices = null, this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) return this; if (e || (e = this._renderingMesh.getVerticesData(d.PositionKind)), !e) return this._boundingInfo = this._mesh.getBoundingInfo(), this; const t = this._renderingMesh.getIndices(); let i; if (this.indexStart === 0 && this.indexCount === t.length) { const s = this._renderingMesh.getBoundingInfo(); i = { minimum: s.minimum.clone(), maximum: s.maximum.clone() } } else i = tn(e, t, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias); return this._boundingInfo ? this._boundingInfo.reConstruct(i.minimum, i.maximum) : this._boundingInfo = new rt(i.minimum, i.maximum), this } _checkCollision(e) { return this.getBoundingInfo()._checkCollision(e) } updateBoundingInfo(e) { let t = this.getBoundingInfo(); return t || (this.refreshBoundingInfo(), t = this.getBoundingInfo()), t && t.update(e), this } isInFrustum(e) { const t = this.getBoundingInfo(); return t ? t.isInFrustum(e, this._mesh.cullingStrategy) : !1 } isCompletelyInFrustum(e) { const t = this.getBoundingInfo(); return t ? t.isCompletelyInFrustum(e) : !1 } render(e) { return this._renderingMesh.render(this, e, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0), this } _getLinesIndexBuffer(e, t) { if (!this._linesIndexBuffer) { const i = []; for (let s = this.indexStart; s < this.indexStart + this.indexCount; s += 3)i.push(e[s], e[s + 1], e[s + 1], e[s + 2], e[s + 2], e[s]); this._linesIndexBuffer = t.createIndexBuffer(i), this._linesIndexCount = i.length } return this._linesIndexBuffer } canIntersects(e) { const t = this.getBoundingInfo(); return t ? e.intersectsBox(t.boundingBox) : !1 } intersects(e, t, i, s, r) { const n = this.getMaterial(); if (!n) return null; let a = 3, o = !1; switch (n.fillMode) { case 3: case 5: case 6: case 8: return null; case 7: a = 1, o = !0; break }return n.fillMode === 4 ? i.length ? this._intersectLines(e, t, i, this._mesh.intersectionThreshold, s) : this._intersectUnIndexedLines(e, t, i, this._mesh.intersectionThreshold, s) : !i.length && this._mesh._unIndexed ? this._intersectUnIndexedTriangles(e, t, i, s, r) : this._intersectTriangles(e, t, i, a, o, s, r) } _intersectLines(e, t, i, s, r) { let n = null; for (let a = this.indexStart; a < this.indexStart + this.indexCount; a += 2) { const o = t[i[a]], l = t[i[a + 1]], h = e.intersectionSegment(o, l, s); if (!(h < 0) && (r || !n || h < n.distance) && (n = new Gs(null, null, h), n.faceId = a / 2, r)) break } return n } _intersectUnIndexedLines(e, t, i, s, r) { let n = null; for (let a = this.verticesStart; a < this.verticesStart + this.verticesCount; a += 2) { const o = t[a], l = t[a + 1], h = e.intersectionSegment(o, l, s); if (!(h < 0) && (r || !n || h < n.distance) && (n = new Gs(null, null, h), n.faceId = a / 2, r)) break } return n } _intersectTriangles(e, t, i, s, r, n, a) { let o = null, l = -1; for (let h = this.indexStart; h < this.indexStart + this.indexCount - (3 - s); h += s) { l++; const u = i[h], f = i[h + 1], _ = i[h + 2]; if (r && _ === 4294967295) { h += 2; continue } const p = t[u], v = t[f], E = t[_]; if (!p || !v || !E || a && !a(p, v, E, e, u, f, _)) continue; const m = e.intersectsTriangle(p, v, E); if (m) { if (m.distance < 0) continue; if ((n || !o || m.distance < o.distance) && (o = m, o.faceId = l, n)) break } } return o } _intersectUnIndexedTriangles(e, t, i, s, r) { let n = null; for (let a = this.verticesStart; a < this.verticesStart + this.verticesCount; a += 3) { const o = t[a], l = t[a + 1], h = t[a + 2]; if (r && !r(o, l, h, e, -1, -1, -1)) continue; const u = e.intersectsTriangle(o, l, h); if (u) { if (u.distance < 0) continue; if ((s || !n || u.distance < n.distance) && (n = u, n.faceId = a / 3, s)) break } } return n } _rebuild() { this._linesIndexBuffer && (this._linesIndexBuffer = null) } clone(e, t) { const i = new nt(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, e, t, !1); if (!this.IsGlobal) { const s = this.getBoundingInfo(); if (!s) return i; i._boundingInfo = new rt(s.minimum, s.maximum) } return i } dispose() { this._linesIndexBuffer && (this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer), this._linesIndexBuffer = null); const e = this._mesh.subMeshes.indexOf(this); this._mesh.subMeshes.splice(e, 1), this.resetDrawCache() } getClassName() { return "SubMesh" } static CreateFromIndices(e, t, i, s, r, n = !0) { let a = Number.MAX_VALUE, o = -Number.MAX_VALUE; const h = (r || s).getIndices(); for (let u = t; u < t + i; u++) { const f = h[u]; f < a && (a = f), f > o && (o = f) } return new nt(e, a, o - a + 1, t, i, s, r, n) } } class qi { } class Y { constructor() { this.uniqueId = 0, this.metadata = {}, this._applyTo = Yr(this._applyToCoroutine.bind(this)), this.uniqueId = Y._UniqueIDGenerator, Y._UniqueIDGenerator++ } set(e, t) { switch (e.length || O.Warn(`Setting vertex data kind '${t}' with an empty array`), t) { case d.PositionKind: this.positions = e; break; case d.NormalKind: this.normals = e; break; case d.TangentKind: this.tangents = e; break; case d.UVKind: this.uvs = e; break; case d.UV2Kind: this.uvs2 = e; break; case d.UV3Kind: this.uvs3 = e; break; case d.UV4Kind: this.uvs4 = e; break; case d.UV5Kind: this.uvs5 = e; break; case d.UV6Kind: this.uvs6 = e; break; case d.ColorKind: this.colors = e; break; case d.MatricesIndicesKind: this.matricesIndices = e; break; case d.MatricesWeightsKind: this.matricesWeights = e; break; case d.MatricesIndicesExtraKind: this.matricesIndicesExtra = e; break; case d.MatricesWeightsExtraKind: this.matricesWeightsExtra = e; break } } applyToMesh(e, t) { return this._applyTo(e, t, !1), this } applyToGeometry(e, t) { return this._applyTo(e, t, !1), this } updateMesh(e) { return this._update(e), this } updateGeometry(e) { return this._update(e), this } *_applyToCoroutine(e, t = !1, i) { if (this.positions && (e.setVerticesData(d.PositionKind, this.positions, t), i && (yield)), this.normals && (e.setVerticesData(d.NormalKind, this.normals, t), i && (yield)), this.tangents && (e.setVerticesData(d.TangentKind, this.tangents, t), i && (yield)), this.uvs && (e.setVerticesData(d.UVKind, this.uvs, t), i && (yield)), this.uvs2 && (e.setVerticesData(d.UV2Kind, this.uvs2, t), i && (yield)), this.uvs3 && (e.setVerticesData(d.UV3Kind, this.uvs3, t), i && (yield)), this.uvs4 && (e.setVerticesData(d.UV4Kind, this.uvs4, t), i && (yield)), this.uvs5 && (e.setVerticesData(d.UV5Kind, this.uvs5, t), i && (yield)), this.uvs6 && (e.setVerticesData(d.UV6Kind, this.uvs6, t), i && (yield)), this.colors && (e.setVerticesData(d.ColorKind, this.colors, t), i && (yield)), this.matricesIndices && (e.setVerticesData(d.MatricesIndicesKind, this.matricesIndices, t), i && (yield)), this.matricesWeights && (e.setVerticesData(d.MatricesWeightsKind, this.matricesWeights, t), i && (yield)), this.matricesIndicesExtra && (e.setVerticesData(d.MatricesIndicesExtraKind, this.matricesIndicesExtra, t), i && (yield)), this.matricesWeightsExtra && (e.setVerticesData(d.MatricesWeightsExtraKind, this.matricesWeightsExtra, t), i && (yield)), this.indices ? (e.setIndices(this.indices, null, t), i && (yield)) : e.setIndices([], null), e.subMeshes && this.materialInfos && this.materialInfos.length > 1) { const s = e; s.subMeshes = []; for (const r of this.materialInfos) new nt(r.materialIndex, r.verticesStart, r.verticesCount, r.indexStart, r.indexCount, s) } return this } _update(e, t, i) { return this.positions && e.updateVerticesData(d.PositionKind, this.positions, t, i), this.normals && e.updateVerticesData(d.NormalKind, this.normals, t, i), this.tangents && e.updateVerticesData(d.TangentKind, this.tangents, t, i), this.uvs && e.updateVerticesData(d.UVKind, this.uvs, t, i), this.uvs2 && e.updateVerticesData(d.UV2Kind, this.uvs2, t, i), this.uvs3 && e.updateVerticesData(d.UV3Kind, this.uvs3, t, i), this.uvs4 && e.updateVerticesData(d.UV4Kind, this.uvs4, t, i), this.uvs5 && e.updateVerticesData(d.UV5Kind, this.uvs5, t, i), this.uvs6 && e.updateVerticesData(d.UV6Kind, this.uvs6, t, i), this.colors && e.updateVerticesData(d.ColorKind, this.colors, t, i), this.matricesIndices && e.updateVerticesData(d.MatricesIndicesKind, this.matricesIndices, t, i), this.matricesWeights && e.updateVerticesData(d.MatricesWeightsKind, this.matricesWeights, t, i), this.matricesIndicesExtra && e.updateVerticesData(d.MatricesIndicesExtraKind, this.matricesIndicesExtra, t, i), this.matricesWeightsExtra && e.updateVerticesData(d.MatricesWeightsExtraKind, this.matricesWeightsExtra, t, i), this.indices && e.setIndices(this.indices, null), this } static _TransformVector3Coordinates(e, t, i = 0, s = e.length) { const r = D.Vector3[0], n = D.Vector3[1]; for (let a = i; a < i + s; a += 3)g.FromArrayToRef(e, a, r), g.TransformCoordinatesToRef(r, t, n), e[a] = n.x, e[a + 1] = n.y, e[a + 2] = n.z } static _TransformVector3Normals(e, t, i = 0, s = e.length) { const r = D.Vector3[0], n = D.Vector3[1]; for (let a = i; a < i + s; a += 3)g.FromArrayToRef(e, a, r), g.TransformNormalToRef(r, t, n), e[a] = n.x, e[a + 1] = n.y, e[a + 2] = n.z } static _TransformVector4Normals(e, t, i = 0, s = e.length) { const r = D.Vector4[0], n = D.Vector4[1]; for (let a = i; a < i + s; a += 4)ve.FromArrayToRef(e, a, r), ve.TransformNormalToRef(r, t, n), e[a] = n.x, e[a + 1] = n.y, e[a + 2] = n.z, e[a + 3] = n.w } static _FlipFaces(e, t = 0, i = e.length) { for (let s = t; s < t + i; s += 3) { const r = e[s + 1]; e[s + 1] = e[s + 2], e[s + 2] = r } } transform(e) { const t = e.determinant() < 0; return this.positions && Y._TransformVector3Coordinates(this.positions, e), this.normals && Y._TransformVector3Normals(this.normals, e), this.tangents && Y._TransformVector4Normals(this.tangents, e), t && this.indices && Y._FlipFaces(this.indices), this } splitBasedOnMaterialID() { if (!this.materialInfos || this.materialInfos.length < 2) return [this]; const e = []; for (const t of this.materialInfos) { const i = new Y; if (this.positions && (i.positions = this.positions.slice(t.verticesStart * 3, (t.verticesCount + t.verticesStart) * 3)), this.normals && (i.normals = this.normals.slice(t.verticesStart * 3, (t.verticesCount + t.verticesStart) * 3)), this.tangents && (i.tangents = this.tangents.slice(t.verticesStart * 4, (t.verticesCount + t.verticesStart) * 4)), this.colors && (i.colors = this.colors.slice(t.verticesStart * 4, (t.verticesCount + t.verticesStart) * 4)), this.uvs && (i.uvs = this.uvs.slice(t.verticesStart * 2, (t.verticesCount + t.verticesStart) * 2)), this.uvs2 && (i.uvs2 = this.uvs2.slice(t.verticesStart * 2, (t.verticesCount + t.verticesStart) * 2)), this.uvs3 && (i.uvs3 = this.uvs3.slice(t.verticesStart * 2, (t.verticesCount + t.verticesStart) * 2)), this.uvs4 && (i.uvs4 = this.uvs4.slice(t.verticesStart * 2, (t.verticesCount + t.verticesStart) * 2)), this.uvs5 && (i.uvs5 = this.uvs5.slice(t.verticesStart * 2, (t.verticesCount + t.verticesStart) * 2)), this.uvs6 && (i.uvs6 = this.uvs6.slice(t.verticesStart * 2, (t.verticesCount + t.verticesStart) * 2)), this.matricesIndices && (i.matricesIndices = this.matricesIndices.slice(t.verticesStart * 4, (t.verticesCount + t.verticesStart) * 4)), this.matricesIndicesExtra && (i.matricesIndicesExtra = this.matricesIndicesExtra.slice(t.verticesStart * 4, (t.verticesCount + t.verticesStart) * 4)), this.matricesWeights && (i.matricesWeights = this.matricesWeights.slice(t.verticesStart * 4, (t.verticesCount + t.verticesStart) * 4)), this.matricesWeightsExtra && (i.matricesWeightsExtra = this.matricesWeightsExtra.slice(t.verticesStart * 4, (t.verticesCount + t.verticesStart) * 4)), this.indices) { i.indices = []; for (let r = t.indexStart; r < t.indexStart + t.indexCount; r++)i.indices.push(this.indices[r] - t.verticesStart) } const s = new qi; s.indexStart = 0, s.indexCount = i.indices ? i.indices.length : 0, s.materialIndex = t.materialIndex, s.verticesStart = 0, s.verticesCount = (i.positions ? i.positions.length : 0) / 3, i.materialInfos = [s], e.push(i) } return e } merge(e, t = !1, i = !1, s = !1, r = !1) { const n = Array.isArray(e) ? e.map(a => ({ vertexData: a })) : [{ vertexData: e }]; return Xi(this._mergeCoroutine(void 0, n, t, !1, i, s, r)) } *_mergeCoroutine(e, t, i = !1, s, r, n = !1, a = !1) { var o, l, h, u; this._validate(); let f = t.map(m => m.vertexData), _ = this; if (a) for (const m of f) m && (m._validate(), !this.normals && m.normals && (this.normals = new Float32Array(this.positions.length)), !this.tangents && m.tangents && (this.tangents = new Float32Array(this.positions.length / 3 * 4)), !this.uvs && m.uvs && (this.uvs = new Float32Array(this.positions.length / 3 * 2)), !this.uvs2 && m.uvs2 && (this.uvs2 = new Float32Array(this.positions.length / 3 * 2)), !this.uvs3 && m.uvs3 && (this.uvs3 = new Float32Array(this.positions.length / 3 * 2)), !this.uvs4 && m.uvs4 && (this.uvs4 = new Float32Array(this.positions.length / 3 * 2)), !this.uvs5 && m.uvs5 && (this.uvs5 = new Float32Array(this.positions.length / 3 * 2)), !this.uvs6 && m.uvs6 && (this.uvs6 = new Float32Array(this.positions.length / 3 * 2)), !this.colors && m.colors && (this.colors = new Float32Array(this.positions.length / 3 * 4), this.colors.fill(1)), !this.matricesIndices && m.matricesIndices && (this.matricesIndices = new Float32Array(this.positions.length / 3 * 4)), !this.matricesWeights && m.matricesWeights && (this.matricesWeights = new Float32Array(this.positions.length / 3 * 4)), !this.matricesIndicesExtra && m.matricesIndicesExtra && (this.matricesIndicesExtra = new Float32Array(this.positions.length / 3 * 4)), !this.matricesWeightsExtra && m.matricesWeightsExtra && (this.matricesWeightsExtra = new Float32Array(this.positions.length / 3 * 4))); for (const m of f) if (m) { if (a) this.normals && !m.normals && (m.normals = new Float32Array(m.positions.length)), this.tangents && !m.tangents && (m.tangents = new Float32Array(m.positions.length / 3 * 4)), this.uvs && !m.uvs && (m.uvs = new Float32Array(m.positions.length / 3 * 2)), this.uvs2 && !m.uvs2 && (m.uvs2 = new Float32Array(m.positions.length / 3 * 2)), this.uvs3 && !m.uvs3 && (m.uvs3 = new Float32Array(m.positions.length / 3 * 2)), this.uvs4 && !m.uvs4 && (m.uvs4 = new Float32Array(m.positions.length / 3 * 2)), this.uvs5 && !m.uvs5 && (m.uvs5 = new Float32Array(m.positions.length / 3 * 2)), this.uvs6 && !m.uvs6 && (m.uvs6 = new Float32Array(m.positions.length / 3 * 2)), this.colors && !m.colors && (m.colors = new Float32Array(m.positions.length / 3 * 4), m.colors.fill(1)), this.matricesIndices && !m.matricesIndices && (m.matricesIndices = new Float32Array(m.positions.length / 3 * 4)), this.matricesWeights && !m.matricesWeights && (m.matricesWeights = new Float32Array(m.positions.length / 3 * 4)), this.matricesIndicesExtra && !m.matricesIndicesExtra && (m.matricesIndicesExtra = new Float32Array(m.positions.length / 3 * 4)), this.matricesWeightsExtra && !m.matricesWeightsExtra && (m.matricesWeightsExtra = new Float32Array(m.positions.length / 3 * 4)); else if (m._validate(), !this.normals != !m.normals || !this.tangents != !m.tangents || !this.uvs != !m.uvs || !this.uvs2 != !m.uvs2 || !this.uvs3 != !m.uvs3 || !this.uvs4 != !m.uvs4 || !this.uvs5 != !m.uvs5 || !this.uvs6 != !m.uvs6 || !this.colors != !m.colors || !this.matricesIndices != !m.matricesIndices || !this.matricesWeights != !m.matricesWeights || !this.matricesIndicesExtra != !m.matricesIndicesExtra || !this.matricesWeightsExtra != !m.matricesWeightsExtra) throw new Error("Cannot merge vertex data that do not have the same set of attributes") } if (n) { let m = 0, x = 0, C = 0; const S = []; let y = null; const b = []; for (const w of this.splitBasedOnMaterialID()) b.push({ vertexData: w, transform: e }); for (const w of t) if (w.vertexData) for (const N of w.vertexData.splitBasedOnMaterialID()) b.push({ vertexData: N, transform: w.transform }); b.sort((w, N) => { const X = w.vertexData.materialInfos ? w.vertexData.materialInfos[0].materialIndex : 0, fe = N.vertexData.materialInfos ? N.vertexData.materialInfos[0].materialIndex : 0; return X > fe ? 1 : X === fe ? 0 : -1 }); for (const w of b) { const N = w.vertexData; if (N.materialInfos ? m = N.materialInfos[0].materialIndex : m = 0, y && y.materialIndex === m) y.indexCount += N.indices.length, y.verticesCount += N.positions.length / 3; else { const X = new qi; X.materialIndex = m, X.indexStart = x, X.indexCount = N.indices.length, X.verticesStart = C, X.verticesCount = N.positions.length / 3, S.push(X), y = X } x += N.indices.length, C += N.positions.length / 3 } const R = b.splice(0, 1)[0]; _ = R.vertexData, e = R.transform, f = b.map(w => w.vertexData), t = b, this.materialInfos = S } const p = f.reduce((m, x) => { var C, S; return m + ((S = (C = x.indices) === null || C === void 0 ? void 0 : C.length) !== null && S !== void 0 ? S : 0) }, (l = (o = _.indices) === null || o === void 0 ? void 0 : o.length) !== null && l !== void 0 ? l : 0); let E = r || f.some(m => m.indices === _.indices) ? (h = _.indices) === null || h === void 0 ? void 0 : h.slice() : _.indices; if (p > 0) { let m = (u = E == null ? void 0 : E.length) !== null && u !== void 0 ? u : 0; if (E || (E = new Array(p)), E.length !== p) { if (Array.isArray(E)) E.length = p; else { const C = i || E instanceof Uint32Array ? new Uint32Array(p) : new Uint16Array(p); C.set(E), E = C } e && e.determinant() < 0 && Y._FlipFaces(E, 0, m) } let x = _.positions ? _.positions.length / 3 : 0; for (const { vertexData: C, transform: S } of t) if (C.indices) { for (let y = 0; y < C.indices.length; y++)E[m + y] = C.indices[y] + x; S && S.determinant() < 0 && Y._FlipFaces(E, m, C.indices.length), x += C.positions.length / 3, m += C.indices.length, s && (yield) } } return this.indices = E, this.positions = Y._MergeElement(d.PositionKind, _.positions, e, t.map(m => [m.vertexData.positions, m.transform])), s && (yield), _.normals && (this.normals = Y._MergeElement(d.NormalKind, _.normals, e, t.map(m => [m.vertexData.normals, m.transform])), s && (yield)), _.tangents && (this.tangents = Y._MergeElement(d.TangentKind, _.tangents, e, t.map(m => [m.vertexData.tangents, m.transform])), s && (yield)), _.uvs && (this.uvs = Y._MergeElement(d.UVKind, _.uvs, e, t.map(m => [m.vertexData.uvs, m.transform])), s && (yield)), _.uvs2 && (this.uvs2 = Y._MergeElement(d.UV2Kind, _.uvs2, e, t.map(m => [m.vertexData.uvs2, m.transform])), s && (yield)), _.uvs3 && (this.uvs3 = Y._MergeElement(d.UV3Kind, _.uvs3, e, t.map(m => [m.vertexData.uvs3, m.transform])), s && (yield)), _.uvs4 && (this.uvs4 = Y._MergeElement(d.UV4Kind, _.uvs4, e, t.map(m => [m.vertexData.uvs4, m.transform])), s && (yield)), _.uvs5 && (this.uvs5 = Y._MergeElement(d.UV5Kind, _.uvs5, e, t.map(m => [m.vertexData.uvs5, m.transform])), s && (yield)), _.uvs6 && (this.uvs6 = Y._MergeElement(d.UV6Kind, _.uvs6, e, t.map(m => [m.vertexData.uvs6, m.transform])), s && (yield)), _.colors && (this.colors = Y._MergeElement(d.ColorKind, _.colors, e, t.map(m => [m.vertexData.colors, m.transform])), s && (yield)), _.matricesIndices && (this.matricesIndices = Y._MergeElement(d.MatricesIndicesKind, _.matricesIndices, e, t.map(m => [m.vertexData.matricesIndices, m.transform])), s && (yield)), _.matricesWeights && (this.matricesWeights = Y._MergeElement(d.MatricesWeightsKind, _.matricesWeights, e, t.map(m => [m.vertexData.matricesWeights, m.transform])), s && (yield)), _.matricesIndicesExtra && (this.matricesIndicesExtra = Y._MergeElement(d.MatricesIndicesExtraKind, _.matricesIndicesExtra, e, t.map(m => [m.vertexData.matricesIndicesExtra, m.transform])), s && (yield)), _.matricesWeightsExtra && (this.matricesWeightsExtra = Y._MergeElement(d.MatricesWeightsExtraKind, _.matricesWeightsExtra, e, t.map(m => [m.vertexData.matricesWeightsExtra, m.transform]))), this } static _MergeElement(e, t, i, s) { const r = s.filter(o => o[0] !== null && o[0] !== void 0); if (!t && r.length == 0) return t; if (!t) return this._MergeElement(e, r[0][0], r[0][1], r.slice(1)); const n = r.reduce((o, l) => o + l[0].length, t.length), a = e === d.PositionKind ? Y._TransformVector3Coordinates : e === d.NormalKind ? Y._TransformVector3Normals : e === d.TangentKind ? Y._TransformVector4Normals : () => { }; if (t instanceof Float32Array) { const o = new Float32Array(n); o.set(t), i && a(o, i, 0, t.length); let l = t.length; for (const [h, u] of r) o.set(h, l), u && a(o, u, l, h.length), l += h.length; return o } else { const o = new Array(n); for (let h = 0; h < t.length; h++)o[h] = t[h]; i && a(o, i, 0, t.length); let l = t.length; for (const [h, u] of r) { for (let f = 0; f < h.length; f++)o[l + f] = h[f]; u && a(o, u, l, h.length), l += h.length } return o } } _validate() { if (!this.positions) throw new zt("Positions are required", gi.MeshInvalidPositionsError); const e = (s, r) => { const n = d.DeduceStride(s); if (r.length % n !== 0) throw new Error("The " + s + "s array count must be a multiple of " + n); return r.length / n }, t = e(d.PositionKind, this.positions), i = (s, r) => { const n = e(s, r); if (n !== t) throw new Error("The " + s + "s element count (" + n + ") does not match the positions count (" + t + ")") }; this.normals && i(d.NormalKind, this.normals), this.tangents && i(d.TangentKind, this.tangents), this.uvs && i(d.UVKind, this.uvs), this.uvs2 && i(d.UV2Kind, this.uvs2), this.uvs3 && i(d.UV3Kind, this.uvs3), this.uvs4 && i(d.UV4Kind, this.uvs4), this.uvs5 && i(d.UV5Kind, this.uvs5), this.uvs6 && i(d.UV6Kind, this.uvs6), this.colors && i(d.ColorKind, this.colors), this.matricesIndices && i(d.MatricesIndicesKind, this.matricesIndices), this.matricesWeights && i(d.MatricesWeightsKind, this.matricesWeights), this.matricesIndicesExtra && i(d.MatricesIndicesExtraKind, this.matricesIndicesExtra), this.matricesWeightsExtra && i(d.MatricesWeightsExtraKind, this.matricesWeightsExtra) } clone() { const e = this.serialize(); return Y.Parse(e) } serialize() { const e = {}; if (this.positions && (e.positions = Array.from(this.positions)), this.normals && (e.normals = Array.from(this.normals)), this.tangents && (e.tangents = Array.from(this.tangents)), this.uvs && (e.uvs = Array.from(this.uvs)), this.uvs2 && (e.uvs2 = Array.from(this.uvs2)), this.uvs3 && (e.uvs3 = Array.from(this.uvs3)), this.uvs4 && (e.uvs4 = Array.from(this.uvs4)), this.uvs5 && (e.uvs5 = Array.from(this.uvs5)), this.uvs6 && (e.uvs6 = Array.from(this.uvs6)), this.colors && (e.colors = Array.from(this.colors)), this.matricesIndices && (e.matricesIndices = Array.from(this.matricesIndices), e.matricesIndices._isExpanded = !0), this.matricesWeights && (e.matricesWeights = Array.from(this.matricesWeights)), this.matricesIndicesExtra && (e.matricesIndicesExtra = Array.from(this.matricesIndicesExtra), e.matricesIndicesExtra._isExpanded = !0), this.matricesWeightsExtra && (e.matricesWeightsExtra = Array.from(this.matricesWeightsExtra)), e.indices = Array.from(this.indices), this.materialInfos) { e.materialInfos = []; for (const t of this.materialInfos) { const i = { indexStart: t.indexStart, indexCount: t.indexCount, materialIndex: t.materialIndex, verticesStart: t.verticesStart, verticesCount: t.verticesCount }; e.materialInfos.push(i) } } return e } static ExtractFromMesh(e, t, i) { return Y._ExtractFrom(e, t, i) } static ExtractFromGeometry(e, t, i) { return Y._ExtractFrom(e, t, i) } static _ExtractFrom(e, t, i) { const s = new Y; return e.isVerticesDataPresent(d.PositionKind) && (s.positions = e.getVerticesData(d.PositionKind, t, i)), e.isVerticesDataPresent(d.NormalKind) && (s.normals = e.getVerticesData(d.NormalKind, t, i)), e.isVerticesDataPresent(d.TangentKind) && (s.tangents = e.getVerticesData(d.TangentKind, t, i)), e.isVerticesDataPresent(d.UVKind) && (s.uvs = e.getVerticesData(d.UVKind, t, i)), e.isVerticesDataPresent(d.UV2Kind) && (s.uvs2 = e.getVerticesData(d.UV2Kind, t, i)), e.isVerticesDataPresent(d.UV3Kind) && (s.uvs3 = e.getVerticesData(d.UV3Kind, t, i)), e.isVerticesDataPresent(d.UV4Kind) && (s.uvs4 = e.getVerticesData(d.UV4Kind, t, i)), e.isVerticesDataPresent(d.UV5Kind) && (s.uvs5 = e.getVerticesData(d.UV5Kind, t, i)), e.isVerticesDataPresent(d.UV6Kind) && (s.uvs6 = e.getVerticesData(d.UV6Kind, t, i)), e.isVerticesDataPresent(d.ColorKind) && (s.colors = e.getVerticesData(d.ColorKind, t, i)), e.isVerticesDataPresent(d.MatricesIndicesKind) && (s.matricesIndices = e.getVerticesData(d.MatricesIndicesKind, t, i)), e.isVerticesDataPresent(d.MatricesWeightsKind) && (s.matricesWeights = e.getVerticesData(d.MatricesWeightsKind, t, i)), e.isVerticesDataPresent(d.MatricesIndicesExtraKind) && (s.matricesIndicesExtra = e.getVerticesData(d.MatricesIndicesExtraKind, t, i)), e.isVerticesDataPresent(d.MatricesWeightsExtraKind) && (s.matricesWeightsExtra = e.getVerticesData(d.MatricesWeightsExtraKind, t, i)), s.indices = e.getIndices(t, i), s } static CreateRibbon(e) { throw K("ribbonBuilder") } static CreateBox(e) { throw K("boxBuilder") } static CreateTiledBox(e) { throw K("tiledBoxBuilder") } static CreateTiledPlane(e) { throw K("tiledPlaneBuilder") } static CreateSphere(e) { throw K("sphereBuilder") } static CreateCylinder(e) { throw K("cylinderBuilder") } static CreateTorus(e) { throw K("torusBuilder") } static CreateLineSystem(e) { throw K("linesBuilder") } static CreateDashedLines(e) { throw K("linesBuilder") } static CreateGround(e) { throw K("groundBuilder") } static CreateTiledGround(e) { throw K("groundBuilder") } static CreateGroundFromHeightMap(e) { throw K("groundBuilder") } static CreatePlane(e) { throw K("planeBuilder") } static CreateDisc(e) { throw K("discBuilder") } static CreatePolygon(e, t, i, s, r, n, a) { throw K("polygonBuilder") } static CreateIcoSphere(e) { throw K("icoSphereBuilder") } static CreatePolyhedron(e) { throw K("polyhedronBuilder") } static CreateCapsule(e = { orientation: g.Up(), subdivisions: 2, tessellation: 16, height: 1, radius: .25, capSubdivisions: 6 }) { throw K("capsuleBuilder") } static CreateTorusKnot(e) { throw K("torusKnotBuilder") } static ComputeNormals(e, t, i, s) { let r = 0, n = 0, a = 0, o = 0, l = 0, h = 0, u = 0, f = 0, _ = 0, p = 0, v = 0, E = 0, m = 0, x = 0, C = 0, S = 0, y = 0, b = 0, R = 0, w = 0, N = !1, X = !1, fe = !1, J = !1, ae = 1, ee = 0, Me = null; s && (N = !!s.facetNormals, X = !!s.facetPositions, fe = !!s.facetPartitioning, ae = s.useRightHandedSystem === !0 ? -1 : 1, ee = s.ratio || 0, J = !!s.depthSort, Me = s.distanceTo, J && Me === void 0 && (Me = g.Zero())); let Ae = 0, Se = 0, xe = 0, Re = 0; for (fe && s && s.bbSize && (Ae = s.subDiv.X * ee / s.bbSize.x, Se = s.subDiv.Y * ee / s.bbSize.y, xe = s.subDiv.Z * ee / s.bbSize.z, Re = s.subDiv.max * s.subDiv.max, s.facetPartitioning.length = 0), r = 0; r < e.length; r++)i[r] = 0; const tt = t.length / 3 | 0; for (r = 0; r < tt; r++) { if (E = t[r * 3] * 3, m = E + 1, x = E + 2, C = t[r * 3 + 1] * 3, S = C + 1, y = C + 2, b = t[r * 3 + 2] * 3, R = b + 1, w = b + 2, n = e[E] - e[C], a = e[m] - e[S], o = e[x] - e[y], l = e[b] - e[C], h = e[R] - e[S], u = e[w] - e[y], f = ae * (a * u - o * h), _ = ae * (o * l - n * u), p = ae * (n * h - a * l), v = Math.sqrt(f * f + _ * _ + p * p), v = v === 0 ? 1 : v, f /= v, _ /= v, p /= v, N && s && (s.facetNormals[r].x = f, s.facetNormals[r].y = _, s.facetNormals[r].z = p), X && s && (s.facetPositions[r].x = (e[E] + e[C] + e[b]) / 3, s.facetPositions[r].y = (e[m] + e[S] + e[R]) / 3, s.facetPositions[r].z = (e[x] + e[y] + e[w]) / 3), fe && s) { const Ze = Math.floor((s.facetPositions[r].x - s.bInfo.minimum.x * ee) * Ae), ft = Math.floor((s.facetPositions[r].y - s.bInfo.minimum.y * ee) * Se), It = Math.floor((s.facetPositions[r].z - s.bInfo.minimum.z * ee) * xe), Ii = Math.floor((e[E] - s.bInfo.minimum.x * ee) * Ae), Pi = Math.floor((e[m] - s.bInfo.minimum.y * ee) * Se), Di = Math.floor((e[x] - s.bInfo.minimum.z * ee) * xe), Qi = Math.floor((e[C] - s.bInfo.minimum.x * ee) * Ae), Ji = Math.floor((e[S] - s.bInfo.minimum.y * ee) * Se), es = Math.floor((e[y] - s.bInfo.minimum.z * ee) * xe), ts = Math.floor((e[b] - s.bInfo.minimum.x * ee) * Ae), is = Math.floor((e[R] - s.bInfo.minimum.y * ee) * Se), ss = Math.floor((e[w] - s.bInfo.minimum.z * ee) * xe), Et = Ii + s.subDiv.max * Pi + Re * Di, bt = Qi + s.subDiv.max * Ji + Re * es, Tt = ts + s.subDiv.max * is + Re * ss, xt = Ze + s.subDiv.max * ft + Re * It; s.facetPartitioning[xt] = s.facetPartitioning[xt] ? s.facetPartitioning[xt] : new Array, s.facetPartitioning[Et] = s.facetPartitioning[Et] ? s.facetPartitioning[Et] : new Array, s.facetPartitioning[bt] = s.facetPartitioning[bt] ? s.facetPartitioning[bt] : new Array, s.facetPartitioning[Tt] = s.facetPartitioning[Tt] ? s.facetPartitioning[Tt] : new Array, s.facetPartitioning[Et].push(r), bt != Et && s.facetPartitioning[bt].push(r), Tt == bt || Tt == Et || s.facetPartitioning[Tt].push(r), xt == Et || xt == bt || xt == Tt || s.facetPartitioning[xt].push(r) } if (J && s && s.facetPositions) { const Ze = s.depthSortedFacets[r]; Ze.ind = r * 3, Ze.sqDistance = g.DistanceSquared(s.facetPositions[r], Me) } i[E] += f, i[m] += _, i[x] += p, i[C] += f, i[S] += _, i[y] += p, i[b] += f, i[R] += _, i[w] += p } for (r = 0; r < i.length / 3; r++)f = i[r * 3], _ = i[r * 3 + 1], p = i[r * 3 + 2], v = Math.sqrt(f * f + _ * _ + p * p), v = v === 0 ? 1 : v, f /= v, _ /= v, p /= v, i[r * 3] = f, i[r * 3 + 1] = _, i[r * 3 + 2] = p } static _ComputeSides(e, t, i, s, r, n, a) { const o = i.length, l = s.length; let h, u; switch (e = e || Y.DEFAULTSIDE, e) { case Y.FRONTSIDE: break; case Y.BACKSIDE: for (h = 0; h < o; h += 3) { const f = i[h]; i[h] = i[h + 2], i[h + 2] = f } for (u = 0; u < l; u++)s[u] = -s[u]; break; case Y.DOUBLESIDE: { const f = t.length, _ = f / 3; for (let E = 0; E < f; E++)t[f + E] = t[E]; for (h = 0; h < o; h += 3)i[h + o] = i[h + 2] + _, i[h + 1 + o] = i[h + 1] + _, i[h + 2 + o] = i[h] + _; for (u = 0; u < l; u++)s[l + u] = -s[u]; const p = r.length; let v = 0; for (v = 0; v < p; v++)r[v + p] = r[v]; for (n = n || new ve(0, 0, 1, 1), a = a || new ve(0, 0, 1, 1), v = 0, h = 0; h < p / 2; h++)r[v] = n.x + (n.z - n.x) * r[v], r[v + 1] = n.y + (n.w - n.y) * r[v + 1], r[v + p] = a.x + (a.z - a.x) * r[v + p], r[v + p + 1] = a.y + (a.w - a.y) * r[v + p + 1], v += 2; break } } } static Parse(e) { const t = new Y, i = e.positions; i && t.set(i, d.PositionKind); const s = e.normals; s && t.set(s, d.NormalKind); const r = e.tangents; r && t.set(r, d.TangentKind); const n = e.uvs; n && t.set(n, d.UVKind); const a = e.uvs2; a && t.set(a, d.UV2Kind); const o = e.uvs3; o && t.set(o, d.UV3Kind); const l = e.uvs4; l && t.set(l, d.UV4Kind); const h = e.uvs5; h && t.set(h, d.UV5Kind); const u = e.uvs6; u && t.set(u, d.UV6Kind); const f = e.colors; f && t.set(de.CheckColors4(f, i.length / 3), d.ColorKind); const _ = e.matricesIndices; _ && t.set(_, d.MatricesIndicesKind); const p = e.matricesWeights; p && t.set(p, d.MatricesWeightsKind); const v = e.indices; v && (t.indices = v); const E = e.materialInfos; if (E) { t.materialInfos = []; for (const m of E) { const x = new qi; x.indexCount = m.indexCount, x.indexStart = m.indexStart, x.verticesCount = m.verticesCount, x.verticesStart = m.verticesStart, x.materialIndex = m.materialIndex, t.materialInfos.push(x) } } return t } static ImportVertexData(e, t) { const i = Y.Parse(e); t.setAllVerticesData(i, e.updatable) } } Y.FRONTSIDE = 0, Y.BACKSIDE = 1, Y.DOUBLESIDE = 2, Y.DEFAULTSIDE = 0, Y._UniqueIDGenerator = 0, T([St.filter((...[c]) => !Array.isArray(c))], Y, "_TransformVector3Coordinates", null), T([St.filter((...[c]) => !Array.isArray(c))], Y, "_TransformVector3Normals", null), T([St.filter((...[c]) => !Array.isArray(c))], Y, "_TransformVector4Normals", null), T([St.filter((...[c]) => !Array.isArray(c))], Y, "_FlipFaces", null); class Ye { static get ForceFullSceneLoadingForIncremental() { return Ye._ForceFullSceneLoadingForIncremental } static set ForceFullSceneLoadingForIncremental(e) { Ye._ForceFullSceneLoadingForIncremental = e } static get ShowLoadingScreen() { return Ye._ShowLoadingScreen } static set ShowLoadingScreen(e) { Ye._ShowLoadingScreen = e } static get loggingLevel() { return Ye._LoggingLevel } static set loggingLevel(e) { Ye._LoggingLevel = e } static get CleanBoneMatrixWeights() { return Ye._CleanBoneMatrixWeights } static set CleanBoneMatrixWeights(e) { Ye._CleanBoneMatrixWeights = e } } Ye._ForceFullSceneLoadingForIncremental = !1, Ye._ShowLoadingScreen = !0, Ye._CleanBoneMatrixWeights = !1, Ye._LoggingLevel = 0; class Qe { } Qe.UseOpenGLOrientationForUV = !1; class Ge { get boundingBias() { return this._boundingBias } set boundingBias(e) { this._boundingBias ? this._boundingBias.copyFrom(e) : this._boundingBias = e.clone(), this._updateBoundingInfo(!0, null) } static CreateGeometryForMesh(e) { const t = new Ge(Ge.RandomId(), e.getScene()); return t.applyToMesh(e), t } get meshes() { return this._meshes } constructor(e, t, i, s = !1, r = null) { this.delayLoadState = 0, this._totalVertices = 0, this._isDisposed = !1, this._indexBufferIsUpdatable = !1, this._positionsCache = [], this._parentContainer = null, this.useBoundingInfoFromGeometry = !1, this._scene = t || ce.LastCreatedScene, this._scene && (this.id = e, this.uniqueId = this._scene.getUniqueId(), this._engine = this._scene.getEngine(), this._meshes = [], this._vertexBuffers = {}, this._indices = [], this._updatable = s, i ? this.setAllVerticesData(i, s) : this._totalVertices = 0, this._engine.getCaps().vertexArrayObject && (this._vertexArrayObjects = {}), r && (this.applyToMesh(r), r.computeWorldMatrix(!0))) } get extend() { return this._extend } getScene() { return this._scene } getEngine() { return this._engine } isReady() { return this.delayLoadState === 1 || this.delayLoadState === 0 } get doNotSerialize() { for (let e = 0; e < this._meshes.length; e++)if (!this._meshes[e].doNotSerialize) return !1; return !0 } _rebuild() { this._vertexArrayObjects && (this._vertexArrayObjects = {}), this._meshes.length !== 0 && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable)); for (const e in this._vertexBuffers) this._vertexBuffers[e]._rebuild() } setAllVerticesData(e, t) { e.applyToGeometry(this, t), this._notifyUpdate() } setVerticesData(e, t, i = !1, s) { i && Array.isArray(t) && (t = new Float32Array(t)); const r = new d(this._engine, t, e, { updatable: i, postponeInternalCreation: this._meshes.length === 0, stride: s, label: "Geometry_" + this.id + "_" + e }); this.setVerticesBuffer(r) } removeVerticesData(e) { this._vertexBuffers[e] && (this._vertexBuffers[e].dispose(), delete this._vertexBuffers[e]), this._vertexArrayObjects && this._disposeVertexArrayObjects() } setVerticesBuffer(e, t = null, i = !0) { const s = e.getKind(); this._vertexBuffers[s] && i && this._vertexBuffers[s].dispose(), e._buffer && e._buffer._increaseReferences(), this._vertexBuffers[s] = e; const r = this._meshes, n = r.length; if (s === d.PositionKind) { this._totalVertices = t ?? e.totalVertices, this._updateExtend(e.getFloatData()), this._resetPointsArrayCache(); const a = this._extend && this._extend.minimum || new g(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), o = this._extend && this._extend.maximum || new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE); for (let l = 0; l < n; l++) { const h = r[l]; h.buildBoundingInfo(a, o), h._createGlobalSubMesh(h.isUnIndexed), h.computeWorldMatrix(!0), h.synchronizeInstances() } } this._notifyUpdate(s) } updateVerticesDataDirectly(e, t, i, s = !1) { const r = this.getVertexBuffer(e); r && (r.updateDirectly(t, i, s), this._notifyUpdate(e)) } updateVerticesData(e, t, i = !1) { const s = this.getVertexBuffer(e); s && (s.update(t), e === d.PositionKind && this._updateBoundingInfo(i, t), this._notifyUpdate(e)) } _updateBoundingInfo(e, t) { if (e && this._updateExtend(t), this._resetPointsArrayCache(), e) { const i = this._meshes; for (const s of i) { s.hasBoundingInfo ? s.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum) : s.buildBoundingInfo(this._extend.minimum, this._extend.maximum); const r = s.subMeshes; for (const n of r) n.refreshBoundingInfo() } } } _bind(e, t, i, s) { if (!e) return; t === void 0 && (t = this._indexBuffer); const r = this.getVertexBuffers(); if (!r) return; if (t != this._indexBuffer || !this._vertexArrayObjects && !s) { this._engine.bindBuffers(r, t, e, i); return } const n = s || this._vertexArrayObjects; n[e.key] || (n[e.key] = this._engine.recordVertexArrayObject(r, t, e, i)), this._engine.bindVertexArrayObject(n[e.key], t) } getTotalVertices() { return this.isReady() ? this._totalVertices : 0 } getVerticesData(e, t, i) { const s = this.getVertexBuffer(e); return s ? s.getFloatData(this._totalVertices, i || t && this._meshes.length !== 1) : null } isVertexBufferUpdatable(e) { const t = this._vertexBuffers[e]; return t ? t.isUpdatable() : !1 } getVertexBuffer(e) { return this.isReady() ? this._vertexBuffers[e] : null } getVertexBuffers() { return this.isReady() ? this._vertexBuffers : null } isVerticesDataPresent(e) { return this._vertexBuffers ? this._vertexBuffers[e] !== void 0 : this._delayInfo ? this._delayInfo.indexOf(e) !== -1 : !1 } getVerticesDataKinds() { const e = []; let t; if (!this._vertexBuffers && this._delayInfo) for (t in this._delayInfo) e.push(t); else for (t in this._vertexBuffers) e.push(t); return e } updateIndices(e, t, i = !1) { if (this._indexBuffer) if (!this._indexBufferIsUpdatable) this.setIndices(e, null, !0); else { const s = e.length !== this._indices.length; if (i || (this._indices = e.slice()), this._engine.updateDynamicIndexBuffer(this._indexBuffer, e, t), s) for (const r of this._meshes) r._createGlobalSubMesh(!0) } } setIndexBuffer(e, t, i) { this._indices = [], this._indexBufferIsUpdatable = !1, this._indexBuffer = e, this._totalVertices = t, this._totalIndices = i, e.is32Bits || (e.is32Bits = this._totalIndices > 65535); for (const s of this._meshes) s._createGlobalSubMesh(!0), s.synchronizeInstances(); this._notifyUpdate() } setIndices(e, t = null, i = !1) { this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indices = e, this._indexBufferIsUpdatable = i, this._meshes.length !== 0 && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, i)), t != null && (this._totalVertices = t); for (const s of this._meshes) s._createGlobalSubMesh(!0), s.synchronizeInstances(); this._notifyUpdate() } getTotalIndices() { return this.isReady() ? this._totalIndices !== void 0 ? this._totalIndices : this._indices.length : 0 } getIndices(e, t) { if (!this.isReady()) return null; const i = this._indices; return !t && (!e || this._meshes.length === 1) ? i : i.slice() } getIndexBuffer() { return this.isReady() ? this._indexBuffer : null } _releaseVertexArrayObject(e = null) { !e || !this._vertexArrayObjects || this._vertexArrayObjects[e.key] && (this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e.key]), delete this._vertexArrayObjects[e.key]) } releaseForMesh(e, t) { const i = this._meshes, s = i.indexOf(e); s !== -1 && (i.splice(s, 1), this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject(), e._geometry = null, i.length === 0 && t && this.dispose()) } applyToMesh(e) { if (e._geometry === this) return; const t = e._geometry; t && t.releaseForMesh(e), this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject(); const i = this._meshes; e._geometry = this, e._internalAbstractMeshDataInfo._positions = null, this._scene.pushGeometry(this), i.push(e), this.isReady() ? this._applyToMesh(e) : this._boundingInfo && e.setBoundingInfo(this._boundingInfo) } _updateExtend(e = null) { if (this.useBoundingInfoFromGeometry && this._boundingInfo) this._extend = { minimum: this._boundingInfo.minimum.clone(), maximum: this._boundingInfo.maximum.clone() }; else { if (!e && (e = this.getVerticesData(d.PositionKind), !e)) return; this._extend = zs(e, 0, this._totalVertices, this.boundingBias, 3) } } _applyToMesh(e) { const t = this._meshes.length; for (const i in this._vertexBuffers) t === 1 && this._vertexBuffers[i].create(), i === d.PositionKind && (this._extend || this._updateExtend(), e.buildBoundingInfo(this._extend.minimum, this._extend.maximum), e._createGlobalSubMesh(e.isUnIndexed), e._updateBoundingInfo()); t === 1 && this._indices && this._indices.length > 0 && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable)), e._syncGeometryWithMorphTargetManager(), e.synchronizeInstances() } _notifyUpdate(e) { this.onGeometryUpdated && this.onGeometryUpdated(this, e), this._vertexArrayObjects && this._disposeVertexArrayObjects(); for (const t of this._meshes) t._markSubMeshesAsAttributesDirty() } load(e, t) { if (this.delayLoadState !== 2) { if (this.isReady()) { t && t(); return } this.delayLoadState = 2, this._queueLoad(e, t) } } _queueLoad(e, t) { this.delayLoadingFile && (e.addPendingData(this), e._loadFile(this.delayLoadingFile, i => { if (!this._delayLoadingFunction) return; this._delayLoadingFunction(JSON.parse(i), this), this.delayLoadState = 1, this._delayInfo = [], e.removePendingData(this); const s = this._meshes, r = s.length; for (let n = 0; n < r; n++)this._applyToMesh(s[n]); t && t() }, void 0, !0)) } toLeftHanded() { const e = this.getIndices(!1); if (e != null && e.length > 0) { for (let s = 0; s < e.length; s += 3) { const r = e[s + 0]; e[s + 0] = e[s + 2], e[s + 2] = r } this.setIndices(e) } const t = this.getVerticesData(d.PositionKind, !1); if (t != null && t.length > 0) { for (let s = 0; s < t.length; s += 3)t[s + 2] = -t[s + 2]; this.setVerticesData(d.PositionKind, t, !1) } const i = this.getVerticesData(d.NormalKind, !1); if (i != null && i.length > 0) { for (let s = 0; s < i.length; s += 3)i[s + 2] = -i[s + 2]; this.setVerticesData(d.NormalKind, i, !1) } } _resetPointsArrayCache() { this._positions = null } _generatePointsArray() { if (this._positions) return !0; const e = this.getVerticesData(d.PositionKind); if (!e || e.length === 0) return !1; for (let t = this._positionsCache.length * 3, i = this._positionsCache.length; t < e.length; t += 3, ++i)this._positionsCache[i] = g.FromArray(e, t); for (let t = 0, i = 0; t < e.length; t += 3, ++i)this._positionsCache[i].set(e[0 + t], e[1 + t], e[2 + t]); return this._positionsCache.length = e.length / 3, this._positions = this._positionsCache, !0 } isDisposed() { return this._isDisposed } _disposeVertexArrayObjects() { if (this._vertexArrayObjects) { for (const i in this._vertexArrayObjects) this._engine.releaseVertexArrayObject(this._vertexArrayObjects[i]); this._vertexArrayObjects = {}; const e = this._meshes, t = e.length; for (let i = 0; i < t; i++)e[i]._invalidateInstanceVertexArrayObject() } } dispose() { const e = this._meshes, t = e.length; let i; for (i = 0; i < t; i++)this.releaseForMesh(e[i]); this._meshes.length = 0, this._disposeVertexArrayObjects(); for (const s in this._vertexBuffers) this._vertexBuffers[s].dispose(); if (this._vertexBuffers = {}, this._totalVertices = 0, this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indexBuffer = null, this._indices = [], this.delayLoadState = 0, this.delayLoadingFile = null, this._delayLoadingFunction = null, this._delayInfo = [], this._boundingInfo = null, this._scene.removeGeometry(this), this._parentContainer) { const s = this._parentContainer.geometries.indexOf(this); s > -1 && this._parentContainer.geometries.splice(s, 1), this._parentContainer = null } this._isDisposed = !0 } copy(e) { const t = new Y; t.indices = []; const i = this.getIndices(); if (i) for (let o = 0; o < i.length; o++)t.indices.push(i[o]); let s = !1, r = !1, n; for (n in this._vertexBuffers) { const o = this.getVerticesData(n); if (o && (o instanceof Float32Array ? t.set(new Float32Array(o), n) : t.set(o.slice(0), n), !r)) { const l = this.getVertexBuffer(n); l && (s = l.isUpdatable(), r = !s) } } const a = new Ge(e, this._scene, t, s); a.delayLoadState = this.delayLoadState, a.delayLoadingFile = this.delayLoadingFile, a._delayLoadingFunction = this._delayLoadingFunction; for (n in this._delayInfo) a._delayInfo = a._delayInfo || [], a._delayInfo.push(n); return a._boundingInfo = new rt(this._extend.minimum, this._extend.maximum), a } serialize() { const e = {}; return e.id = this.id, e.uniqueId = this.uniqueId, e.updatable = this._updatable, ne && ne.HasTags(this) && (e.tags = ne.GetTags(this)), e } _toNumberArray(e) { return Array.isArray(e) ? e : Array.prototype.slice.call(e) } clearCachedData() { this._indices = [], this._resetPointsArrayCache(); for (const e in this._vertexBuffers) Object.prototype.hasOwnProperty.call(this._vertexBuffers, e) && (this._vertexBuffers[e]._buffer._data = null) } serializeVerticeData() { const e = this.serialize(); return this.isVerticesDataPresent(d.PositionKind) && (e.positions = this._toNumberArray(this.getVerticesData(d.PositionKind)), this.isVertexBufferUpdatable(d.PositionKind) && (e.positions._updatable = !0)), this.isVerticesDataPresent(d.NormalKind) && (e.normals = this._toNumberArray(this.getVerticesData(d.NormalKind)), this.isVertexBufferUpdatable(d.NormalKind) && (e.normals._updatable = !0)), this.isVerticesDataPresent(d.TangentKind) && (e.tangents = this._toNumberArray(this.getVerticesData(d.TangentKind)), this.isVertexBufferUpdatable(d.TangentKind) && (e.tangents._updatable = !0)), this.isVerticesDataPresent(d.UVKind) && (e.uvs = this._toNumberArray(this.getVerticesData(d.UVKind)), this.isVertexBufferUpdatable(d.UVKind) && (e.uvs._updatable = !0)), this.isVerticesDataPresent(d.UV2Kind) && (e.uvs2 = this._toNumberArray(this.getVerticesData(d.UV2Kind)), this.isVertexBufferUpdatable(d.UV2Kind) && (e.uvs2._updatable = !0)), this.isVerticesDataPresent(d.UV3Kind) && (e.uvs3 = this._toNumberArray(this.getVerticesData(d.UV3Kind)), this.isVertexBufferUpdatable(d.UV3Kind) && (e.uvs3._updatable = !0)), this.isVerticesDataPresent(d.UV4Kind) && (e.uvs4 = this._toNumberArray(this.getVerticesData(d.UV4Kind)), this.isVertexBufferUpdatable(d.UV4Kind) && (e.uvs4._updatable = !0)), this.isVerticesDataPresent(d.UV5Kind) && (e.uvs5 = this._toNumberArray(this.getVerticesData(d.UV5Kind)), this.isVertexBufferUpdatable(d.UV5Kind) && (e.uvs5._updatable = !0)), this.isVerticesDataPresent(d.UV6Kind) && (e.uvs6 = this._toNumberArray(this.getVerticesData(d.UV6Kind)), this.isVertexBufferUpdatable(d.UV6Kind) && (e.uvs6._updatable = !0)), this.isVerticesDataPresent(d.ColorKind) && (e.colors = this._toNumberArray(this.getVerticesData(d.ColorKind)), this.isVertexBufferUpdatable(d.ColorKind) && (e.colors._updatable = !0)), this.isVerticesDataPresent(d.MatricesIndicesKind) && (e.matricesIndices = this._toNumberArray(this.getVerticesData(d.MatricesIndicesKind)), e.matricesIndices._isExpanded = !0, this.isVertexBufferUpdatable(d.MatricesIndicesKind) && (e.matricesIndices._updatable = !0)), this.isVerticesDataPresent(d.MatricesWeightsKind) && (e.matricesWeights = this._toNumberArray(this.getVerticesData(d.MatricesWeightsKind)), this.isVertexBufferUpdatable(d.MatricesWeightsKind) && (e.matricesWeights._updatable = !0)), e.indices = this._toNumberArray(this.getIndices()), e } static ExtractFromMesh(e, t) { const i = e._geometry; return i ? i.copy(t) : null } static RandomId() { return G.RandomId() } static _GetGeometryByLoadedUniqueId(e, t) { for (let i = 0; i < t.geometries.length; i++)if (t.geometries[i]._loadedUniqueId === e) return t.geometries[i]; return null } static _ImportGeometry(e, t) { const i = t.getScene(), s = e.geometryUniqueId, r = e.geometryId; if (s || r) { const n = s ? this._GetGeometryByLoadedUniqueId(s, i) : i.getGeometryById(r); n && n.applyToMesh(t) } else if (e instanceof ArrayBuffer) { const n = t._binaryInfo; if (n.positionsAttrDesc && n.positionsAttrDesc.count > 0) { const a = new Float32Array(e, n.positionsAttrDesc.offset, n.positionsAttrDesc.count); t.setVerticesData(d.PositionKind, a, !1) } if (n.normalsAttrDesc && n.normalsAttrDesc.count > 0) { const a = new Float32Array(e, n.normalsAttrDesc.offset, n.normalsAttrDesc.count); t.setVerticesData(d.NormalKind, a, !1) } if (n.tangetsAttrDesc && n.tangetsAttrDesc.count > 0) { const a = new Float32Array(e, n.tangetsAttrDesc.offset, n.tangetsAttrDesc.count); t.setVerticesData(d.TangentKind, a, !1) } if (n.uvsAttrDesc && n.uvsAttrDesc.count > 0) { const a = new Float32Array(e, n.uvsAttrDesc.offset, n.uvsAttrDesc.count); if (Qe.UseOpenGLOrientationForUV) for (let o = 1; o < a.length; o += 2)a[o] = 1 - a[o]; t.setVerticesData(d.UVKind, a, !1) } if (n.uvs2AttrDesc && n.uvs2AttrDesc.count > 0) { const a = new Float32Array(e, n.uvs2AttrDesc.offset, n.uvs2AttrDesc.count); if (Qe.UseOpenGLOrientationForUV) for (let o = 1; o < a.length; o += 2)a[o] = 1 - a[o]; t.setVerticesData(d.UV2Kind, a, !1) } if (n.uvs3AttrDesc && n.uvs3AttrDesc.count > 0) { const a = new Float32Array(e, n.uvs3AttrDesc.offset, n.uvs3AttrDesc.count); if (Qe.UseOpenGLOrientationForUV) for (let o = 1; o < a.length; o += 2)a[o] = 1 - a[o]; t.setVerticesData(d.UV3Kind, a, !1) } if (n.uvs4AttrDesc && n.uvs4AttrDesc.count > 0) { const a = new Float32Array(e, n.uvs4AttrDesc.offset, n.uvs4AttrDesc.count); if (Qe.UseOpenGLOrientationForUV) for (let o = 1; o < a.length; o += 2)a[o] = 1 - a[o]; t.setVerticesData(d.UV4Kind, a, !1) } if (n.uvs5AttrDesc && n.uvs5AttrDesc.count > 0) { const a = new Float32Array(e, n.uvs5AttrDesc.offset, n.uvs5AttrDesc.count); if (Qe.UseOpenGLOrientationForUV) for (let o = 1; o < a.length; o += 2)a[o] = 1 - a[o]; t.setVerticesData(d.UV5Kind, a, !1) } if (n.uvs6AttrDesc && n.uvs6AttrDesc.count > 0) { const a = new Float32Array(e, n.uvs6AttrDesc.offset, n.uvs6AttrDesc.count); if (Qe.UseOpenGLOrientationForUV) for (let o = 1; o < a.length; o += 2)a[o] = 1 - a[o]; t.setVerticesData(d.UV6Kind, a, !1) } if (n.colorsAttrDesc && n.colorsAttrDesc.count > 0) { const a = new Float32Array(e, n.colorsAttrDesc.offset, n.colorsAttrDesc.count); t.setVerticesData(d.ColorKind, a, !1, n.colorsAttrDesc.stride) } if (n.matricesIndicesAttrDesc && n.matricesIndicesAttrDesc.count > 0) { const a = new Int32Array(e, n.matricesIndicesAttrDesc.offset, n.matricesIndicesAttrDesc.count), o = []; for (let l = 0; l < a.length; l++) { const h = a[l]; o.push(h & 255), o.push((h & 65280) >> 8), o.push((h & 16711680) >> 16), o.push(h >> 24 & 255) } t.setVerticesData(d.MatricesIndicesKind, o, !1) } if (n.matricesIndicesExtraAttrDesc && n.matricesIndicesExtraAttrDesc.count > 0) { const a = new Int32Array(e, n.matricesIndicesExtraAttrDesc.offset, n.matricesIndicesExtraAttrDesc.count), o = []; for (let l = 0; l < a.length; l++) { const h = a[l]; o.push(h & 255), o.push((h & 65280) >> 8), o.push((h & 16711680) >> 16), o.push(h >> 24 & 255) } t.setVerticesData(d.MatricesIndicesExtraKind, o, !1) } if (n.matricesWeightsAttrDesc && n.matricesWeightsAttrDesc.count > 0) { const a = new Float32Array(e, n.matricesWeightsAttrDesc.offset, n.matricesWeightsAttrDesc.count); t.setVerticesData(d.MatricesWeightsKind, a, !1) } if (n.indicesAttrDesc && n.indicesAttrDesc.count > 0) { const a = new Int32Array(e, n.indicesAttrDesc.offset, n.indicesAttrDesc.count); t.setIndices(a, null) } if (n.subMeshesAttrDesc && n.subMeshesAttrDesc.count > 0) { const a = new Int32Array(e, n.subMeshesAttrDesc.offset, n.subMeshesAttrDesc.count * 5); t.subMeshes = []; for (let o = 0; o < n.subMeshesAttrDesc.count; o++) { const l = a[o * 5 + 0], h = a[o * 5 + 1], u = a[o * 5 + 2], f = a[o * 5 + 3], _ = a[o * 5 + 4]; nt.AddToMesh(l, h, u, f, _, t) } } } else if (e.positions && e.normals && e.indices) { if (t.setVerticesData(d.PositionKind, e.positions, e.positions._updatable), t.setVerticesData(d.NormalKind, e.normals, e.normals._updatable), e.tangents && t.setVerticesData(d.TangentKind, e.tangents, e.tangents._updatable), e.uvs && t.setVerticesData(d.UVKind, e.uvs, e.uvs._updatable), e.uvs2 && t.setVerticesData(d.UV2Kind, e.uvs2, e.uvs2._updatable), e.uvs3 && t.setVerticesData(d.UV3Kind, e.uvs3, e.uvs3._updatable), e.uvs4 && t.setVerticesData(d.UV4Kind, e.uvs4, e.uvs4._updatable), e.uvs5 && t.setVerticesData(d.UV5Kind, e.uvs5, e.uvs5._updatable), e.uvs6 && t.setVerticesData(d.UV6Kind, e.uvs6, e.uvs6._updatable), e.colors && t.setVerticesData(d.ColorKind, de.CheckColors4(e.colors, e.positions.length / 3), e.colors._updatable), e.matricesIndices) if (e.matricesIndices._isExpanded) delete e.matricesIndices._isExpanded, t.setVerticesData(d.MatricesIndicesKind, e.matricesIndices, e.matricesIndices._updatable); else { const n = []; for (let a = 0; a < e.matricesIndices.length; a++) { const o = e.matricesIndices[a]; n.push(o & 255), n.push((o & 65280) >> 8), n.push((o & 16711680) >> 16), n.push(o >> 24 & 255) } t.setVerticesData(d.MatricesIndicesKind, n, e.matricesIndices._updatable) } if (e.matricesIndicesExtra) if (e.matricesIndicesExtra._isExpanded) delete e.matricesIndices._isExpanded, t.setVerticesData(d.MatricesIndicesExtraKind, e.matricesIndicesExtra, e.matricesIndicesExtra._updatable); else { const n = []; for (let a = 0; a < e.matricesIndicesExtra.length; a++) { const o = e.matricesIndicesExtra[a]; n.push(o & 255), n.push((o & 65280) >> 8), n.push((o & 16711680) >> 16), n.push(o >> 24 & 255) } t.setVerticesData(d.MatricesIndicesExtraKind, n, e.matricesIndicesExtra._updatable) } e.matricesWeights && (Ge._CleanMatricesWeights(e, t), t.setVerticesData(d.MatricesWeightsKind, e.matricesWeights, e.matricesWeights._updatable)), e.matricesWeightsExtra && t.setVerticesData(d.MatricesWeightsExtraKind, e.matricesWeightsExtra, e.matricesWeights._updatable), t.setIndices(e.indices, null) } if (e.subMeshes) { t.subMeshes = []; for (let n = 0; n < e.subMeshes.length; n++) { const a = e.subMeshes[n]; nt.AddToMesh(a.materialIndex, a.verticesStart, a.verticesCount, a.indexStart, a.indexCount, t) } } t._shouldGenerateFlatShading && (t.convertToFlatShadedMesh(), t._shouldGenerateFlatShading = !1), t.computeWorldMatrix(!0), i.onMeshImportedObservable.notifyObservers(t) } static _CleanMatricesWeights(e, t) { if (!Ye.CleanBoneMatrixWeights) return; let s = 0; if (e.skeletonId > -1) { const u = t.getScene().getLastSkeletonById(e.skeletonId); if (!u) return; s = u.bones.length } else return; const r = t.getVerticesData(d.MatricesIndicesKind), n = t.getVerticesData(d.MatricesIndicesExtraKind), a = e.matricesWeights, o = e.matricesWeightsExtra, l = e.numBoneInfluencer, h = a.length; for (let u = 0; u < h; u += 4) { let f = 0, _ = -1; for (let p = 0; p < 4; p++) { const v = a[u + p]; f += v, v < .001 && _ < 0 && (_ = p) } if (o) for (let p = 0; p < 4; p++) { const v = o[u + p]; f += v, v < .001 && _ < 0 && (_ = p + 4) } if ((_ < 0 || _ > l - 1) && (_ = l - 1), f > .001) { const p = 1 / f; for (let v = 0; v < 4; v++)a[u + v] *= p; if (o) for (let v = 0; v < 4; v++)o[u + v] *= p } else _ >= 4 ? (o[u + _ - 4] = 1 - f, n[u + _ - 4] = s) : (a[u + _] = 1 - f, r[u + _] = s) } t.setVerticesData(d.MatricesIndicesKind, r), e.matricesWeightsExtra && t.setVerticesData(d.MatricesIndicesExtraKind, n) } static Parse(e, t, i) { const s = new Ge(e.id, t, void 0, e.updatable); return s._loadedUniqueId = e.uniqueId, ne && ne.AddTagsTo(s, e.tags), e.delayLoadingFile ? (s.delayLoadState = 4, s.delayLoadingFile = i + e.delayLoadingFile, s._boundingInfo = new rt(g.FromArray(e.boundingBoxMinimum), g.FromArray(e.boundingBoxMaximum)), s._delayInfo = [], e.hasUVs && s._delayInfo.push(d.UVKind), e.hasUVs2 && s._delayInfo.push(d.UV2Kind), e.hasUVs3 && s._delayInfo.push(d.UV3Kind), e.hasUVs4 && s._delayInfo.push(d.UV4Kind), e.hasUVs5 && s._delayInfo.push(d.UV5Kind), e.hasUVs6 && s._delayInfo.push(d.UV6Kind), e.hasColors && s._delayInfo.push(d.ColorKind), e.hasMatricesIndices && s._delayInfo.push(d.MatricesIndicesKind), e.hasMatricesWeights && s._delayInfo.push(d.MatricesWeightsKind), s._delayLoadingFunction = Y.ImportVertexData) : Y.ImportVertexData(e, s), t.pushGeometry(s, !0), s } } class sn { constructor(e = 30) { this._enabled = !0, this._rollingFrameTime = new rn(e) } sampleFrame(e = wt.Now) { if (this._enabled) { if (this._lastFrameTimeMs != null) { const t = e - this._lastFrameTimeMs; this._rollingFrameTime.add(t) } this._lastFrameTimeMs = e } } get averageFrameTime() { return this._rollingFrameTime.average } get averageFrameTimeVariance() { return this._rollingFrameTime.variance } get instantaneousFrameTime() { return this._rollingFrameTime.history(0) } get averageFPS() { return 1e3 / this._rollingFrameTime.average } get instantaneousFPS() { const e = this._rollingFrameTime.history(0); return e === 0 ? 0 : 1e3 / e } get isSaturated() { return this._rollingFrameTime.isSaturated() } enable() { this._enabled = !0 } disable() { this._enabled = !1, this._lastFrameTimeMs = null } get isEnabled() { return this._enabled } reset() { this._lastFrameTimeMs = null, this._rollingFrameTime.reset() } } class rn { constructor(e) { this._samples = new Array(e), this.reset() } add(e) { let t; if (this.isSaturated()) { const i = this._samples[this._pos]; t = i - this.average, this.average -= t / (this._sampleCount - 1), this._m2 -= t * (i - this.average) } else this._sampleCount++; t = e - this.average, this.average += t / this._sampleCount, this._m2 += t * (e - this.average), this.variance = this._m2 / (this._sampleCount - 1), this._samples[this._pos] = e, this._pos++, this._pos %= this._samples.length } history(e) { if (e >= this._sampleCount || e >= this._samples.length) return 0; const t = this._wrapPosition(this._pos - 1); return this._samples[this._wrapPosition(t - e)] } isSaturated() { return this._sampleCount >= this._samples.length } reset() { this.average = 0, this.variance = 0, this._sampleCount = 0, this._pos = 0, this._m2 = 0 } _wrapPosition(e) { const t = this._samples.length; return (e % t + t) % t } } $.prototype.setAlphaConstants = function (c, e, t, i) { this._alphaState.setAlphaBlendConstants(c, e, t, i) }, $.prototype.setAlphaMode = function (c, e = !1) { if (this._alphaMode === c) { if (!e) { const t = c === 0; this.depthCullingState.depthMask !== t && (this.depthCullingState.depthMask = t) } return } switch (c) { case 0: this._alphaState.alphaBlend = !1; break; case 7: this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0; break; case 8: this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0; break; case 2: this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0; break; case 6: this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0; break; case 1: this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0; break; case 3: this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0; break; case 4: this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0; break; case 5: this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0; break; case 9: this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA), this._alphaState.alphaBlend = !0; break; case 10: this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0; break; case 11: this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0; break; case 12: this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO), this._alphaState.alphaBlend = !0; break; case 13: this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0; break; case 14: this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0; break; case 15: this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO), this._alphaState.alphaBlend = !0; break; case 16: this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0; break; case 17: this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0; break }e || (this.depthCullingState.depthMask = c === 0), this._alphaMode = c }, $.prototype.getAlphaMode = function () { return this._alphaMode }, $.prototype.setAlphaEquation = function (c) { if (this._alphaEquation !== c) { switch (c) { case 0: this._alphaState.setAlphaEquationParameters(32774, 32774); break; case 1: this._alphaState.setAlphaEquationParameters(32778, 32778); break; case 2: this._alphaState.setAlphaEquationParameters(32779, 32779); break; case 3: this._alphaState.setAlphaEquationParameters(32776, 32776); break; case 4: this._alphaState.setAlphaEquationParameters(32775, 32775); break; case 5: this._alphaState.setAlphaEquationParameters(32775, 32774); break }this._alphaEquation = c } }, $.prototype.getAlphaEquation = function () { return this._alphaEquation }; function nn(c, e, t = !1, i) { switch (c) { case 3: { const r = e instanceof ArrayBuffer ? new Int8Array(e) : new Int8Array(e); return i && r.set(new Int8Array(i)), r } case 0: { const r = e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e); return i && r.set(new Uint8Array(i)), r } case 4: { const r = e instanceof ArrayBuffer ? new Int16Array(e) : new Int16Array(t ? e / 2 : e); return i && r.set(new Int16Array(i)), r } case 5: case 8: case 9: case 10: case 2: { const r = e instanceof ArrayBuffer ? new Uint16Array(e) : new Uint16Array(t ? e / 2 : e); return i && r.set(new Uint16Array(i)), r } case 6: { const r = e instanceof ArrayBuffer ? new Int32Array(e) : new Int32Array(t ? e / 4 : e); return i && r.set(new Int32Array(i)), r } case 7: case 11: case 12: case 13: case 14: case 15: { const r = e instanceof ArrayBuffer ? new Uint32Array(e) : new Uint32Array(t ? e / 4 : e); return i && r.set(new Uint32Array(i)), r } case 1: { const r = e instanceof ArrayBuffer ? new Float32Array(e) : new Float32Array(t ? e / 4 : e); return i && r.set(new Float32Array(i)), r } }const s = e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e); return i && s.set(new Uint8Array(i)), s } $.prototype._readTexturePixelsSync = function (c, e, t, i = -1, s = 0, r = null, n = !0, a = !1, o = 0, l = 0) { var h, u; const f = this._gl; if (!f) throw new Error("Engine does not have gl rendering context."); if (!this._dummyFramebuffer) { const p = f.createFramebuffer(); if (!p) throw new Error("Unable to create dummy framebuffer"); this._dummyFramebuffer = p } f.bindFramebuffer(f.FRAMEBUFFER, this._dummyFramebuffer), i > -1 ? f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_CUBE_MAP_POSITIVE_X + i, (h = c._hardwareTexture) === null || h === void 0 ? void 0 : h.underlyingResource, s) : f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, (u = c._hardwareTexture) === null || u === void 0 ? void 0 : u.underlyingResource, s); let _ = c.type !== void 0 ? this._getWebGLTextureType(c.type) : f.UNSIGNED_BYTE; if (a) r || (r = nn(c.type, 4 * e * t)); else switch (_) { case f.UNSIGNED_BYTE: r || (r = new Uint8Array(4 * e * t)), _ = f.UNSIGNED_BYTE; break; default: r || (r = new Float32Array(4 * e * t)), _ = f.FLOAT; break }return n && this.flushFramebuffer(), f.readPixels(o, l, e, t, f.RGBA, _, r), f.bindFramebuffer(f.FRAMEBUFFER, this._currentFramebuffer), r }, $.prototype._readTexturePixels = function (c, e, t, i = -1, s = 0, r = null, n = !0, a = !1, o = 0, l = 0) { return Promise.resolve(this._readTexturePixelsSync(c, e, t, i, s, r, n, a, o, l)) }, $.prototype.updateDynamicIndexBuffer = function (c, e, t = 0) { this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null, this.bindIndexBuffer(c); let i; c.is32Bits ? i = e instanceof Uint32Array ? e : new Uint32Array(e) : i = e instanceof Uint16Array ? e : new Uint16Array(e), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, i, this._gl.DYNAMIC_DRAW), this._resetIndexBufferBinding() }, $.prototype.updateDynamicVertexBuffer = function (c, e, t, i) { this.bindArrayBuffer(c), t === void 0 && (t = 0); const s = e.byteLength || e.length; i === void 0 || i >= s && t === 0 ? e instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, t, new Float32Array(e)) : this._gl.bufferSubData(this._gl.ARRAY_BUFFER, t, e) : e instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(e).subarray(t, t + i)) : (e instanceof ArrayBuffer ? e = new Uint8Array(e, t, i) : e = new Uint8Array(e.buffer, e.byteOffset + t, i), this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e)), this._resetVertexBufferBinding() }; class P extends $ { static get NpmPackage() { return $.NpmPackage } static get Version() { return $.Version } static get Instances() { return ce.Instances } static get LastCreatedEngine() { return ce.LastCreatedEngine } static get LastCreatedScene() { return ce.LastCreatedScene } _createImageBitmapFromSource(e, t) { return new Promise((s, r) => { const n = new Image; n.onload = () => { n.decode().then(() => { this.createImageBitmap(n, t).then(a => { s(a) }) }) }, n.onerror = () => { r(`Error loading image ${n.src}`) }, n.src = e }) } createImageBitmap(e, t) { return createImageBitmap(e, t) } resizeImageBitmap(e, t, i) { const r = this.createCanvas(t, i).getContext("2d"); if (!r) throw new Error("Unable to get 2d context for resizeImageBitmap"); return r.drawImage(e, 0, 0), r.getImageData(0, 0, t, i).data } static MarkAllMaterialsAsDirty(e, t) { for (let i = 0; i < P.Instances.length; i++) { const s = P.Instances[i]; for (let r = 0; r < s.scenes.length; r++)s.scenes[r].markAllMaterialsAsDirty(e, t) } } static DefaultLoadingScreenFactory(e) { throw K("LoadingScreen") } get _supportsHardwareTextureRescaling() { return !!P._RescalePostProcessFactory } get performanceMonitor() { return this._performanceMonitor } get compatibilityMode() { return this._compatibilityMode } set compatibilityMode(e) { this._compatibilityMode = !0 } getInputElement() { return this._renderingCanvas } constructor(e, t, i, s = !1) { if (super(e, t, i, s), this.enableOfflineSupport = !1, this.disableManifestCheck = !1, this.disableContextMenu = !0, this.scenes = [], this._virtualScenes = new Array, this.onNewSceneAddedObservable = new L, this.postProcesses = [], this.isPointerLock = !1, this.onResizeObservable = new L, this.onCanvasBlurObservable = new L, this.onCanvasFocusObservable = new L, this.onCanvasPointerOutObservable = new L, this.onBeginFrameObservable = new L, this.customAnimationFrameRequester = null, this.onEndFrameObservable = new L, this.onBeforeShaderCompilationObservable = new L, this.onAfterShaderCompilationObservable = new L, this._deterministicLockstep = !1, this._lockstepMaxSteps = 4, this._timeStep = 1 / 60, this._fps = 60, this._deltaTime = 0, this._drawCalls = new ct, this.canvasTabIndex = 1, this.disablePerformanceMonitorInBackground = !1, this._performanceMonitor = new sn, this._compatibilityMode = !0, this.currentRenderPassId = 0, this._renderPassNames = ["main"], P.Instances.push(this), !!e && (this._features.supportRenderPasses = !0, i = this._creationOptions, e.getContext)) { const r = e; this._sharedInit(r) } } _initGLContext() { super._initGLContext(), this._rescalePostProcess = null } _sharedInit(e) { super._sharedInit(e), this._onCanvasFocus = () => { this.onCanvasFocusObservable.notifyObservers(this) }, this._onCanvasBlur = () => { this.onCanvasBlurObservable.notifyObservers(this) }, this._onCanvasContextMenu = i => { this.disableContextMenu && i.preventDefault() }, e.addEventListener("focus", this._onCanvasFocus), e.addEventListener("blur", this._onCanvasBlur), e.addEventListener("contextmenu", this._onCanvasContextMenu), this._onBlur = () => { this.disablePerformanceMonitorInBackground && this._performanceMonitor.disable(), this._windowIsBackground = !0 }, this._onFocus = () => { this.disablePerformanceMonitorInBackground && this._performanceMonitor.enable(), this._windowIsBackground = !1 }, this._onCanvasPointerOut = i => { document.elementFromPoint(i.clientX, i.clientY) !== e && this.onCanvasPointerOutObservable.notifyObservers(i) }; const t = this.getHostWindow(); t && typeof t.addEventListener == "function" && (t.addEventListener("blur", this._onBlur), t.addEventListener("focus", this._onFocus)), e.addEventListener("pointerout", this._onCanvasPointerOut), this._creationOptions.doNotHandleTouchAction || this._disableTouchAction(), !P.audioEngine && this._creationOptions.audioEngine && P.AudioEngineFactory && (P.audioEngine = P.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination())), Qt() && (this._onFullscreenChange = () => { this.isFullscreen = !!document.fullscreenElement, this.isFullscreen && this._pointerLockRequested && e && P._RequestPointerlock(e) }, document.addEventListener("fullscreenchange", this._onFullscreenChange, !1), document.addEventListener("webkitfullscreenchange", this._onFullscreenChange, !1), this._onPointerLockChange = () => { this.isPointerLock = document.pointerLockElement === e }, document.addEventListener("pointerlockchange", this._onPointerLockChange, !1), document.addEventListener("webkitpointerlockchange", this._onPointerLockChange, !1)), this.enableOfflineSupport = P.OfflineProviderFactory !== void 0, this._deterministicLockstep = !!this._creationOptions.deterministicLockstep, this._lockstepMaxSteps = this._creationOptions.lockstepMaxSteps || 0, this._timeStep = this._creationOptions.timeStep || 1 / 60 } _verifyPointerLock() { var e; (e = this._onPointerLockChange) === null || e === void 0 || e.call(this) } getAspectRatio(e, t = !1) { const i = e.viewport; return this.getRenderWidth(t) * i.width / (this.getRenderHeight(t) * i.height) } getScreenAspectRatio() { return this.getRenderWidth(!0) / this.getRenderHeight(!0) } getRenderingCanvasClientRect() { return this._renderingCanvas ? this._renderingCanvas.getBoundingClientRect() : null } getInputElementClientRect() { return this._renderingCanvas ? this.getInputElement().getBoundingClientRect() : null } isDeterministicLockStep() { return this._deterministicLockstep } getLockstepMaxSteps() { return this._lockstepMaxSteps } getTimeStep() { return this._timeStep * 1e3 } generateMipMapsForCubemap(e, t = !0) { if (e.generateMipMaps) { const i = this._gl; this._bindTextureDirectly(i.TEXTURE_CUBE_MAP, e, !0), i.generateMipmap(i.TEXTURE_CUBE_MAP), t && this._bindTextureDirectly(i.TEXTURE_CUBE_MAP, null) } } getDepthWrite() { return this._depthCullingState.depthMask } setDepthWrite(e) { this._depthCullingState.depthMask = e } getStencilBuffer() { return this._stencilState.stencilTest } setStencilBuffer(e) { this._stencilState.stencilTest = e } getStencilMask() { return this._stencilState.stencilMask } setStencilMask(e) { this._stencilState.stencilMask = e } getStencilFunction() { return this._stencilState.stencilFunc } getStencilFunctionReference() { return this._stencilState.stencilFuncRef } getStencilFunctionMask() { return this._stencilState.stencilFuncMask } setStencilFunction(e) { this._stencilState.stencilFunc = e } setStencilFunctionReference(e) { this._stencilState.stencilFuncRef = e } setStencilFunctionMask(e) { this._stencilState.stencilFuncMask = e } getStencilOperationFail() { return this._stencilState.stencilOpStencilFail } getStencilOperationDepthFail() { return this._stencilState.stencilOpDepthFail } getStencilOperationPass() { return this._stencilState.stencilOpStencilDepthPass } setStencilOperationFail(e) { this._stencilState.stencilOpStencilFail = e } setStencilOperationDepthFail(e) { this._stencilState.stencilOpDepthFail = e } setStencilOperationPass(e) { this._stencilState.stencilOpStencilDepthPass = e } setDitheringState(e) { e ? this._gl.enable(this._gl.DITHER) : this._gl.disable(this._gl.DITHER) } setRasterizerState(e) { e ? this._gl.disable(this._gl.RASTERIZER_DISCARD) : this._gl.enable(this._gl.RASTERIZER_DISCARD) } getDepthFunction() { return this._depthCullingState.depthFunc } setDepthFunction(e) { this._depthCullingState.depthFunc = e } setDepthFunctionToGreater() { this.setDepthFunction(516) } setDepthFunctionToGreaterOrEqual() { this.setDepthFunction(518) } setDepthFunctionToLess() { this.setDepthFunction(513) } setDepthFunctionToLessOrEqual() { this.setDepthFunction(515) } cacheStencilState() { this._cachedStencilBuffer = this.getStencilBuffer(), this._cachedStencilFunction = this.getStencilFunction(), this._cachedStencilMask = this.getStencilMask(), this._cachedStencilOperationPass = this.getStencilOperationPass(), this._cachedStencilOperationFail = this.getStencilOperationFail(), this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail(), this._cachedStencilReference = this.getStencilFunctionReference() } restoreStencilState() { this.setStencilFunction(this._cachedStencilFunction), this.setStencilMask(this._cachedStencilMask), this.setStencilBuffer(this._cachedStencilBuffer), this.setStencilOperationPass(this._cachedStencilOperationPass), this.setStencilOperationFail(this._cachedStencilOperationFail), this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail), this.setStencilFunctionReference(this._cachedStencilReference) } setDirectViewport(e, t, i, s) { const r = this._cachedViewport; return this._cachedViewport = null, this._viewport(e, t, i, s), r } scissorClear(e, t, i, s, r) { this.enableScissor(e, t, i, s), this.clear(r, !0, !0, !0), this.disableScissor() } enableScissor(e, t, i, s) { const r = this._gl; r.enable(r.SCISSOR_TEST), r.scissor(e, t, i, s) } disableScissor() { const e = this._gl; e.disable(e.SCISSOR_TEST) } _reportDrawCall(e = 1) { this._drawCalls.addCount(e, !1) } _loadFileAsync(e, t, i) { return new Promise((s, r) => { this._loadFile(e, n => { s(n) }, void 0, t, i, (n, a) => { r(a) }) }) } getVertexShaderSource(e) { const t = this._gl.getAttachedShaders(e); return t ? this._gl.getShaderSource(t[0]) : null } getFragmentShaderSource(e) { const t = this._gl.getAttachedShaders(e); return t ? this._gl.getShaderSource(t[1]) : null } setDepthStencilTexture(e, t, i, s) { e !== void 0 && (t && (this._boundUniforms[e] = t), !i || !i.depthStencilTexture ? this._setTexture(e, null, void 0, void 0, s) : this._setTexture(e, i, !1, !0, s)) } setTextureFromPostProcess(e, t, i) { var s; let r = null; t && (t._forcedOutputTexture ? r = t._forcedOutputTexture : t._textures.data[t._currentRenderTextureInd] && (r = t._textures.data[t._currentRenderTextureInd])), this._bindTexture(e, (s = r == null ? void 0 : r.texture) !== null && s !== void 0 ? s : null, i) } setTextureFromPostProcessOutput(e, t, i) { var s, r; this._bindTexture(e, (r = (s = t == null ? void 0 : t._outputTexture) === null || s === void 0 ? void 0 : s.texture) !== null && r !== void 0 ? r : null, i) } _rebuildBuffers() { for (const e of this.scenes) e.resetCachedMaterial(), e._rebuildGeometries(), e._rebuildTextures(); for (const e of this._virtualScenes) e.resetCachedMaterial(), e._rebuildGeometries(), e._rebuildTextures(); super._rebuildBuffers() } _renderFrame() { for (let e = 0; e < this._activeRenderLoops.length; e++) { const t = this._activeRenderLoops[e]; t() } } _cancelFrame() { if (this._renderingQueueLaunched && this.customAnimationFrameRequester) { this._renderingQueueLaunched = !1; const { cancelAnimationFrame: e } = this.customAnimationFrameRequester; e && e(this.customAnimationFrameRequester.requestID) } else super._cancelFrame() } _renderLoop() { if (!this._contextWasLost) { let e = !0; (this.isDisposed || !this.renderEvenInBackground && this._windowIsBackground) && (e = !1), e && (this.beginFrame(), this._renderViews() || this._renderFrame(), this.endFrame()) } this._activeRenderLoops.length > 0 ? this.customAnimationFrameRequester ? (this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester), this._frameHandler = this.customAnimationFrameRequester.requestID) : this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()) : this._renderingQueueLaunched = !1 } _renderViews() { return !1 } switchFullscreen(e) { this.isFullscreen ? this.exitFullscreen() : this.enterFullscreen(e) } enterFullscreen(e) { this.isFullscreen || (this._pointerLockRequested = e, this._renderingCanvas && P._RequestFullscreen(this._renderingCanvas)) } exitFullscreen() { this.isFullscreen && P._ExitFullscreen() } enterPointerlock() { this._renderingCanvas && P._RequestPointerlock(this._renderingCanvas) } exitPointerlock() { P._ExitPointerlock() } beginFrame() { this._measureFps(), this.onBeginFrameObservable.notifyObservers(this), super.beginFrame() } endFrame() { super.endFrame(), this.onEndFrameObservable.notifyObservers(this) } setSize(e, t, i = !1) { if (!this._renderingCanvas || !super.setSize(e, t, i)) return !1; if (this.scenes) { for (let s = 0; s < this.scenes.length; s++) { const r = this.scenes[s]; for (let n = 0; n < r.cameras.length; n++) { const a = r.cameras[n]; a._currentRenderId = 0 } } this.onResizeObservable.hasObservers() && this.onResizeObservable.notifyObservers(this) } return !0 } _deletePipelineContext(e) { const t = e; t && t.program && t.transformFeedback && (this.deleteTransformFeedback(t.transformFeedback), t.transformFeedback = null), super._deletePipelineContext(e) } createShaderProgram(e, t, i, s, r, n = null) { r = r || this._gl, this.onBeforeShaderCompilationObservable.notifyObservers(this); const a = super.createShaderProgram(e, t, i, s, r, n); return this.onAfterShaderCompilationObservable.notifyObservers(this), a } _createShaderProgram(e, t, i, s, r = null) { const n = s.createProgram(); if (e.program = n, !n) throw new Error("Unable to create program"); if (s.attachShader(n, t), s.attachShader(n, i), this.webGLVersion > 1 && r) { const a = this.createTransformFeedback(); this.bindTransformFeedback(a), this.setTranformFeedbackVaryings(n, r), e.transformFeedback = a } return s.linkProgram(n), this.webGLVersion > 1 && r && this.bindTransformFeedback(null), e.context = s, e.vertexShader = t, e.fragmentShader = i, e.isParallelCompiled || this._finalizePipelineContext(e), n } _releaseTexture(e) { super._releaseTexture(e) } _releaseRenderTargetWrapper(e) { super._releaseRenderTargetWrapper(e), this.scenes.forEach(t => { t.postProcesses.forEach(i => { i._outputTexture === e && (i._outputTexture = null) }), t.cameras.forEach(i => { i._postProcesses.forEach(s => { s && s._outputTexture === e && (s._outputTexture = null) }) }) }) } getRenderPassNames() { return this._renderPassNames } getCurrentRenderPassName() { return this._renderPassNames[this.currentRenderPassId] } createRenderPassId(e) { const t = ++P._RenderPassIdCounter; return this._renderPassNames[t] = e ?? "NONAME", t } releaseRenderPassId(e) { this._renderPassNames[e] = void 0; for (let t = 0; t < this.scenes.length; ++t) { const i = this.scenes[t]; for (let s = 0; s < i.meshes.length; ++s) { const r = i.meshes[s]; if (r.subMeshes) for (let n = 0; n < r.subMeshes.length; ++n)r.subMeshes[n]._removeDrawWrapper(e) } } } _rescaleTexture(e, t, i, s, r) { this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE); const n = this.createRenderTargetTexture({ width: t.width, height: t.height }, { generateMipMaps: !1, type: 0, samplingMode: 2, generateDepthBuffer: !1, generateStencilBuffer: !1 }); !this._rescalePostProcess && P._RescalePostProcessFactory && (this._rescalePostProcess = P._RescalePostProcessFactory(this)), this._rescalePostProcess && (this._rescalePostProcess.externalTextureSamplerBinding = !0, this._rescalePostProcess.getEffect().executeWhenCompiled(() => { this._rescalePostProcess.onApply = function (o) { o._bindTexture("textureSampler", e) }; let a = i; a || (a = this.scenes[this.scenes.length - 1]), a.postProcessManager.directRender([this._rescalePostProcess], n, !0), this._bindTextureDirectly(this._gl.TEXTURE_2D, t, !0), this._gl.copyTexImage2D(this._gl.TEXTURE_2D, 0, s, 0, 0, t.width, t.height, 0), this.unBindFramebuffer(n), n.dispose(), r && r() })) } getFps() { return this._fps } getDeltaTime() { return this._deltaTime } _measureFps() { this._performanceMonitor.sampleFrame(), this._fps = this._performanceMonitor.averageFPS, this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0 } wrapWebGLTexture(e, t = !1, i = 3, s = 0, r = 0) { const n = new ms(e, this._gl), a = new Ot(this, Ne.Unknown, !0); return a._hardwareTexture = n, a.baseWidth = s, a.baseHeight = r, a.width = s, a.height = r, a.isReady = !0, a.useMipMaps = t, this.updateTextureSamplingMode(i, a), a } _uploadImageToTexture(e, t, i = 0, s = 0) { const r = this._gl, n = this._getWebGLTextureType(e.type), a = this._getInternalFormat(e.format), o = this._getRGBABufferInternalSizedFormat(e.type, a), l = e.isCube ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D; this._bindTextureDirectly(l, e, !0), this._unpackFlipY(e.invertY); let h = r.TEXTURE_2D; e.isCube && (h = r.TEXTURE_CUBE_MAP_POSITIVE_X + i), r.texImage2D(h, s, o, a, n, t), this._bindTextureDirectly(l, null, !0) } updateTextureComparisonFunction(e, t) { if (this.webGLVersion === 1) { O.Error("WebGL 1 does not support texture comparison."); return } const i = this._gl; e.isCube ? (this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, e, !0), t === 0 ? (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, 515), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, t), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)) : (this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), t === 0 ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, 515), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_2D, null)), e._comparisonFunction = t } createInstancesBuffer(e) { const t = this._gl.createBuffer(); if (!t) throw new Error("Unable to create instance buffer"); const i = new ii(t); return i.capacity = e, this.bindArrayBuffer(i), this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.DYNAMIC_DRAW), i.references = 1, i } deleteInstancesBuffer(e) { this._gl.deleteBuffer(e) } _clientWaitAsync(e, t = 0, i = 10) { const s = this._gl; return new Promise((r, n) => { const a = () => { const o = s.clientWaitSync(e, t, 0); if (o == s.WAIT_FAILED) { n(); return } if (o == s.TIMEOUT_EXPIRED) { setTimeout(a, i); return } r() }; a() }) } _readPixelsAsync(e, t, i, s, r, n, a) { if (this._webGLVersion < 2) throw new Error("_readPixelsAsync only work on WebGL2+"); const o = this._gl, l = o.createBuffer(); o.bindBuffer(o.PIXEL_PACK_BUFFER, l), o.bufferData(o.PIXEL_PACK_BUFFER, a.byteLength, o.STREAM_READ), o.readPixels(e, t, i, s, r, n, 0), o.bindBuffer(o.PIXEL_PACK_BUFFER, null); const h = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0); return h ? (o.flush(), this._clientWaitAsync(h, 0, 10).then(() => (o.deleteSync(h), o.bindBuffer(o.PIXEL_PACK_BUFFER, l), o.getBufferSubData(o.PIXEL_PACK_BUFFER, 0, a), o.bindBuffer(o.PIXEL_PACK_BUFFER, null), o.deleteBuffer(l), a))) : null } dispose() { for (this.hideLoadingUI(), this.onNewSceneAddedObservable.clear(); this.postProcesses.length;)this.postProcesses[0].dispose(); for (this._rescalePostProcess && this._rescalePostProcess.dispose(); this.scenes.length;)this.scenes[0].dispose(); for (; this._virtualScenes.length;)this._virtualScenes[0].dispose(); ce.Instances.length === 1 && P.audioEngine && (P.audioEngine.dispose(), P.audioEngine = null); const e = this.getHostWindow(); e && typeof e.removeEventListener == "function" && (e.removeEventListener("blur", this._onBlur), e.removeEventListener("focus", this._onFocus)), this._renderingCanvas && (this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus), this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur), this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut), this._renderingCanvas.removeEventListener("contextmenu", this._onCanvasContextMenu)), Qt() && (document.removeEventListener("fullscreenchange", this._onFullscreenChange), document.removeEventListener("mozfullscreenchange", this._onFullscreenChange), document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange), document.removeEventListener("msfullscreenchange", this._onFullscreenChange), document.removeEventListener("pointerlockchange", this._onPointerLockChange), document.removeEventListener("mspointerlockchange", this._onPointerLockChange), document.removeEventListener("mozpointerlockchange", this._onPointerLockChange), document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange)), super.dispose(); const t = ce.Instances.indexOf(this); t >= 0 && ce.Instances.splice(t, 1), P.Instances.length || ce.OnEnginesDisposedObservable.notifyObservers(this), this.onResizeObservable.clear(), this.onCanvasBlurObservable.clear(), this.onCanvasFocusObservable.clear(), this.onCanvasPointerOutObservable.clear(), this.onBeginFrameObservable.clear(), this.onEndFrameObservable.clear() } _disableTouchAction() { !this._renderingCanvas || !this._renderingCanvas.setAttribute || (this._renderingCanvas.setAttribute("touch-action", "none"), this._renderingCanvas.style.touchAction = "none", this._renderingCanvas.style.webkitTapHighlightColor = "transparent") } displayLoadingUI() { if (!Fe()) return; const e = this.loadingScreen; e && e.displayLoadingUI() } hideLoadingUI() { if (!Fe()) return; const e = this._loadingScreen; e && e.hideLoadingUI() } get loadingScreen() { return !this._loadingScreen && this._renderingCanvas && (this._loadingScreen = P.DefaultLoadingScreenFactory(this._renderingCanvas)), this._loadingScreen } set loadingScreen(e) { this._loadingScreen = e } set loadingUIText(e) { this.loadingScreen.loadingUIText = e } set loadingUIBackgroundColor(e) { this.loadingScreen.loadingUIBackgroundColor = e } createVideoElement(e) { return document.createElement("video") } static _RequestPointerlock(e) { if (e.requestPointerLock) { const t = e.requestPointerLock(); t instanceof Promise ? t.then(() => { e.focus() }).catch(() => { }) : e.focus() } } static _ExitPointerlock() { document.exitPointerLock && document.exitPointerLock() } static _RequestFullscreen(e) { const t = e.requestFullscreen || e.webkitRequestFullscreen; t && t.call(e) } static _ExitFullscreen() { const e = document; document.exitFullscreen ? document.exitFullscreen() : e.webkitCancelFullScreen && e.webkitCancelFullScreen() } getFontOffset(e) { const t = document.createElement("span"); t.innerHTML = "Hg", t.setAttribute("style", `font: ${e} !important`); const i = document.createElement("div"); i.style.display = "inline-block", i.style.width = "1px", i.style.height = "0px", i.style.verticalAlign = "bottom"; const s = document.createElement("div"); s.style.whiteSpace = "nowrap", s.appendChild(t), s.appendChild(i), document.body.appendChild(s); let r = 0, n = 0; try { n = i.getBoundingClientRect().top - t.getBoundingClientRect().top, i.style.verticalAlign = "baseline", r = i.getBoundingClientRect().top - t.getBoundingClientRect().top } finally { document.body.removeChild(s) } return { ascent: r, height: n, descent: n - r } } } P.ALPHA_DISABLE = 0, P.ALPHA_ADD = 1, P.ALPHA_COMBINE = 2, P.ALPHA_SUBTRACT = 3, P.ALPHA_MULTIPLY = 4, P.ALPHA_MAXIMIZED = 5, P.ALPHA_ONEONE = 6, P.ALPHA_PREMULTIPLIED = 7, P.ALPHA_PREMULTIPLIED_PORTERDUFF = 8, P.ALPHA_INTERPOLATE = 9, P.ALPHA_SCREENMODE = 10, P.DELAYLOADSTATE_NONE = 0, P.DELAYLOADSTATE_LOADED = 1, P.DELAYLOADSTATE_LOADING = 2, P.DELAYLOADSTATE_NOTLOADED = 4, P.NEVER = 512, P.ALWAYS = 519, P.LESS = 513, P.EQUAL = 514, P.LEQUAL = 515, P.GREATER = 516, P.GEQUAL = 518, P.NOTEQUAL = 517, P.KEEP = 7680, P.REPLACE = 7681, P.INCR = 7682, P.DECR = 7683, P.INVERT = 5386, P.INCR_WRAP = 34055, P.DECR_WRAP = 34056, P.TEXTURE_CLAMP_ADDRESSMODE = 0, P.TEXTURE_WRAP_ADDRESSMODE = 1, P.TEXTURE_MIRROR_ADDRESSMODE = 2, P.TEXTUREFORMAT_ALPHA = 0, P.TEXTUREFORMAT_LUMINANCE = 1, P.TEXTUREFORMAT_LUMINANCE_ALPHA = 2, P.TEXTUREFORMAT_RGB = 4, P.TEXTUREFORMAT_RGBA = 5, P.TEXTUREFORMAT_RED = 6, P.TEXTUREFORMAT_R = 6, P.TEXTUREFORMAT_RG = 7, P.TEXTUREFORMAT_RED_INTEGER = 8, P.TEXTUREFORMAT_R_INTEGER = 8, P.TEXTUREFORMAT_RG_INTEGER = 9, P.TEXTUREFORMAT_RGB_INTEGER = 10, P.TEXTUREFORMAT_RGBA_INTEGER = 11, P.TEXTURETYPE_UNSIGNED_BYTE = 0, P.TEXTURETYPE_UNSIGNED_INT = 0, P.TEXTURETYPE_FLOAT = 1, P.TEXTURETYPE_HALF_FLOAT = 2, P.TEXTURETYPE_BYTE = 3, P.TEXTURETYPE_SHORT = 4, P.TEXTURETYPE_UNSIGNED_SHORT = 5, P.TEXTURETYPE_INT = 6, P.TEXTURETYPE_UNSIGNED_INTEGER = 7, P.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8, P.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9, P.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10, P.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11, P.TEXTURETYPE_UNSIGNED_INT_24_8 = 12, P.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13, P.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14, P.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15, P.TEXTURE_NEAREST_SAMPLINGMODE = 1, P.TEXTURE_BILINEAR_SAMPLINGMODE = 2, P.TEXTURE_TRILINEAR_SAMPLINGMODE = 3, P.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8, P.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11, P.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3, P.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4, P.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5, P.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6, P.TEXTURE_NEAREST_LINEAR = 7, P.TEXTURE_NEAREST_NEAREST = 1, P.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9, P.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10, P.TEXTURE_LINEAR_LINEAR = 2, P.TEXTURE_LINEAR_NEAREST = 12, P.TEXTURE_EXPLICIT_MODE = 0, P.TEXTURE_SPHERICAL_MODE = 1, P.TEXTURE_PLANAR_MODE = 2, P.TEXTURE_CUBIC_MODE = 3, P.TEXTURE_PROJECTION_MODE = 4, P.TEXTURE_SKYBOX_MODE = 5, P.TEXTURE_INVCUBIC_MODE = 6, P.TEXTURE_EQUIRECTANGULAR_MODE = 7, P.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8, P.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9, P.SCALEMODE_FLOOR = 1, P.SCALEMODE_NEAREST = 2, P.SCALEMODE_CEILING = 3, P._RescalePostProcessFactory = null, P._RenderPassIdCounter = 0; const an = A.Compose(g.One(), q.FromEulerAngles(0, Math.PI, 0), g.Zero()); class Z extends We { get billboardMode() { return this._billboardMode } set billboardMode(e) { this._billboardMode !== e && (this._billboardMode = e, this._cache.useBillboardPosition = (this._billboardMode & Z.BILLBOARDMODE_USE_POSITION) !== 0, this._computeUseBillboardPath()) } get preserveParentRotationForBillboard() { return this._preserveParentRotationForBillboard } set preserveParentRotationForBillboard(e) { e !== this._preserveParentRotationForBillboard && (this._preserveParentRotationForBillboard = e, this._computeUseBillboardPath()) } _computeUseBillboardPath() { this._cache.useBillboardPath = this._billboardMode !== Z.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard } get infiniteDistance() { return this._infiniteDistance } set infiniteDistance(e) { this._infiniteDistance !== e && (this._infiniteDistance = e) } constructor(e, t = null, i = !0) { super(e, t), this._forward = new g(0, 0, 1), this._up = new g(0, 1, 0), this._right = new g(1, 0, 0), this._position = g.Zero(), this._rotation = g.Zero(), this._rotationQuaternion = null, this._scaling = g.One(), this._transformToBoneReferal = null, this._isAbsoluteSynced = !1, this._billboardMode = Z.BILLBOARDMODE_NONE, this._preserveParentRotationForBillboard = !1, this.scalingDeterminant = 1, this._infiniteDistance = !1, this.ignoreNonUniformScaling = !1, this.reIntegrateRotationIntoRotationQuaternion = !1, this._poseMatrix = null, this._localMatrix = A.Zero(), this._usePivotMatrix = !1, this._absolutePosition = g.Zero(), this._absoluteScaling = g.Zero(), this._absoluteRotationQuaternion = q.Identity(), this._pivotMatrix = A.Identity(), this._postMultiplyPivotMatrix = !1, this._isWorldMatrixFrozen = !1, this._indexInSceneTransformNodesArray = -1, this.onAfterWorldMatrixUpdateObservable = new L, this._nonUniformScaling = !1, i && this.getScene().addTransformNode(this) } getClassName() { return "TransformNode" } get position() { return this._position } set position(e) { this._position = e, this._isDirty = !0 } isUsingPivotMatrix() { return this._usePivotMatrix } isUsingPostMultiplyPivotMatrix() { return this._postMultiplyPivotMatrix } get rotation() { return this._rotation } set rotation(e) { this._rotation = e, this._rotationQuaternion = null, this._isDirty = !0 } get scaling() { return this._scaling } set scaling(e) { this._scaling = e, this._isDirty = !0 } get rotationQuaternion() { return this._rotationQuaternion } set rotationQuaternion(e) { this._rotationQuaternion = e, e && this._rotation.setAll(0), this._isDirty = !0 } get forward() { return g.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward), this._forward.normalize() } get up() { return g.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up), this._up.normalize() } get right() { return g.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right), this._right.normalize() } updatePoseMatrix(e) { return this._poseMatrix ? (this._poseMatrix.copyFrom(e), this) : (this._poseMatrix = e.clone(), this) } getPoseMatrix() { return this._poseMatrix || (this._poseMatrix = A.Identity()), this._poseMatrix } _isSynchronized() { const e = this._cache; return !(this._billboardMode !== e.billboardMode || this._billboardMode !== Z.BILLBOARDMODE_NONE || e.pivotMatrixUpdated || this._infiniteDistance || this._position._isDirty || this._scaling._isDirty || this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty) } _initCache() { super._initCache(); const e = this._cache; e.localMatrixUpdated = !1, e.billboardMode = -1, e.infiniteDistance = !1, e.useBillboardPosition = !1, e.useBillboardPath = !1 } get absolutePosition() { return this.getAbsolutePosition() } get absoluteScaling() { return this._syncAbsoluteScalingAndRotation(), this._absoluteScaling } get absoluteRotationQuaternion() { return this._syncAbsoluteScalingAndRotation(), this._absoluteRotationQuaternion } setPreTransformMatrix(e) { return this.setPivotMatrix(e, !1) } setPivotMatrix(e, t = !0) { return this._pivotMatrix.copyFrom(e), this._usePivotMatrix = !this._pivotMatrix.isIdentity(), this._cache.pivotMatrixUpdated = !0, this._postMultiplyPivotMatrix = t, this._postMultiplyPivotMatrix && (this._pivotMatrixInverse ? this._pivotMatrix.invertToRef(this._pivotMatrixInverse) : this._pivotMatrixInverse = A.Invert(this._pivotMatrix)), this } getPivotMatrix() { return this._pivotMatrix } instantiateHierarchy(e = null, t, i) { const s = this.clone("Clone of " + (this.name || this.id), e || this.parent, !0); s && i && i(this, s); for (const r of this.getChildTransformNodes(!0)) r.instantiateHierarchy(s, t, i); return s } freezeWorldMatrix(e = null, t = !1) { return e ? t ? (this._rotation.setAll(0), this._rotationQuaternion = this._rotationQuaternion || q.Identity(), e.decompose(this._scaling, this._rotationQuaternion, this._position), this.computeWorldMatrix(!0)) : (this._worldMatrix = e, this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._afterComputeWorldMatrix()) : (this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0)), this._isDirty = !1, this._isWorldMatrixFrozen = !0, this } unfreezeWorldMatrix() { return this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0), this } get isWorldMatrixFrozen() { return this._isWorldMatrixFrozen } getAbsolutePosition() { return this.computeWorldMatrix(), this._absolutePosition } setAbsolutePosition(e) { if (!e) return this; let t, i, s; if (e.x === void 0) { if (arguments.length < 3) return this; t = arguments[0], i = arguments[1], s = arguments[2] } else t = e.x, i = e.y, s = e.z; if (this.parent) { const r = D.Matrix[0]; this.parent.getWorldMatrix().invertToRef(r), g.TransformCoordinatesFromFloatsToRef(t, i, s, r, this.position) } else this.position.x = t, this.position.y = i, this.position.z = s; return this._absolutePosition.copyFrom(e), this } setPositionWithLocalVector(e) { return this.computeWorldMatrix(), this.position = g.TransformNormal(e, this._localMatrix), this } getPositionExpressedInLocalSpace() { this.computeWorldMatrix(); const e = D.Matrix[0]; return this._localMatrix.invertToRef(e), g.TransformNormal(this.position, e) } locallyTranslate(e) { return this.computeWorldMatrix(!0), this.position = g.TransformCoordinates(e, this._localMatrix), this } lookAt(e, t = 0, i = 0, s = 0, r = dt.LOCAL) { const n = Z._LookAtVectorCache, a = r === dt.LOCAL ? this.position : this.getAbsolutePosition(); if (e.subtractToRef(a, n), this.setDirection(n, t, i, s), r === dt.WORLD && this.parent) if (this.rotationQuaternion) { const o = D.Matrix[0]; this.rotationQuaternion.toRotationMatrix(o); const l = D.Matrix[1]; this.parent.getWorldMatrix().getRotationMatrixToRef(l), l.invert(), o.multiplyToRef(l, o), this.rotationQuaternion.fromRotationMatrix(o) } else { const o = D.Quaternion[0]; q.FromEulerVectorToRef(this.rotation, o); const l = D.Matrix[0]; o.toRotationMatrix(l); const h = D.Matrix[1]; this.parent.getWorldMatrix().getRotationMatrixToRef(h), h.invert(), l.multiplyToRef(h, l), o.fromRotationMatrix(l), o.toEulerAnglesToRef(this.rotation) } return this } getDirection(e) { const t = g.Zero(); return this.getDirectionToRef(e, t), t } getDirectionToRef(e, t) { return g.TransformNormalToRef(e, this.getWorldMatrix(), t), this } setDirection(e, t = 0, i = 0, s = 0) { const r = -Math.atan2(e.z, e.x) + Math.PI / 2, n = Math.sqrt(e.x * e.x + e.z * e.z), a = -Math.atan2(e.y, n); return this.rotationQuaternion ? q.RotationYawPitchRollToRef(r + t, a + i, s, this.rotationQuaternion) : (this.rotation.x = a + i, this.rotation.y = r + t, this.rotation.z = s), this } setPivotPoint(e, t = dt.LOCAL) { this.getScene().getRenderId() == 0 && this.computeWorldMatrix(!0); const i = this.getWorldMatrix(); if (t == dt.WORLD) { const s = D.Matrix[0]; i.invertToRef(s), e = g.TransformCoordinates(e, s) } return this.setPivotMatrix(A.Translation(-e.x, -e.y, -e.z), !0) } getPivotPoint() { const e = g.Zero(); return this.getPivotPointToRef(e), e } getPivotPointToRef(e) { return e.x = -this._pivotMatrix.m[12], e.y = -this._pivotMatrix.m[13], e.z = -this._pivotMatrix.m[14], this } getAbsolutePivotPoint() { const e = g.Zero(); return this.getAbsolutePivotPointToRef(e), e } getAbsolutePivotPointToRef(e) { return this.getPivotPointToRef(e), g.TransformCoordinatesToRef(e, this.getWorldMatrix(), e), this } markAsDirty(e) { if (this._isDirty) return this; if (this._children) for (const t of this._children) t.markAsDirty(e); return super.markAsDirty(e) } setParent(e, t = !1, i = !1) { if (!e && !this.parent) return this; const s = D.Quaternion[0], r = D.Vector3[0], n = D.Vector3[1], a = D.Matrix[1]; A.IdentityToRef(a); const o = D.Matrix[0]; this.computeWorldMatrix(!0); let l = this.rotationQuaternion; return l || (l = Z._TmpRotation, q.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, l)), A.ComposeToRef(this.scaling, l, this.position, o), this.parent && o.multiplyToRef(this.parent.computeWorldMatrix(!0), o), e && (e.computeWorldMatrix(!0).invertToRef(a), o.multiplyToRef(a, o)), o.decompose(n, s, r, t ? this : void 0), this.rotationQuaternion ? this.rotationQuaternion.copyFrom(s) : s.toEulerAnglesToRef(this.rotation), this.scaling.copyFrom(n), this.position.copyFrom(r), this.parent = e, i && this.setPivotMatrix(A.Identity()), this } get nonUniformScaling() { return this._nonUniformScaling } _updateNonUniformScalingState(e) { return this._nonUniformScaling === e ? !1 : (this._nonUniformScaling = e, !0) } attachToBone(e, t) { return this._currentParentWhenAttachingToBone = this.parent, this._transformToBoneReferal = t, this.parent = e, e.getSkeleton().prepare(!0), e.getFinalMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this } detachFromBone(e = !1) { return this.parent ? (this.parent.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this._transformToBoneReferal = null, e ? this.parent = this._currentParentWhenAttachingToBone : this.parent = null, this) : (e && (this.parent = this._currentParentWhenAttachingToBone), this) } rotate(e, t, i) { e.normalize(), this.rotationQuaternion || (this.rotationQuaternion = this.rotation.toQuaternion(), this.rotation.setAll(0)); let s; if (!i || i === dt.LOCAL) s = q.RotationAxisToRef(e, t, Z._RotationAxisCache), this.rotationQuaternion.multiplyToRef(s, this.rotationQuaternion); else { if (this.parent) { const r = this.parent.getWorldMatrix(), n = D.Matrix[0]; r.invertToRef(n), e = g.TransformNormal(e, n), r.determinant() < 0 && (t *= -1) } s = q.RotationAxisToRef(e, t, Z._RotationAxisCache), s.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion) } return this } rotateAround(e, t, i) { t.normalize(), this.rotationQuaternion || (this.rotationQuaternion = q.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z), this.rotation.setAll(0)); const s = D.Vector3[0], r = D.Vector3[1], n = D.Vector3[2], a = D.Quaternion[0], o = D.Matrix[0], l = D.Matrix[1], h = D.Matrix[2], u = D.Matrix[3]; return e.subtractToRef(this.position, s), A.TranslationToRef(s.x, s.y, s.z, o), A.TranslationToRef(-s.x, -s.y, -s.z, l), A.RotationAxisToRef(t, i, h), l.multiplyToRef(h, u), u.multiplyToRef(o, u), u.decompose(r, a, n), this.position.addInPlace(n), a.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion), this } translate(e, t, i) { const s = e.scale(t); if (!i || i === dt.LOCAL) { const r = this.getPositionExpressedInLocalSpace().add(s); this.setPositionWithLocalVector(r) } else this.setAbsolutePosition(this.getAbsolutePosition().add(s)); return this } addRotation(e, t, i) { let s; this.rotationQuaternion ? s = this.rotationQuaternion : (s = D.Quaternion[1], q.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, s)); const r = D.Quaternion[0]; return q.RotationYawPitchRollToRef(t, e, i, r), s.multiplyInPlace(r), this.rotationQuaternion || s.toEulerAnglesToRef(this.rotation), this } _getEffectiveParent() { return this.parent } isWorldMatrixCameraDependent() { return this._infiniteDistance && !this.parent || this._billboardMode !== Z.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard } computeWorldMatrix(e = !1, t = null) { if (this._isWorldMatrixFrozen && !this._isDirty) return this._worldMatrix; const i = this.getScene().getRenderId(); if (!this._isDirty && !e && (this._currentRenderId === i || this.isSynchronized())) return this._currentRenderId = i, this._worldMatrix; t = t || this.getScene().activeCamera, this._updateCache(); const s = this._cache; s.pivotMatrixUpdated = !1, s.billboardMode = this.billboardMode, s.infiniteDistance = this.infiniteDistance, s.parent = this._parentNode, this._currentRenderId = i, this._childUpdateId += 1, this._isDirty = !1, this._position._isDirty = !1, this._rotation._isDirty = !1, this._scaling._isDirty = !1; const r = this._getEffectiveParent(), n = Z._TmpScaling; let a = this._position; if (this._infiniteDistance && !this.parent && t) { const l = t.getWorldMatrix(), h = new g(l.m[12], l.m[13], l.m[14]); a = Z._TmpTranslation, a.copyFromFloats(this._position.x + h.x, this._position.y + h.y, this._position.z + h.z) } n.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant); let o; if (this._rotationQuaternion ? (this._rotationQuaternion._isDirty = !1, o = this._rotationQuaternion, this.reIntegrateRotationIntoRotationQuaternion && this.rotation.lengthSquared() && (this._rotationQuaternion.multiplyInPlace(q.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z)), this._rotation.copyFromFloats(0, 0, 0))) : (o = Z._TmpRotation, q.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, o)), this._usePivotMatrix) { const l = D.Matrix[1]; A.ScalingToRef(n.x, n.y, n.z, l); const h = D.Matrix[0]; o.toRotationMatrix(h), this._pivotMatrix.multiplyToRef(l, D.Matrix[4]), D.Matrix[4].multiplyToRef(h, this._localMatrix), this._postMultiplyPivotMatrix && this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix), this._localMatrix.addTranslationFromFloats(a.x, a.y, a.z) } else A.ComposeToRef(n, o, a, this._localMatrix); if (r && r.getWorldMatrix) { if (e && r.computeWorldMatrix(e), s.useBillboardPath) { if (this._transformToBoneReferal) { const f = this.parent; f.getSkeleton().prepare(), f.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), D.Matrix[7]) } else D.Matrix[7].copyFrom(r.getWorldMatrix()); const l = D.Vector3[5], h = D.Vector3[6], u = D.Quaternion[0]; D.Matrix[7].decompose(h, u, l), A.ScalingToRef(h.x, h.y, h.z, D.Matrix[7]), D.Matrix[7].setTranslation(l), Z.BillboardUseParentOrientation && (this._position.applyRotationQuaternionToRef(u, l), this._localMatrix.setTranslation(l)), this._localMatrix.multiplyToRef(D.Matrix[7], this._worldMatrix) } else if (this._transformToBoneReferal) { const l = this.parent; l.getSkeleton().prepare(), this._localMatrix.multiplyToRef(l.getFinalMatrix(), D.Matrix[6]), D.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix) } else this._localMatrix.multiplyToRef(r.getWorldMatrix(), this._worldMatrix); this._markSyncedWithParent() } else this._worldMatrix.copyFrom(this._localMatrix); if (s.useBillboardPath && t && this.billboardMode && !s.useBillboardPosition) { const l = D.Vector3[0]; if (this._worldMatrix.getTranslationToRef(l), D.Matrix[1].copyFrom(t.getViewMatrix()), this._scene.useRightHandedSystem && D.Matrix[1].multiplyToRef(an, D.Matrix[1]), D.Matrix[1].setTranslationFromFloats(0, 0, 0), D.Matrix[1].invertToRef(D.Matrix[0]), (this.billboardMode & Z.BILLBOARDMODE_ALL) !== Z.BILLBOARDMODE_ALL) { D.Matrix[0].decompose(void 0, D.Quaternion[0], void 0); const h = D.Vector3[1]; D.Quaternion[0].toEulerAnglesToRef(h), (this.billboardMode & Z.BILLBOARDMODE_X) !== Z.BILLBOARDMODE_X && (h.x = 0), (this.billboardMode & Z.BILLBOARDMODE_Y) !== Z.BILLBOARDMODE_Y && (h.y = 0), (this.billboardMode & Z.BILLBOARDMODE_Z) !== Z.BILLBOARDMODE_Z && (h.z = 0), A.RotationYawPitchRollToRef(h.y, h.x, h.z, D.Matrix[0]) } this._worldMatrix.setTranslationFromFloats(0, 0, 0), this._worldMatrix.multiplyToRef(D.Matrix[0], this._worldMatrix), this._worldMatrix.setTranslation(D.Vector3[0]) } else if (s.useBillboardPath && t && s.useBillboardPosition) { const l = D.Vector3[0]; this._worldMatrix.getTranslationToRef(l); const h = t.globalPosition; this._worldMatrix.invertToRef(D.Matrix[1]); const u = D.Vector3[1]; g.TransformCoordinatesToRef(h, D.Matrix[1], u), u.normalize(); const f = -Math.atan2(u.z, u.x) + Math.PI / 2, _ = Math.sqrt(u.x * u.x + u.z * u.z), p = -Math.atan2(u.y, _); if (q.RotationYawPitchRollToRef(f, p, 0, D.Quaternion[0]), (this.billboardMode & Z.BILLBOARDMODE_ALL) !== Z.BILLBOARDMODE_ALL) { const v = D.Vector3[1]; D.Quaternion[0].toEulerAnglesToRef(v), (this.billboardMode & Z.BILLBOARDMODE_X) !== Z.BILLBOARDMODE_X && (v.x = 0), (this.billboardMode & Z.BILLBOARDMODE_Y) !== Z.BILLBOARDMODE_Y && (v.y = 0), (this.billboardMode & Z.BILLBOARDMODE_Z) !== Z.BILLBOARDMODE_Z && (v.z = 0), A.RotationYawPitchRollToRef(v.y, v.x, v.z, D.Matrix[0]) } else A.FromQuaternionToRef(D.Quaternion[0], D.Matrix[0]); this._worldMatrix.setTranslationFromFloats(0, 0, 0), this._worldMatrix.multiplyToRef(D.Matrix[0], this._worldMatrix), this._worldMatrix.setTranslation(D.Vector3[0]) } return this.ignoreNonUniformScaling ? this._updateNonUniformScalingState(!1) : this._scaling.isNonUniformWithinEpsilon(1e-6) ? this._updateNonUniformScalingState(!0) : r && r._nonUniformScaling ? this._updateNonUniformScalingState(r._nonUniformScaling) : this._updateNonUniformScalingState(!1), this._afterComputeWorldMatrix(), this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._isAbsoluteSynced = !1, this.onAfterWorldMatrixUpdateObservable.notifyObservers(this), this._poseMatrix || (this._poseMatrix = A.Invert(this._worldMatrix)), this._worldMatrixDeterminantIsDirty = !0, this._worldMatrix } resetLocalMatrix(e = !0) { if (this.computeWorldMatrix(), e) { const t = this.getChildren(); for (let i = 0; i < t.length; ++i) { const s = t[i]; if (s) { s.computeWorldMatrix(); const r = D.Matrix[0]; s._localMatrix.multiplyToRef(this._localMatrix, r); const n = D.Quaternion[0]; r.decompose(s.scaling, n, s.position), s.rotationQuaternion ? s.rotationQuaternion.copyFrom(n) : n.toEulerAnglesToRef(s.rotation) } } } this.scaling.copyFromFloats(1, 1, 1), this.position.copyFromFloats(0, 0, 0), this.rotation.copyFromFloats(0, 0, 0), this.rotationQuaternion && (this.rotationQuaternion = q.Identity()), this._worldMatrix = A.Identity() } _afterComputeWorldMatrix() { } registerAfterWorldMatrixUpdate(e) { return this.onAfterWorldMatrixUpdateObservable.add(e), this } unregisterAfterWorldMatrixUpdate(e) { return this.onAfterWorldMatrixUpdateObservable.removeCallback(e), this } getPositionInCameraSpace(e = null) { return e || (e = this.getScene().activeCamera), g.TransformCoordinates(this.getAbsolutePosition(), e.getViewMatrix()) } getDistanceToCamera(e = null) { return e || (e = this.getScene().activeCamera), this.getAbsolutePosition().subtract(e.globalPosition).length() } clone(e, t, i) { const s = re.Clone(() => new Z(e, this.getScene()), this); if (s.name = e, s.id = e, t && (s.parent = t), !i) { const r = this.getDescendants(!0); for (let n = 0; n < r.length; n++) { const a = r[n]; a.clone && a.clone(e + "." + a.name, s) } } return s } serialize(e) { const t = re.Serialize(this, e); return t.type = this.getClassName(), t.uniqueId = this.uniqueId, this.parent && this.parent._serializeAsParent(t), t.localMatrix = this.getPivotMatrix().asArray(), t.isEnabled = this.isEnabled(), t } static Parse(e, t, i) { const s = re.Parse(() => new Z(e.name, t), e, t, i); return e.localMatrix ? s.setPreTransformMatrix(A.FromArray(e.localMatrix)) : e.pivotMatrix && s.setPivotMatrix(A.FromArray(e.pivotMatrix)), s.setEnabled(e.isEnabled), s._waitingParsedUniqueId = e.uniqueId, e.parentId !== void 0 && (s._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (s._waitingParentInstanceIndex = e.parentInstanceIndex), s } getChildTransformNodes(e, t) { const i = []; return this._getDescendants(i, e, s => (!t || t(s)) && s instanceof Z), i } dispose(e, t = !1) { if (this.getScene().stopAnimation(this), this.getScene().removeTransformNode(this), this._parentContainer) { const i = this._parentContainer.transformNodes.indexOf(this); i > -1 && this._parentContainer.transformNodes.splice(i, 1), this._parentContainer = null } if (this.onAfterWorldMatrixUpdateObservable.clear(), e) { const i = this.getChildTransformNodes(!0); for (const s of i) s.parent = null, s.computeWorldMatrix(!0) } super.dispose(e, t) } normalizeToUnitCube(e = !0, t = !1, i) { let s = null, r = null; t && (this.rotationQuaternion ? (r = this.rotationQuaternion.clone(), this.rotationQuaternion.copyFromFloats(0, 0, 0, 1)) : this.rotation && (s = this.rotation.clone(), this.rotation.copyFromFloats(0, 0, 0))); const n = this.getHierarchyBoundingVectors(e, i), a = n.max.subtract(n.min), o = Math.max(a.x, a.y, a.z); if (o === 0) return this; const l = 1 / o; return this.scaling.scaleInPlace(l), t && (this.rotationQuaternion && r ? this.rotationQuaternion.copyFrom(r) : this.rotation && s && this.rotation.copyFrom(s)), this } _syncAbsoluteScalingAndRotation() { this._isAbsoluteSynced || (this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion), this._isAbsoluteSynced = !0) } } Z.BILLBOARDMODE_NONE = 0, Z.BILLBOARDMODE_X = 1, Z.BILLBOARDMODE_Y = 2, Z.BILLBOARDMODE_Z = 4, Z.BILLBOARDMODE_ALL = 7, Z.BILLBOARDMODE_USE_POSITION = 128, Z.BillboardUseParentOrientation = !1, Z._TmpRotation = q.Zero(), Z._TmpScaling = g.Zero(), Z._TmpTranslation = g.Zero(), Z._LookAtVectorCache = new g(0, 0, 0), Z._RotationAxisCache = new q, T([Zt("position")], Z.prototype, "_position", void 0), T([Zt("rotation")], Z.prototype, "_rotation", void 0), T([dr("rotationQuaternion")], Z.prototype, "_rotationQuaternion", void 0), T([Zt("scaling")], Z.prototype, "_scaling", void 0), T([M("billboardMode")], Z.prototype, "_billboardMode", void 0), T([M()], Z.prototype, "scalingDeterminant", void 0), T([M("infiniteDistance")], Z.prototype, "_infiniteDistance", void 0), T([M()], Z.prototype, "ignoreNonUniformScaling", void 0), T([M()], Z.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0); class on { constructor() { this._checkCollisions = !1, this._collisionMask = -1, this._collisionGroup = -1, this._surroundingMeshes = null, this._collider = null, this._oldPositionForCollisions = new g(0, 0, 0), this._diffPositionForCollisions = new g(0, 0, 0), this._collisionResponse = !0 } } class ln { constructor() { this.facetNb = 0, this.partitioningSubdivisions = 10, this.partitioningBBoxRatio = 1.01, this.facetDataEnabled = !1, this.facetParameters = {}, this.bbSize = g.Zero(), this.subDiv = { max: 1, X: 1, Y: 1, Z: 1 }, this.facetDepthSort = !1, this.facetDepthSortEnabled = !1 } } class hn { constructor() { this._hasVertexAlpha = !1, this._useVertexColors = !0, this._numBoneInfluencers = 4, this._applyFog = !0, this._receiveShadows = !1, this._facetData = new ln, this._visibility = 1, this._skeleton = null, this._layerMask = 268435455, this._computeBonesUsingShaders = !0, this._isActive = !1, this._onlyForInstances = !1, this._isActiveIntermediate = !1, this._onlyForInstancesIntermediate = !1, this._actAsRegularMesh = !1, this._currentLOD = null, this._currentLODIsUpToDate = !1, this._collisionRetryCount = 3, this._morphTargetManager = null, this._renderingGroupId = 0, this._bakedVertexAnimationManager = null, this._material = null, this._positions = null, this._pointerOverDisableMeshTesting = !1, this._meshCollisionData = new on, this._enableDistantPicking = !1, this._rawBoundingInfo = null } } class Je extends Z { static get BILLBOARDMODE_NONE() { return Z.BILLBOARDMODE_NONE } static get BILLBOARDMODE_X() { return Z.BILLBOARDMODE_X } static get BILLBOARDMODE_Y() { return Z.BILLBOARDMODE_Y } static get BILLBOARDMODE_Z() { return Z.BILLBOARDMODE_Z } static get BILLBOARDMODE_ALL() { return Z.BILLBOARDMODE_ALL } static get BILLBOARDMODE_USE_POSITION() { return Z.BILLBOARDMODE_USE_POSITION } get facetNb() { return this._internalAbstractMeshDataInfo._facetData.facetNb } get partitioningSubdivisions() { return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions } set partitioningSubdivisions(e) { this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = e } get partitioningBBoxRatio() { return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio } set partitioningBBoxRatio(e) { this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = e } get mustDepthSortFacets() { return this._internalAbstractMeshDataInfo._facetData.facetDepthSort } set mustDepthSortFacets(e) { this._internalAbstractMeshDataInfo._facetData.facetDepthSort = e } get facetDepthSortFrom() { return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom } set facetDepthSortFrom(e) { this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = e } get collisionRetryCount() { return this._internalAbstractMeshDataInfo._collisionRetryCount } set collisionRetryCount(e) { this._internalAbstractMeshDataInfo._collisionRetryCount = e } get isFacetDataEnabled() { return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled } get morphTargetManager() { return this._internalAbstractMeshDataInfo._morphTargetManager } set morphTargetManager(e) { this._internalAbstractMeshDataInfo._morphTargetManager !== e && (this._internalAbstractMeshDataInfo._morphTargetManager = e, this._syncGeometryWithMorphTargetManager()) } get bakedVertexAnimationManager() { return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager } set bakedVertexAnimationManager(e) { this._internalAbstractMeshDataInfo._bakedVertexAnimationManager !== e && (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = e, this._markSubMeshesAsAttributesDirty()) } _syncGeometryWithMorphTargetManager() { } _updateNonUniformScalingState(e) { return super._updateNonUniformScalingState(e) ? (this._markSubMeshesAsMiscDirty(), !0) : !1 } get rawBoundingInfo() { return this._internalAbstractMeshDataInfo._rawBoundingInfo } set rawBoundingInfo(e) { this._internalAbstractMeshDataInfo._rawBoundingInfo = e } set onCollide(e) { this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver && this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver), this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(e) } set onCollisionPositionChange(e) { this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver && this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver), this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(e) } get visibility() { return this._internalAbstractMeshDataInfo._visibility } set visibility(e) { if (this._internalAbstractMeshDataInfo._visibility === e) return; const t = this._internalAbstractMeshDataInfo._visibility; this._internalAbstractMeshDataInfo._visibility = e, (t === 1 && e !== 1 || t !== 1 && e === 1) && this._markSubMeshesAsDirty(i => { i.markAsMiscDirty(), i.markAsPrePassDirty() }) } get pointerOverDisableMeshTesting() { return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting } set pointerOverDisableMeshTesting(e) { this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = e } get renderingGroupId() { return this._internalAbstractMeshDataInfo._renderingGroupId } set renderingGroupId(e) { this._internalAbstractMeshDataInfo._renderingGroupId = e } get material() { return this._internalAbstractMeshDataInfo._material } set material(e) { this._internalAbstractMeshDataInfo._material !== e && (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0), this._internalAbstractMeshDataInfo._material = e, e && e.meshMap && (e.meshMap[this.uniqueId] = this), this.onMaterialChangedObservable.hasObservers() && this.onMaterialChangedObservable.notifyObservers(this), this.subMeshes && (this.resetDrawCache(), this._unBindEffect())) } getMaterialForRenderPass(e) { var t; return (t = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || t === void 0 ? void 0 : t[e] } setMaterialForRenderPass(e, t) { this.resetDrawCache(e), this._internalAbstractMeshDataInfo._materialForRenderPass || (this._internalAbstractMeshDataInfo._materialForRenderPass = []), this._internalAbstractMeshDataInfo._materialForRenderPass[e] = t } get receiveShadows() { return this._internalAbstractMeshDataInfo._receiveShadows } set receiveShadows(e) { this._internalAbstractMeshDataInfo._receiveShadows !== e && (this._internalAbstractMeshDataInfo._receiveShadows = e, this._markSubMeshesAsLightDirty()) } get hasVertexAlpha() { return this._internalAbstractMeshDataInfo._hasVertexAlpha } set hasVertexAlpha(e) { this._internalAbstractMeshDataInfo._hasVertexAlpha !== e && (this._internalAbstractMeshDataInfo._hasVertexAlpha = e, this._markSubMeshesAsAttributesDirty(), this._markSubMeshesAsMiscDirty()) } get useVertexColors() { return this._internalAbstractMeshDataInfo._useVertexColors } set useVertexColors(e) { this._internalAbstractMeshDataInfo._useVertexColors !== e && (this._internalAbstractMeshDataInfo._useVertexColors = e, this._markSubMeshesAsAttributesDirty()) } get computeBonesUsingShaders() { return this._internalAbstractMeshDataInfo._computeBonesUsingShaders } set computeBonesUsingShaders(e) { this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== e && (this._internalAbstractMeshDataInfo._computeBonesUsingShaders = e, this._markSubMeshesAsAttributesDirty()) } get numBoneInfluencers() { return this._internalAbstractMeshDataInfo._numBoneInfluencers } set numBoneInfluencers(e) { this._internalAbstractMeshDataInfo._numBoneInfluencers !== e && (this._internalAbstractMeshDataInfo._numBoneInfluencers = e, this._markSubMeshesAsAttributesDirty()) } get applyFog() { return this._internalAbstractMeshDataInfo._applyFog } set applyFog(e) { this._internalAbstractMeshDataInfo._applyFog !== e && (this._internalAbstractMeshDataInfo._applyFog = e, this._markSubMeshesAsMiscDirty()) } get enableDistantPicking() { return this._internalAbstractMeshDataInfo._enableDistantPicking } set enableDistantPicking(e) { this._internalAbstractMeshDataInfo._enableDistantPicking = e } get layerMask() { return this._internalAbstractMeshDataInfo._layerMask } set layerMask(e) { e !== this._internalAbstractMeshDataInfo._layerMask && (this._internalAbstractMeshDataInfo._layerMask = e, this._resyncLightSources()) } get collisionMask() { return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask } set collisionMask(e) { this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = isNaN(e) ? -1 : e } get collisionResponse() { return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse } set collisionResponse(e) { this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = e } get collisionGroup() { return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup } set collisionGroup(e) { this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = isNaN(e) ? -1 : e } get surroundingMeshes() { return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes } set surroundingMeshes(e) { this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = e } get lightSources() { return this._lightSources } get _positions() { return null } set skeleton(e) { const t = this._internalAbstractMeshDataInfo._skeleton; t && t.needInitialSkinMatrix && t._unregisterMeshWithPoseMatrix(this), e && e.needInitialSkinMatrix && e._registerMeshWithPoseMatrix(this), this._internalAbstractMeshDataInfo._skeleton = e, this._internalAbstractMeshDataInfo._skeleton || (this._bonesTransformMatrices = null), this._markSubMeshesAsAttributesDirty() } get skeleton() { return this._internalAbstractMeshDataInfo._skeleton } constructor(e, t = null) { switch (super(e, t, !1), this._internalAbstractMeshDataInfo = new hn, this._waitingMaterialId = null, this.cullingStrategy = Je.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY, this.onCollideObservable = new L, this.onCollisionPositionChangeObservable = new L, this.onMaterialChangedObservable = new L, this.definedFacingForward = !0, this._occlusionQuery = null, this._renderingGroup = null, this.alphaIndex = Number.MAX_VALUE, this.isVisible = !0, this.isPickable = !0, this.isNearPickable = !1, this.isNearGrabbable = !1, this.showSubMeshesBoundingBox = !1, this.isBlocker = !1, this.enablePointerMoveEvents = !1, this.outlineColor = te.Red(), this.outlineWidth = .02, this.overlayColor = te.Red(), this.overlayAlpha = .5, this.useOctreeForRenderingSelection = !0, this.useOctreeForPicking = !0, this.useOctreeForCollisions = !0, this.alwaysSelectAsActiveMesh = !1, this.doNotSyncBoundingInfo = !1, this.actionManager = null, this.ellipsoid = new g(.5, 1, .5), this.ellipsoidOffset = new g(0, 0, 0), this.edgesWidth = 1, this.edgesColor = new de(1, 0, 0, 1), this._edgesRenderer = null, this._masterMesh = null, this._boundingInfo = null, this._boundingInfoIsDirty = !0, this._renderId = 0, this._intersectionsInProgress = new Array, this._unIndexed = !1, this._lightSources = new Array, this._waitingData = { lods: null, actions: null, freezeWorldMatrix: null }, this._bonesTransformMatrices = null, this._transformMatrixTexture = null, this.onRebuildObservable = new L, this._onCollisionPositionChange = (i, s, r = null) => { s.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions), this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > P.CollisionsEpsilon && this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions), r && this.onCollideObservable.notifyObservers(r), this.onCollisionPositionChangeObservable.notifyObservers(this.position) }, t = this.getScene(), t.addMesh(this), this._resyncLightSources(), this._uniformBuffer = new U(this.getScene().getEngine(), void 0, void 0, e, !this.getScene().getEngine().isWebGPU), this._buildUniformLayout(), t.performancePriority) { case ut.Aggressive: this.doNotSyncBoundingInfo = !0; case ut.Intermediate: this.alwaysSelectAsActiveMesh = !0, this.isPickable = !1; break } } _buildUniformLayout() { this._uniformBuffer.addUniform("world", 16), this._uniformBuffer.addUniform("visibility", 1), this._uniformBuffer.create() } transferToEffect(e) { const t = this._uniformBuffer; t.updateMatrix("world", e), t.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility), t.update() } getMeshUniformBuffer() { return this._uniformBuffer } getClassName() { return "AbstractMesh" } toString(e) { let t = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO"); t += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0); const i = this._internalAbstractMeshDataInfo._skeleton; return i && (t += ", skeleton: " + i.name), e && (t += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode], t += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO")), t } _getEffectiveParent() { return this._masterMesh && this.billboardMode !== Z.BILLBOARDMODE_NONE ? this._masterMesh : super._getEffectiveParent() } _getActionManagerForTrigger(e, t = !0) { if (this.actionManager && (t || this.actionManager.isRecursive)) if (e) { if (this.actionManager.hasSpecificTrigger(e)) return this.actionManager } else return this.actionManager; return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null } _rebuild(e = !1) { if (this.onRebuildObservable.notifyObservers(this), this._occlusionQuery !== null && (this._occlusionQuery = null), !!this.subMeshes) for (const t of this.subMeshes) t._rebuild() } _resyncLightSources() { this._lightSources.length = 0; for (const e of this.getScene().lights) e.isEnabled() && e.canAffectMesh(this) && this._lightSources.push(e); this._markSubMeshesAsLightDirty() } _resyncLightSource(e) { const t = e.isEnabled() && e.canAffectMesh(this), i = this._lightSources.indexOf(e); let s = !1; if (i === -1) { if (!t) return; this._lightSources.push(e) } else { if (t) return; s = !0, this._lightSources.splice(i, 1) } this._markSubMeshesAsLightDirty(s) } _unBindEffect() { for (const e of this.subMeshes) e.setEffect(null) } _removeLightSource(e, t) { const i = this._lightSources.indexOf(e); i !== -1 && (this._lightSources.splice(i, 1), this._markSubMeshesAsLightDirty(t)) } _markSubMeshesAsDirty(e) { if (this.subMeshes) for (const t of this.subMeshes) for (let i = 0; i < t._drawWrappers.length; ++i) { const s = t._drawWrappers[i]; !s || !s.defines || !s.defines.markAllAsDirty || e(s.defines) } } _markSubMeshesAsLightDirty(e = !1) { this._markSubMeshesAsDirty(t => t.markAsLightDirty(e)) } _markSubMeshesAsAttributesDirty() { this._markSubMeshesAsDirty(e => e.markAsAttributesDirty()) } _markSubMeshesAsMiscDirty() { this._markSubMeshesAsDirty(e => e.markAsMiscDirty()) } markAsDirty(e) { return this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this } resetDrawCache(e) { if (this.subMeshes) for (const t of this.subMeshes) t.resetDrawCache(e) } get isBlocked() { return !1 } getLOD(e) { return this } getTotalVertices() { return 0 } getTotalIndices() { return 0 } getIndices() { return null } getVerticesData(e) { return null } setVerticesData(e, t, i, s) { return this } updateVerticesData(e, t, i, s) { return this } setIndices(e, t) { return this } isVerticesDataPresent(e) { return !1 } getBoundingInfo() { return this._masterMesh ? this._masterMesh.getBoundingInfo() : (this._boundingInfoIsDirty && (this._boundingInfoIsDirty = !1, this._updateBoundingInfo()), this._boundingInfo) } getRawBoundingInfo() { var e; return (e = this.rawBoundingInfo) !== null && e !== void 0 ? e : this.getBoundingInfo() } setBoundingInfo(e) { return this._boundingInfo = e, this } get hasBoundingInfo() { return this._boundingInfo !== null } buildBoundingInfo(e, t, i) { return this._boundingInfo = new rt(e, t, i), this._boundingInfo } normalizeToUnitCube(e = !0, t = !1, i) { return super.normalizeToUnitCube(e, t, i) } get useBones() { return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(d.MatricesIndicesKind) && this.isVerticesDataPresent(d.MatricesWeightsKind) } _preActivate() { } _preActivateForIntermediateRendering(e) { } _activate(e, t) { return this._renderId = e, !0 } _postActivate() { } _freeze() { } _unFreeze() { } getWorldMatrix() { return this._masterMesh && this.billboardMode === Z.BILLBOARDMODE_NONE ? this._masterMesh.getWorldMatrix() : super.getWorldMatrix() } _getWorldMatrixDeterminant() { return this._masterMesh ? this._masterMesh._getWorldMatrixDeterminant() : super._getWorldMatrixDeterminant() } get isAnInstance() { return !1 } get hasInstances() { return !1 } get hasThinInstances() { return !1 } movePOV(e, t, i) { return this.position.addInPlace(this.calcMovePOV(e, t, i)), this } calcMovePOV(e, t, i) { const s = new A; (this.rotationQuaternion ? this.rotationQuaternion : q.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z)).toRotationMatrix(s); const n = g.Zero(), a = this.definedFacingForward ? -1 : 1; return g.TransformCoordinatesFromFloatsToRef(e * a, t, i * a, s, n), n } rotatePOV(e, t, i) { return this.rotation.addInPlace(this.calcRotatePOV(e, t, i)), this } calcRotatePOV(e, t, i) { const s = this.definedFacingForward ? 1 : -1; return new g(e * s, t, i * s) } refreshBoundingInfo(e = !1, t = !1) { return this._boundingInfo && this._boundingInfo.isLocked ? this : (this._refreshBoundingInfo(this._getPositionData(e, t), null), this) } _refreshBoundingInfo(e, t) { if (e) { const i = zs(e, 0, this.getTotalVertices(), t); this._boundingInfo ? this._boundingInfo.reConstruct(i.minimum, i.maximum) : this._boundingInfo = new rt(i.minimum, i.maximum) } if (this.subMeshes) for (let i = 0; i < this.subMeshes.length; i++)this.subMeshes[i].refreshBoundingInfo(e); this._updateBoundingInfo() } _getData(e = !1, t = !1, i, s = d.PositionKind) { if (i = i ?? this.getVerticesData(s).slice(), i && t && this.morphTargetManager) { let r = 0, n = 0; for (let a = 0; a < i.length; a++) { for (let o = 0; o < this.morphTargetManager.numTargets; o++) { const l = this.morphTargetManager.getTarget(o), h = l.influence; if (h > 0) { let u = null; switch (s) { case d.PositionKind: u = l.getPositions(); break; case d.NormalKind: u = l.getNormals(); break; case d.TangentKind: u = l.getTangents(); break; case d.UVKind: u = l.getUVs(); break }u && (i[a] += (u[a] - i[a]) * h) } } if (r++, s === d.PositionKind && this._positions && r === 3) { r = 0; const o = n * 3; this._positions[n++].copyFromFloats(i[o], i[o + 1], i[o + 2]) } } } if (i && e && this.skeleton) { const r = this.getVerticesData(d.MatricesIndicesKind), n = this.getVerticesData(d.MatricesWeightsKind); if (n && r) { const a = this.numBoneInfluencers > 4, o = a ? this.getVerticesData(d.MatricesIndicesExtraKind) : null, l = a ? this.getVerticesData(d.MatricesWeightsExtraKind) : null, h = this.skeleton.getTransformMatrices(this), u = D.Vector3[0], f = D.Matrix[0], _ = D.Matrix[1]; let p = 0; for (let v = 0; v < i.length; v += 3, p += 4) { f.reset(); let E, m; for (E = 0; E < 4; E++)m = n[p + E], m > 0 && (A.FromFloat32ArrayToRefScaled(h, Math.floor(r[p + E] * 16), m, _), f.addToSelf(_)); if (a) for (E = 0; E < 4; E++)m = l[p + E], m > 0 && (A.FromFloat32ArrayToRefScaled(h, Math.floor(o[p + E] * 16), m, _), f.addToSelf(_)); s === d.NormalKind ? g.TransformNormalFromFloatsToRef(i[v], i[v + 1], i[v + 2], f, u) : g.TransformCoordinatesFromFloatsToRef(i[v], i[v + 1], i[v + 2], f, u), u.toArray(i, v), s === d.PositionKind && this._positions && this._positions[v / 3].copyFrom(u) } } } return i } getNormalsData(e = !1, t = !1) { return this._getData(e, t, null, d.NormalKind) } getPositionData(e = !1, t = !1, i) { return this._getData(e, t, i, d.PositionKind) } _getPositionData(e, t) { var i; let s = this.getVerticesData(d.PositionKind); if (this._internalAbstractMeshDataInfo._positions && (this._internalAbstractMeshDataInfo._positions = null), s && (e && this.skeleton || t && this.morphTargetManager)) { if (s = s.slice(), this._generatePointsArray(), this._positions) { const r = this._positions; this._internalAbstractMeshDataInfo._positions = new Array(r.length); for (let n = 0; n < r.length; n++)this._internalAbstractMeshDataInfo._positions[n] = ((i = r[n]) === null || i === void 0 ? void 0 : i.clone()) || new g } return this.getPositionData(e, t, s) } return s } _updateBoundingInfo() { return this._boundingInfo ? this._boundingInfo.update(this.worldMatrixFromCache) : this._boundingInfo = new rt(g.Zero(), g.Zero(), this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache), this } _updateSubMeshesBoundingInfo(e) { if (!this.subMeshes) return this; const t = this.subMeshes.length; for (let i = 0; i < t; i++) { const s = this.subMeshes[i]; (t > 1 || !s.IsGlobal) && s.updateBoundingInfo(e) } return this } _afterComputeWorldMatrix() { this.doNotSyncBoundingInfo || (this._boundingInfoIsDirty = !0) } isInFrustum(e) { return this.getBoundingInfo().isInFrustum(e, this.cullingStrategy) } isCompletelyInFrustum(e) { return this.getBoundingInfo().isCompletelyInFrustum(e) } intersectsMesh(e, t = !1, i) { const s = this.getBoundingInfo(), r = e.getBoundingInfo(); if (s.intersects(r, t)) return !0; if (i) { for (const n of this.getChildMeshes()) if (n.intersectsMesh(e, t, !0)) return !0 } return !1 } intersectsPoint(e) { return this.getBoundingInfo().intersectsPoint(e) } get checkCollisions() { return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions } set checkCollisions(e) { this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = e } get collider() { return this._internalAbstractMeshDataInfo._meshCollisionData._collider } moveWithCollisions(e) { this.getAbsolutePosition().addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions); const i = this.getScene().collisionCoordinator; return this._internalAbstractMeshDataInfo._meshCollisionData._collider || (this._internalAbstractMeshDataInfo._meshCollisionData._collider = i.createCollider()), this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid, i.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, e, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId), this } _collideForSubMesh(e, t, i) { var s; if (this._generatePointsArray(), !this._positions) return this; if (!e._lastColliderWorldVertices || !e._lastColliderTransformMatrix.equals(t)) { e._lastColliderTransformMatrix = t.clone(), e._lastColliderWorldVertices = [], e._trianglePlanes = []; const r = e.verticesStart, n = e.verticesStart + e.verticesCount; for (let a = r; a < n; a++)e._lastColliderWorldVertices.push(g.TransformCoordinates(this._positions[a], t)) } return i._collide(e._trianglePlanes, e._lastColliderWorldVertices, this.getIndices(), e.indexStart, e.indexStart + e.indexCount, e.verticesStart, !!e.getMaterial(), this, this._shouldConvertRHS(), ((s = e.getMaterial()) === null || s === void 0 ? void 0 : s.fillMode) === 7), this } _processCollisionsForSubMeshes(e, t) { const i = this._scene.getCollidingSubMeshCandidates(this, e), s = i.length; for (let r = 0; r < s; r++) { const n = i.data[r]; s > 1 && !n._checkCollision(e) || this._collideForSubMesh(n, t, e) } return this } _shouldConvertRHS() { return !1 } _checkCollision(e) { if (!this.getBoundingInfo()._checkCollision(e)) return this; const t = D.Matrix[0], i = D.Matrix[1]; return A.ScalingToRef(1 / e._radius.x, 1 / e._radius.y, 1 / e._radius.z, t), this.worldMatrixFromCache.multiplyToRef(t, i), this._processCollisionsForSubMeshes(e, i), this } _generatePointsArray() { return !1 } intersects(e, t, i, s = !1, r, n = !1) { const a = new ai, o = this.getClassName(), l = o === "InstancedLinesMesh" || o === "LinesMesh" || o === "GreasedLineMesh" ? this.intersectionThreshold : 0, h = this.getBoundingInfo(); if (!this.subMeshes || !n && (!e.intersectsSphere(h.boundingSphere, l) || !e.intersectsBox(h.boundingBox, l))) return a; if (s) return a.hit = !n, a.pickedMesh = n ? null : this, a.distance = n ? 0 : g.Distance(e.origin, h.boundingSphere.center), a.subMeshId = 0, a; if (!this._generatePointsArray()) return a; let u = null; const f = this._scene.getIntersectingSubMeshCandidates(this, e), _ = f.length; let p = !1; for (let v = 0; v < _; v++) { const m = f.data[v].getMaterial(); if (m && (m.fillMode == 7 || m.fillMode == 0 || m.fillMode == 1 || m.fillMode == 2 || m.fillMode == 4)) { p = !0; break } } if (!p) return a.hit = !0, a.pickedMesh = this, a.distance = g.Distance(e.origin, h.boundingSphere.center), a.subMeshId = -1, a; for (let v = 0; v < _; v++) { const E = f.data[v]; if (_ > 1 && !n && !E.canIntersects(e)) continue; const m = E.intersects(e, this._positions, this.getIndices(), t, i); if (m && (t || !u || m.distance < u.distance) && (u = m, u.subMeshId = v, t)) break } if (u) { const v = r ?? this.getWorldMatrix(), E = D.Vector3[0], m = D.Vector3[1]; g.TransformCoordinatesToRef(e.origin, v, E), e.direction.scaleToRef(u.distance, m); const C = g.TransformNormal(m, v).addInPlace(E); return a.hit = !0, a.distance = g.Distance(E, C), a.pickedPoint = C, a.pickedMesh = this, a.bu = u.bu || 0, a.bv = u.bv || 0, a.subMeshFaceId = u.faceId, a.faceId = u.faceId + f.data[u.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3), a.subMeshId = u.subMeshId, a } return a } clone(e, t, i) { return null } releaseSubMeshes() { if (this.subMeshes) for (; this.subMeshes.length;)this.subMeshes[0].dispose(); else this.subMeshes = []; return this } dispose(e, t = !1) { let i; const s = this.getScene(); for (this._scene.useMaterialMeshMap && this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0), s.freeActiveMeshes(), s.freeRenderingGroups(), s.renderingManager.maintainStateBetweenFrames && s.renderingManager.restoreDispachedFlags(), this.actionManager !== void 0 && this.actionManager !== null && (this._scene.meshes.some(a => a !== this && a.actionManager === this.actionManager) || this.actionManager.dispose(), this.actionManager = null), this._internalAbstractMeshDataInfo._skeleton = null, this._transformMatrixTexture && (this._transformMatrixTexture.dispose(), this._transformMatrixTexture = null), i = 0; i < this._intersectionsInProgress.length; i++) { const a = this._intersectionsInProgress[i], o = a._intersectionsInProgress.indexOf(this); a._intersectionsInProgress.splice(o, 1) } this._intersectionsInProgress.length = 0, s.lights.forEach(a => { let o = a.includedOnlyMeshes.indexOf(this); o !== -1 && a.includedOnlyMeshes.splice(o, 1), o = a.excludedMeshes.indexOf(this), o !== -1 && a.excludedMeshes.splice(o, 1); const l = a.getShadowGenerators(); if (l) { const h = l.values(); for (let u = h.next(); u.done !== !0; u = h.next()) { const _ = u.value.getShadowMap(); _ && _.renderList && (o = _.renderList.indexOf(this), o !== -1 && _.renderList.splice(o, 1)) } } }), (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") && this.releaseSubMeshes(); const n = s.getEngine(); if (this._occlusionQuery !== null && (this.isOcclusionQueryInProgress = !1, n.deleteQuery(this._occlusionQuery), this._occlusionQuery = null), n.wipeCaches(), s.removeMesh(this), this._parentContainer) { const a = this._parentContainer.meshes.indexOf(this); a > -1 && this._parentContainer.meshes.splice(a, 1), this._parentContainer = null } if (t && this.material && (this.material.getClassName() === "MultiMaterial" ? this.material.dispose(!1, !0, !0) : this.material.dispose(!1, !0)), !e) for (i = 0; i < s.particleSystems.length; i++)s.particleSystems[i].emitter === this && (s.particleSystems[i].dispose(), i--); this._internalAbstractMeshDataInfo._facetData.facetDataEnabled && this.disableFacetData(), this._uniformBuffer.dispose(), this.onAfterWorldMatrixUpdateObservable.clear(), this.onCollideObservable.clear(), this.onCollisionPositionChangeObservable.clear(), this.onRebuildObservable.clear(), super.dispose(e, t) } addChild(e, t = !1) { return e.setParent(this, t), this } removeChild(e, t = !1) { return e.setParent(null, t), this } _initFacetData() { const e = this._internalAbstractMeshDataInfo._facetData; e.facetNormals || (e.facetNormals = []), e.facetPositions || (e.facetPositions = []), e.facetPartitioning || (e.facetPartitioning = new Array), e.facetNb = this.getIndices().length / 3 | 0, e.partitioningSubdivisions = e.partitioningSubdivisions ? e.partitioningSubdivisions : 10, e.partitioningBBoxRatio = e.partitioningBBoxRatio ? e.partitioningBBoxRatio : 1.01; for (let t = 0; t < e.facetNb; t++)e.facetNormals[t] = g.Zero(), e.facetPositions[t] = g.Zero(); return e.facetDataEnabled = !0, this } updateFacetData() { const e = this._internalAbstractMeshDataInfo._facetData; e.facetDataEnabled || this._initFacetData(); const t = this.getVerticesData(d.PositionKind), i = this.getIndices(), s = this.getVerticesData(d.NormalKind), r = this.getBoundingInfo(); if (e.facetDepthSort && !e.facetDepthSortEnabled) { if (e.facetDepthSortEnabled = !0, i instanceof Uint16Array) e.depthSortedIndices = new Uint16Array(i); else if (i instanceof Uint32Array) e.depthSortedIndices = new Uint32Array(i); else { let a = !1; for (let o = 0; o < i.length; o++)if (i[o] > 65535) { a = !0; break } a ? e.depthSortedIndices = new Uint32Array(i) : e.depthSortedIndices = new Uint16Array(i) } if (e.facetDepthSortFunction = function (a, o) { return o.sqDistance - a.sqDistance }, !e.facetDepthSortFrom) { const a = this.getScene().activeCamera; e.facetDepthSortFrom = a ? a.position : g.Zero() } e.depthSortedFacets = []; for (let a = 0; a < e.facetNb; a++) { const o = { ind: a * 3, sqDistance: 0 }; e.depthSortedFacets.push(o) } e.invertedMatrix = A.Identity(), e.facetDepthSortOrigin = g.Zero() } e.bbSize.x = r.maximum.x - r.minimum.x > Ie ? r.maximum.x - r.minimum.x : Ie, e.bbSize.y = r.maximum.y - r.minimum.y > Ie ? r.maximum.y - r.minimum.y : Ie, e.bbSize.z = r.maximum.z - r.minimum.z > Ie ? r.maximum.z - r.minimum.z : Ie; let n = e.bbSize.x > e.bbSize.y ? e.bbSize.x : e.bbSize.y; if (n = n > e.bbSize.z ? n : e.bbSize.z, e.subDiv.max = e.partitioningSubdivisions, e.subDiv.X = Math.floor(e.subDiv.max * e.bbSize.x / n), e.subDiv.Y = Math.floor(e.subDiv.max * e.bbSize.y / n), e.subDiv.Z = Math.floor(e.subDiv.max * e.bbSize.z / n), e.subDiv.X = e.subDiv.X < 1 ? 1 : e.subDiv.X, e.subDiv.Y = e.subDiv.Y < 1 ? 1 : e.subDiv.Y, e.subDiv.Z = e.subDiv.Z < 1 ? 1 : e.subDiv.Z, e.facetParameters.facetNormals = this.getFacetLocalNormals(), e.facetParameters.facetPositions = this.getFacetLocalPositions(), e.facetParameters.facetPartitioning = this.getFacetLocalPartitioning(), e.facetParameters.bInfo = r, e.facetParameters.bbSize = e.bbSize, e.facetParameters.subDiv = e.subDiv, e.facetParameters.ratio = this.partitioningBBoxRatio, e.facetParameters.depthSort = e.facetDepthSort, e.facetDepthSort && e.facetDepthSortEnabled && (this.computeWorldMatrix(!0), this._worldMatrix.invertToRef(e.invertedMatrix), g.TransformCoordinatesToRef(e.facetDepthSortFrom, e.invertedMatrix, e.facetDepthSortOrigin), e.facetParameters.distanceTo = e.facetDepthSortOrigin), e.facetParameters.depthSortedFacets = e.depthSortedFacets, s && Y.ComputeNormals(t, i, s, e.facetParameters), e.facetDepthSort && e.facetDepthSortEnabled) { e.depthSortedFacets.sort(e.facetDepthSortFunction); const a = e.depthSortedIndices.length / 3 | 0; for (let o = 0; o < a; o++) { const l = e.depthSortedFacets[o].ind; e.depthSortedIndices[o * 3] = i[l], e.depthSortedIndices[o * 3 + 1] = i[l + 1], e.depthSortedIndices[o * 3 + 2] = i[l + 2] } this.updateIndices(e.depthSortedIndices, void 0, !0) } return this } getFacetLocalNormals() { const e = this._internalAbstractMeshDataInfo._facetData; return e.facetNormals || this.updateFacetData(), e.facetNormals } getFacetLocalPositions() { const e = this._internalAbstractMeshDataInfo._facetData; return e.facetPositions || this.updateFacetData(), e.facetPositions } getFacetLocalPartitioning() { const e = this._internalAbstractMeshDataInfo._facetData; return e.facetPartitioning || this.updateFacetData(), e.facetPartitioning } getFacetPosition(e) { const t = g.Zero(); return this.getFacetPositionToRef(e, t), t } getFacetPositionToRef(e, t) { const i = this.getFacetLocalPositions()[e], s = this.getWorldMatrix(); return g.TransformCoordinatesToRef(i, s, t), this } getFacetNormal(e) { const t = g.Zero(); return this.getFacetNormalToRef(e, t), t } getFacetNormalToRef(e, t) { const i = this.getFacetLocalNormals()[e]; return g.TransformNormalToRef(i, this.getWorldMatrix(), t), this } getFacetsAtLocalCoordinates(e, t, i) { const s = this.getBoundingInfo(), r = this._internalAbstractMeshDataInfo._facetData, n = Math.floor((e - s.minimum.x * r.partitioningBBoxRatio) * r.subDiv.X * r.partitioningBBoxRatio / r.bbSize.x), a = Math.floor((t - s.minimum.y * r.partitioningBBoxRatio) * r.subDiv.Y * r.partitioningBBoxRatio / r.bbSize.y), o = Math.floor((i - s.minimum.z * r.partitioningBBoxRatio) * r.subDiv.Z * r.partitioningBBoxRatio / r.bbSize.z); return n < 0 || n > r.subDiv.max || a < 0 || a > r.subDiv.max || o < 0 || o > r.subDiv.max ? null : r.facetPartitioning[n + r.subDiv.max * a + r.subDiv.max * r.subDiv.max * o] } getClosestFacetAtCoordinates(e, t, i, s, r = !1, n = !0) { const a = this.getWorldMatrix(), o = D.Matrix[5]; a.invertToRef(o); const l = D.Vector3[8]; g.TransformCoordinatesFromFloatsToRef(e, t, i, o, l); const h = this.getClosestFacetAtLocalCoordinates(l.x, l.y, l.z, s, r, n); return s && g.TransformCoordinatesFromFloatsToRef(s.x, s.y, s.z, a, s), h } getClosestFacetAtLocalCoordinates(e, t, i, s, r = !1, n = !0) { let a = null, o = 0, l = 0, h = 0, u = 0, f = 0, _ = 0, p = 0, v = 0; const E = this.getFacetLocalPositions(), m = this.getFacetLocalNormals(), x = this.getFacetsAtLocalCoordinates(e, t, i); if (!x) return null; let C = Number.MAX_VALUE, S = C, y, b, R; for (let w = 0; w < x.length; w++)y = x[w], b = m[y], R = E[y], u = (e - R.x) * b.x + (t - R.y) * b.y + (i - R.z) * b.z, (!r || r && n && u >= 0 || r && !n && u <= 0) && (u = b.x * R.x + b.y * R.y + b.z * R.z, f = -(b.x * e + b.y * t + b.z * i - u) / (b.x * b.x + b.y * b.y + b.z * b.z), _ = e + b.x * f, p = t + b.y * f, v = i + b.z * f, o = _ - e, l = p - t, h = v - i, S = o * o + l * l + h * h, S < C && (C = S, a = y, s && (s.x = _, s.y = p, s.z = v))); return a } getFacetDataParameters() { return this._internalAbstractMeshDataInfo._facetData.facetParameters } disableFacetData() { const e = this._internalAbstractMeshDataInfo._facetData; return e.facetDataEnabled && (e.facetDataEnabled = !1, e.facetPositions = [], e.facetNormals = [], e.facetPartitioning = new Array, e.facetParameters = null, e.depthSortedIndices = new Uint32Array(0)), this } updateIndices(e, t, i = !1) { return this } createNormals(e) { const t = this.getVerticesData(d.PositionKind), i = this.getIndices(); let s; return this.isVerticesDataPresent(d.NormalKind) ? s = this.getVerticesData(d.NormalKind) : s = [], Y.ComputeNormals(t, i, s, { useRightHandedSystem: this.getScene().useRightHandedSystem }), this.setVerticesData(d.NormalKind, s, e), this } alignWithNormal(e, t) { t || (t = ui.Y); const i = D.Vector3[0], s = D.Vector3[1]; return g.CrossToRef(t, e, s), g.CrossToRef(e, s, i), this.rotationQuaternion ? q.RotationQuaternionFromAxisToRef(i, e, s, this.rotationQuaternion) : g.RotationFromAxisToRef(i, e, s, this.rotation), this } _checkOcclusionQuery() { return !1 } disableEdgesRendering() { throw K("EdgesRenderer") } enableEdgesRendering(e, t, i) { throw K("EdgesRenderer") } getConnectedParticleSystems() { return this._scene.particleSystems.filter(e => e.emitter === this) } } Je.OCCLUSION_TYPE_NONE = 0, Je.OCCLUSION_TYPE_OPTIMISTIC = 1, Je.OCCLUSION_TYPE_STRICT = 2, Je.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0, Je.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1, Je.CULLINGSTRATEGY_STANDARD = 0, Je.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1, Je.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2, Je.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3, at("BABYLON.AbstractMesh", Je); function cn(c) { c.indexOf("vClipPlane") === -1 && c.push("vClipPlane"), c.indexOf("vClipPlane2") === -1 && c.push("vClipPlane2"), c.indexOf("vClipPlane3") === -1 && c.push("vClipPlane3"), c.indexOf("vClipPlane4") === -1 && c.push("vClipPlane4"), c.indexOf("vClipPlane5") === -1 && c.push("vClipPlane5"), c.indexOf("vClipPlane6") === -1 && c.push("vClipPlane6") } function un(c, e, t) { var i, s, r, n, a, o; let l = !1; const h = !!((i = c.clipPlane) !== null && i !== void 0 ? i : e.clipPlane), u = !!((s = c.clipPlane2) !== null && s !== void 0 ? s : e.clipPlane2), f = !!((r = c.clipPlane3) !== null && r !== void 0 ? r : e.clipPlane3), _ = !!((n = c.clipPlane4) !== null && n !== void 0 ? n : e.clipPlane4), p = !!((a = c.clipPlane5) !== null && a !== void 0 ? a : e.clipPlane5), v = !!((o = c.clipPlane6) !== null && o !== void 0 ? o : e.clipPlane6); return t.CLIPPLANE !== h && (t.CLIPPLANE = h, l = !0), t.CLIPPLANE2 !== u && (t.CLIPPLANE2 = u, l = !0), t.CLIPPLANE3 !== f && (t.CLIPPLANE3 = f, l = !0), t.CLIPPLANE4 !== _ && (t.CLIPPLANE4 = _, l = !0), t.CLIPPLANE5 !== p && (t.CLIPPLANE5 = p, l = !0), t.CLIPPLANE6 !== v && (t.CLIPPLANE6 = v, l = !0), l } function fn(c, e, t) { var i, s, r, n, a, o; let l = (i = e.clipPlane) !== null && i !== void 0 ? i : t.clipPlane; Ht(c, "vClipPlane", l), l = (s = e.clipPlane2) !== null && s !== void 0 ? s : t.clipPlane2, Ht(c, "vClipPlane2", l), l = (r = e.clipPlane3) !== null && r !== void 0 ? r : t.clipPlane3, Ht(c, "vClipPlane3", l), l = (n = e.clipPlane4) !== null && n !== void 0 ? n : t.clipPlane4, Ht(c, "vClipPlane4", l), l = (a = e.clipPlane5) !== null && a !== void 0 ? a : t.clipPlane5, Ht(c, "vClipPlane5", l), l = (o = e.clipPlane6) !== null && o !== void 0 ? o : t.clipPlane6, Ht(c, "vClipPlane6", l) } function Ht(c, e, t) { t && c.setFloat4(e, t.normal.x, t.normal.y, t.normal.z, t.d) } class le { static BindSceneUniformBuffer(e, t) { t.bindToEffect(e, "Scene") } static PrepareDefinesForMergedUV(e, t, i) { t._needUVs = !0, t[i] = !0, e.optimizeUVAllocation && e.getTextureMatrix().isIdentityAs3x2() ? (t[i + "DIRECTUV"] = e.coordinatesIndex + 1, t["MAINUV" + (e.coordinatesIndex + 1)] = !0) : t[i + "DIRECTUV"] = 0 } static BindTextureMatrix(e, t, i) { const s = e.getTextureMatrix(); t.updateMatrix(i + "Matrix", s) } static GetFogState(e, t) { return t.fogEnabled && e.applyFog && t.fogMode !== Le.FOGMODE_NONE } static PrepareDefinesForMisc(e, t, i, s, r, n, a, o = !1) { a._areMiscDirty && (a.LOGARITHMICDEPTH = i, a.POINTSIZE = s, a.FOG = r && this.GetFogState(e, t), a.NONUNIFORMSCALING = e.nonUniformScaling, a.ALPHATEST = n, a.DECAL_AFTER_DETAIL = o) } static PrepareDefinesForCamera(e, t) { let i = !1; if (e.activeCamera) { const s = t.CAMERA_ORTHOGRAPHIC ? 1 : 0, r = t.CAMERA_PERSPECTIVE ? 1 : 0, n = e.activeCamera.mode === Q.ORTHOGRAPHIC_CAMERA ? 1 : 0, a = e.activeCamera.mode === Q.PERSPECTIVE_CAMERA ? 1 : 0; (s ^ n || r ^ a) && (t.CAMERA_ORTHOGRAPHIC = n === 1, t.CAMERA_PERSPECTIVE = a === 1, i = !0) } return i } static PrepareDefinesForFrameBoundValues(e, t, i, s, r, n = null, a = !1) { let o = le.PrepareDefinesForCamera(e, s); n !== !1 && (o = un(i, e, s)), s.DEPTHPREPASS !== !t.getColorWrite() && (s.DEPTHPREPASS = !s.DEPTHPREPASS, o = !0), s.INSTANCES !== r && (s.INSTANCES = r, o = !0), s.THIN_INSTANCES !== a && (s.THIN_INSTANCES = a, o = !0), o && s.markAsUnprocessed() } static PrepareDefinesForBones(e, t) { if (e.useBones && e.computeBonesUsingShaders && e.skeleton) { t.NUM_BONE_INFLUENCERS = e.numBoneInfluencers; const i = t.BONETEXTURE !== void 0; if (e.skeleton.isUsingTextureForMatrices && i) t.BONETEXTURE = !0; else { t.BonesPerMesh = e.skeleton.bones.length + 1, t.BONETEXTURE = i ? !1 : void 0; const s = e.getScene().prePassRenderer; if (s && s.enabled) { const r = s.excludedSkinnedMesh.indexOf(e) === -1; t.BONES_VELOCITY_ENABLED = r } } } else t.NUM_BONE_INFLUENCERS = 0, t.BonesPerMesh = 0, t.BONETEXTURE !== void 0 && (t.BONETEXTURE = !1) } static PrepareDefinesForMorphTargets(e, t) { const i = e.morphTargetManager; i ? (t.MORPHTARGETS_UV = i.supportsUVs && t.UV1, t.MORPHTARGETS_TANGENT = i.supportsTangents && t.TANGENT, t.MORPHTARGETS_NORMAL = i.supportsNormals && t.NORMAL, t.MORPHTARGETS = i.numInfluencers > 0, t.NUM_MORPH_INFLUENCERS = i.numInfluencers, t.MORPHTARGETS_TEXTURE = i.isUsingTextureForTargets) : (t.MORPHTARGETS_UV = !1, t.MORPHTARGETS_TANGENT = !1, t.MORPHTARGETS_NORMAL = !1, t.MORPHTARGETS = !1, t.NUM_MORPH_INFLUENCERS = 0) } static PrepareDefinesForBakedVertexAnimation(e, t) { const i = e.bakedVertexAnimationManager; t.BAKED_VERTEX_ANIMATION_TEXTURE = !!(i && i.isEnabled) } static PrepareDefinesForAttributes(e, t, i, s, r = !1, n = !0, a = !0) { if (!t._areAttributesDirty && t._needNormals === t._normals && t._needUVs === t._uvs) return !1; t._normals = t._needNormals, t._uvs = t._needUVs, t.NORMAL = t._needNormals && e.isVerticesDataPresent(d.NormalKind), t._needNormals && e.isVerticesDataPresent(d.TangentKind) && (t.TANGENT = !0); for (let o = 1; o <= 6; ++o)t["UV" + o] = t._needUVs ? e.isVerticesDataPresent(`uv${o === 1 ? "" : o}`) : !1; if (i) { const o = e.useVertexColors && e.isVerticesDataPresent(d.ColorKind); t.VERTEXCOLOR = o, t.VERTEXALPHA = e.hasVertexAlpha && o && n } return e.isVerticesDataPresent(d.ColorInstanceKind) && (e.hasInstances || e.hasThinInstances) && (t.INSTANCESCOLOR = !0), s && this.PrepareDefinesForBones(e, t), r && this.PrepareDefinesForMorphTargets(e, t), a && this.PrepareDefinesForBakedVertexAnimation(e, t), !0 } static PrepareDefinesForMultiview(e, t) { if (e.activeCamera) { const i = t.MULTIVIEW; t.MULTIVIEW = e.activeCamera.outputRenderTarget !== null && e.activeCamera.outputRenderTarget.getViewCount() > 1, t.MULTIVIEW != i && t.markAsUnprocessed() } } static PrepareDefinesForOIT(e, t, i) { const s = t.ORDER_INDEPENDENT_TRANSPARENCY, r = t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS; t.ORDER_INDEPENDENT_TRANSPARENCY = e.useOrderIndependentTransparency && i, t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !e.getEngine().getCaps().textureFloatLinearFiltering, (s !== t.ORDER_INDEPENDENT_TRANSPARENCY || r !== t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) && t.markAsUnprocessed() } static PrepareDefinesForPrePass(e, t, i) { const s = t.PREPASS; if (!t._arePrePassDirty) return; const r = [{ type: 1, define: "PREPASS_POSITION", index: "PREPASS_POSITION_INDEX" }, { type: 2, define: "PREPASS_VELOCITY", index: "PREPASS_VELOCITY_INDEX" }, { type: 3, define: "PREPASS_REFLECTIVITY", index: "PREPASS_REFLECTIVITY_INDEX" }, { type: 0, define: "PREPASS_IRRADIANCE", index: "PREPASS_IRRADIANCE_INDEX" }, { type: 7, define: "PREPASS_ALBEDO_SQRT", index: "PREPASS_ALBEDO_SQRT_INDEX" }, { type: 5, define: "PREPASS_DEPTH", index: "PREPASS_DEPTH_INDEX" }, { type: 6, define: "PREPASS_NORMAL", index: "PREPASS_NORMAL_INDEX" }]; if (e.prePassRenderer && e.prePassRenderer.enabled && i) { t.PREPASS = !0, t.SCENE_MRT_COUNT = e.prePassRenderer.mrtCount, t.PREPASS_NORMAL_WORLDSPACE = e.prePassRenderer.generateNormalsInWorldSpace; for (let n = 0; n < r.length; n++) { const a = e.prePassRenderer.getIndex(r[n].type); a !== -1 ? (t[r[n].define] = !0, t[r[n].index] = a) : t[r[n].define] = !1 } } else { t.PREPASS = !1; for (let n = 0; n < r.length; n++)t[r[n].define] = !1 } t.PREPASS != s && (t.markAsUnprocessed(), t.markAsImageProcessingDirty()) } static PrepareDefinesForLight(e, t, i, s, r, n, a) { var o; switch (a.needNormals = !0, r["LIGHT" + s] === void 0 && (a.needRebuild = !0), r["LIGHT" + s] = !0, r["SPOTLIGHT" + s] = !1, r["HEMILIGHT" + s] = !1, r["POINTLIGHT" + s] = !1, r["DIRLIGHT" + s] = !1, i.prepareLightSpecificDefines(r, s), r["LIGHT_FALLOFF_PHYSICAL" + s] = !1, r["LIGHT_FALLOFF_GLTF" + s] = !1, r["LIGHT_FALLOFF_STANDARD" + s] = !1, i.falloffType) { case Ce.FALLOFF_GLTF: r["LIGHT_FALLOFF_GLTF" + s] = !0; break; case Ce.FALLOFF_PHYSICAL: r["LIGHT_FALLOFF_PHYSICAL" + s] = !0; break; case Ce.FALLOFF_STANDARD: r["LIGHT_FALLOFF_STANDARD" + s] = !0; break }if (n && !i.specular.equalsFloats(0, 0, 0) && (a.specularEnabled = !0), r["SHADOW" + s] = !1, r["SHADOWCSM" + s] = !1, r["SHADOWCSMDEBUG" + s] = !1, r["SHADOWCSMNUM_CASCADES" + s] = !1, r["SHADOWCSMUSESHADOWMAXZ" + s] = !1, r["SHADOWCSMNOBLEND" + s] = !1, r["SHADOWCSM_RIGHTHANDED" + s] = !1, r["SHADOWPCF" + s] = !1, r["SHADOWPCSS" + s] = !1, r["SHADOWPOISSON" + s] = !1, r["SHADOWESM" + s] = !1, r["SHADOWCLOSEESM" + s] = !1, r["SHADOWCUBE" + s] = !1, r["SHADOWLOWQUALITY" + s] = !1, r["SHADOWMEDIUMQUALITY" + s] = !1, t && t.receiveShadows && e.shadowsEnabled && i.shadowEnabled) { const l = (o = i.getShadowGenerator(e.activeCamera)) !== null && o !== void 0 ? o : i.getShadowGenerator(); if (l) { const h = l.getShadowMap(); h && h.renderList && h.renderList.length > 0 && (a.shadowEnabled = !0, l.prepareDefines(r, s)) } } i.lightmapMode != Ce.LIGHTMAP_DEFAULT ? (a.lightmapMode = !0, r["LIGHTMAPEXCLUDED" + s] = !0, r["LIGHTMAPNOSPECULAR" + s] = i.lightmapMode == Ce.LIGHTMAP_SHADOWSONLY) : (r["LIGHTMAPEXCLUDED" + s] = !1, r["LIGHTMAPNOSPECULAR" + s] = !1) } static PrepareDefinesForLights(e, t, i, s, r = 4, n = !1) { if (!i._areLightsDirty) return i._needNormals; let a = 0; const o = { needNormals: i._needNormals, needRebuild: !1, lightmapMode: !1, shadowEnabled: !1, specularEnabled: !1 }; if (e.lightsEnabled && !n) { for (const h of t.lightSources) if (this.PrepareDefinesForLight(e, t, h, a, i, s, o), a++, a === r) break } i.SPECULARTERM = o.specularEnabled, i.SHADOWS = o.shadowEnabled; for (let h = a; h < r; h++)i["LIGHT" + h] !== void 0 && (i["LIGHT" + h] = !1, i["HEMILIGHT" + h] = !1, i["POINTLIGHT" + h] = !1, i["DIRLIGHT" + h] = !1, i["SPOTLIGHT" + h] = !1, i["SHADOW" + h] = !1, i["SHADOWCSM" + h] = !1, i["SHADOWCSMDEBUG" + h] = !1, i["SHADOWCSMNUM_CASCADES" + h] = !1, i["SHADOWCSMUSESHADOWMAXZ" + h] = !1, i["SHADOWCSMNOBLEND" + h] = !1, i["SHADOWCSM_RIGHTHANDED" + h] = !1, i["SHADOWPCF" + h] = !1, i["SHADOWPCSS" + h] = !1, i["SHADOWPOISSON" + h] = !1, i["SHADOWESM" + h] = !1, i["SHADOWCLOSEESM" + h] = !1, i["SHADOWCUBE" + h] = !1, i["SHADOWLOWQUALITY" + h] = !1, i["SHADOWMEDIUMQUALITY" + h] = !1); const l = e.getEngine().getCaps(); return i.SHADOWFLOAT === void 0 && (o.needRebuild = !0), i.SHADOWFLOAT = o.shadowEnabled && (l.textureFloatRender && l.textureFloatLinearFiltering || l.textureHalfFloatRender && l.textureHalfFloatLinearFiltering), i.LIGHTMAPEXCLUDED = o.lightmapMode, o.needRebuild && i.rebuild(), o.needNormals } static PrepareUniformsAndSamplersForLight(e, t, i, s, r = null, n = !1) { r && r.push("Light" + e), !n && (t.push("vLightData" + e, "vLightDiffuse" + e, "vLightSpecular" + e, "vLightDirection" + e, "vLightFalloff" + e, "vLightGround" + e, "lightMatrix" + e, "shadowsInfo" + e, "depthValues" + e), i.push("shadowSampler" + e), i.push("depthSampler" + e), t.push("viewFrustumZ" + e, "cascadeBlendFactor" + e, "lightSizeUVCorrection" + e, "depthCorrection" + e, "penumbraDarkness" + e, "frustumLengths" + e), s && (i.push("projectionLightSampler" + e), t.push("textureProjectionMatrix" + e))) } static PrepareUniformsAndSamplersList(e, t, i, s = 4) { let r, n = null; if (e.uniformsNames) { const a = e; r = a.uniformsNames, n = a.uniformBuffersNames, t = a.samplers, i = a.defines, s = a.maxSimultaneousLights || 0 } else r = e, t || (t = []); for (let a = 0; a < s && i["LIGHT" + a]; a++)this.PrepareUniformsAndSamplersForLight(a, r, t, i["PROJECTEDLIGHTTEXTURE" + a], n); i.NUM_MORPH_INFLUENCERS && r.push("morphTargetInfluences"), i.BAKED_VERTEX_ANIMATION_TEXTURE && (r.push("bakedVertexAnimationSettings"), r.push("bakedVertexAnimationTextureSizeInverted"), r.push("bakedVertexAnimationTime"), t.push("bakedVertexAnimationTexture")) } static HandleFallbacksForShadows(e, t, i = 4, s = 0) { let r = 0; for (let n = 0; n < i && e["LIGHT" + n]; n++)n > 0 && (r = s + n, t.addFallback(r, "LIGHT" + n)), e.SHADOWS || (e["SHADOW" + n] && t.addFallback(s, "SHADOW" + n), e["SHADOWPCF" + n] && t.addFallback(s, "SHADOWPCF" + n), e["SHADOWPCSS" + n] && t.addFallback(s, "SHADOWPCSS" + n), e["SHADOWPOISSON" + n] && t.addFallback(s, "SHADOWPOISSON" + n), e["SHADOWESM" + n] && t.addFallback(s, "SHADOWESM" + n), e["SHADOWCLOSEESM" + n] && t.addFallback(s, "SHADOWCLOSEESM" + n)); return r++ } static PrepareAttributesForMorphTargetsInfluencers(e, t, i) { this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = i, this.PrepareAttributesForMorphTargets(e, t, this._TmpMorphInfluencers) } static PrepareAttributesForMorphTargets(e, t, i) { const s = i.NUM_MORPH_INFLUENCERS; if (s > 0 && ce.LastCreatedEngine) { const r = ce.LastCreatedEngine.getCaps().maxVertexAttribs, n = t.morphTargetManager; if (n != null && n.isUsingTextureForTargets) return; const a = n && n.supportsNormals && i.NORMAL, o = n && n.supportsTangents && i.TANGENT, l = n && n.supportsUVs && i.UV1; for (let h = 0; h < s; h++)e.push(d.PositionKind + h), a && e.push(d.NormalKind + h), o && e.push(d.TangentKind + h), l && e.push(d.UVKind + "_" + h), e.length > r && O.Error("Cannot add more vertex attributes for mesh " + t.name) } } static PrepareAttributesForBakedVertexAnimation(e, t, i) { i.BAKED_VERTEX_ANIMATION_TEXTURE && i.INSTANCES && e.push("bakedVertexAnimationSettingsInstanced") } static PrepareAttributesForBones(e, t, i, s) { i.NUM_BONE_INFLUENCERS > 0 && (s.addCPUSkinningFallback(0, t), e.push(d.MatricesIndicesKind), e.push(d.MatricesWeightsKind), i.NUM_BONE_INFLUENCERS > 4 && (e.push(d.MatricesIndicesExtraKind), e.push(d.MatricesWeightsExtraKind))) } static PrepareAttributesForInstances(e, t) { (t.INSTANCES || t.THIN_INSTANCES) && this.PushAttributesForInstances(e, !!t.PREPASS_VELOCITY), t.INSTANCESCOLOR && e.push(d.ColorInstanceKind) } static PushAttributesForInstances(e, t = !1) { e.push("world0"), e.push("world1"), e.push("world2"), e.push("world3"), t && (e.push("previousWorld0"), e.push("previousWorld1"), e.push("previousWorld2"), e.push("previousWorld3")) } static BindLightProperties(e, t, i) { e.transferToEffect(t, i + "") } static BindLight(e, t, i, s, r, n = !0) { e._bindLight(t, i, s, r, n) } static BindLights(e, t, i, s, r = 4) { const n = Math.min(t.lightSources.length, r); for (let a = 0; a < n; a++) { const o = t.lightSources[a]; this.BindLight(o, a, e, i, typeof s == "boolean" ? s : s.SPECULARTERM, t.receiveShadows) } } static BindFogParameters(e, t, i, s = !1) { e.fogEnabled && t.applyFog && e.fogMode !== Le.FOGMODE_NONE && (i.setFloat4("vFogInfos", e.fogMode, e.fogStart, e.fogEnd, e.fogDensity), s ? (e.fogColor.toLinearSpaceToRef(this._TempFogColor, e.getEngine().useExactSrgbConversions), i.setColor3("vFogColor", this._TempFogColor)) : i.setColor3("vFogColor", e.fogColor)) } static BindBonesParameters(e, t, i) { if (!(!t || !e) && (e.computeBonesUsingShaders && t._bonesComputationForcedToCPU && (e.computeBonesUsingShaders = !1), e.useBones && e.computeBonesUsingShaders && e.skeleton)) { const s = e.skeleton; if (s.isUsingTextureForMatrices && t.getUniformIndex("boneTextureWidth") > -1) { const r = s.getTransformMatrixTexture(e); t.setTexture("boneSampler", r), t.setFloat("boneTextureWidth", 4 * (s.bones.length + 1)) } else { const r = s.getTransformMatrices(e); r && (t.setMatrices("mBones", r), i && e.getScene().prePassRenderer && e.getScene().prePassRenderer.getIndex(2) && (i.previousBones[e.uniqueId] || (i.previousBones[e.uniqueId] = r.slice()), t.setMatrices("mPreviousBones", i.previousBones[e.uniqueId]), le._CopyBonesTransformationMatrices(r, i.previousBones[e.uniqueId]))) } } } static _CopyBonesTransformationMatrices(e, t) { return t.set(e), t } static BindMorphTargetParameters(e, t) { const i = e.morphTargetManager; !e || !i || t.setFloatArray("morphTargetInfluences", i.influences) } static BindLogDepth(e, t, i) { if (!e || e.LOGARITHMICDEPTH || e.indexOf && e.indexOf("LOGARITHMICDEPTH") >= 0) { const s = i.activeCamera; s.mode === Q.ORTHOGRAPHIC_CAMERA && O.Error("Logarithmic depth is not compatible with orthographic cameras!", 20), t.setFloat("logarithmicDepthConstant", 2 / (Math.log(s.maxZ + 1) / Math.LN2)) } } } le._TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 }, le._TempFogColor = te.Black(); class pt { constructor() { this.reset() } reset() { this.enabled = !1, this.mask = 255, this.func = 519, this.funcRef = 1, this.funcMask = 255, this.opStencilFail = 7680, this.opDepthFail = 7680, this.opStencilDepthPass = 7681 } get func() { return this._func } set func(e) { this._func = e } get funcRef() { return this._funcRef } set funcRef(e) { this._funcRef = e } get funcMask() { return this._funcMask } set funcMask(e) { this._funcMask = e } get opStencilFail() { return this._opStencilFail } set opStencilFail(e) { this._opStencilFail = e } get opDepthFail() { return this._opDepthFail } set opDepthFail(e) { this._opDepthFail = e } get opStencilDepthPass() { return this._opStencilDepthPass } set opStencilDepthPass(e) { this._opStencilDepthPass = e } get mask() { return this._mask } set mask(e) { this._mask = e } get enabled() { return this._enabled } set enabled(e) { this._enabled = e } getClassName() { return "MaterialStencilState" } copyTo(e) { re.Clone(() => e, this) } serialize() { return re.Serialize(this) } parse(e, t, i) { re.Parse(() => this, e, t, i) } } T([M()], pt.prototype, "func", null), T([M()], pt.prototype, "funcRef", null), T([M()], pt.prototype, "funcMask", null), T([M()], pt.prototype, "opStencilFail", null), T([M()], pt.prototype, "opDepthFail", null), T([M()], pt.prototype, "opStencilDepthPass", null), T([M()], pt.prototype, "mask", null), T([M()], pt.prototype, "enabled", null); var Ue; (function (c) { c[c.Created = 1] = "Created", c[c.Disposed = 2] = "Disposed", c[c.GetDefineNames = 4] = "GetDefineNames", c[c.PrepareUniformBuffer = 8] = "PrepareUniformBuffer", c[c.IsReadyForSubMesh = 16] = "IsReadyForSubMesh", c[c.PrepareDefines = 32] = "PrepareDefines", c[c.BindForSubMesh = 64] = "BindForSubMesh", c[c.PrepareEffect = 128] = "PrepareEffect", c[c.GetAnimatables = 256] = "GetAnimatables", c[c.GetActiveTextures = 512] = "GetActiveTextures", c[c.HasTexture = 1024] = "HasTexture", c[c.FillRenderTargetTextures = 2048] = "FillRenderTargetTextures", c[c.HasRenderTargetTextures = 4096] = "HasRenderTargetTextures", c[c.HardBindForSubMesh = 8192] = "HardBindForSubMesh" })(Ue || (Ue = {})); class I { get canRenderToMRT() { return !1 } set alpha(e) { if (this._alpha === e) return; const t = this._alpha; this._alpha = e, (t === 1 || e === 1) && this.markAsDirty(I.MiscDirtyFlag + I.PrePassDirtyFlag) } get alpha() { return this._alpha } set backFaceCulling(e) { this._backFaceCulling !== e && (this._backFaceCulling = e, this.markAsDirty(I.TextureDirtyFlag)) } get backFaceCulling() { return this._backFaceCulling } set cullBackFaces(e) { this._cullBackFaces !== e && (this._cullBackFaces = e, this.markAsDirty(I.TextureDirtyFlag)) } get cullBackFaces() { return this._cullBackFaces } get blockDirtyMechanism() { return this._blockDirtyMechanism } set blockDirtyMechanism(e) { this._blockDirtyMechanism !== e && (this._blockDirtyMechanism = e, e || this.markDirty()) } atomicMaterialsUpdate(e) { this.blockDirtyMechanism = !0; try { e(this) } finally { this.blockDirtyMechanism = !1 } } get hasRenderTargetTextures() { return this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._eventInfo.hasRenderTargetTextures } set onDispose(e) { this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e) } get onBindObservable() { return this._onBindObservable || (this._onBindObservable = new L), this._onBindObservable } set onBind(e) { this._onBindObserver && this.onBindObservable.remove(this._onBindObserver), this._onBindObserver = this.onBindObservable.add(e) } get onUnBindObservable() { return this._onUnBindObservable || (this._onUnBindObservable = new L), this._onUnBindObservable } get onEffectCreatedObservable() { return this._onEffectCreatedObservable || (this._onEffectCreatedObservable = new L), this._onEffectCreatedObservable } set alphaMode(e) { this._alphaMode !== e && (this._alphaMode = e, this.markAsDirty(I.TextureDirtyFlag)) } get alphaMode() { return this._alphaMode } set needDepthPrePass(e) { this._needDepthPrePass !== e && (this._needDepthPrePass = e, this._needDepthPrePass && (this.checkReadyOnEveryCall = !0)) } get needDepthPrePass() { return this._needDepthPrePass } get isPrePassCapable() { return !1 } set fogEnabled(e) { this._fogEnabled !== e && (this._fogEnabled = e, this.markAsDirty(I.MiscDirtyFlag)) } get fogEnabled() { return this._fogEnabled } get wireframe() { switch (this._fillMode) { case I.WireFrameFillMode: case I.LineListDrawMode: case I.LineLoopDrawMode: case I.LineStripDrawMode: return !0 }return this._scene.forceWireframe } set wireframe(e) { this.fillMode = e ? I.WireFrameFillMode : I.TriangleFillMode } get pointsCloud() { switch (this._fillMode) { case I.PointFillMode: case I.PointListDrawMode: return !0 }return this._scene.forcePointsCloud } set pointsCloud(e) { this.fillMode = e ? I.PointFillMode : I.TriangleFillMode } get fillMode() { return this._fillMode } set fillMode(e) { this._fillMode !== e && (this._fillMode = e, this.markAsDirty(I.MiscDirtyFlag)) } get useLogarithmicDepth() { return this._useLogarithmicDepth } set useLogarithmicDepth(e) { const t = this.getScene().getEngine().getCaps().fragmentDepthSupported; e && !t && O.Warn("Logarithmic depth has been requested for a material on a device that doesn't support it."), this._useLogarithmicDepth = e && t, this._markAllSubMeshesAsMiscDirty() } _getDrawWrapper() { return this._drawWrapper } _setDrawWrapper(e) { this._drawWrapper = e } constructor(e, t, i) { this.shadowDepthWrapper = null, this.allowShaderHotSwapping = !0, this.metadata = null, this.reservedDataStore = null, this.checkReadyOnEveryCall = !1, this.checkReadyOnlyOnce = !1, this.state = "", this._alpha = 1, this._backFaceCulling = !0, this._cullBackFaces = !0, this._blockDirtyMechanism = !1, this.onCompiled = null, this.onError = null, this.getRenderTargetTextures = null, this.doNotSerialize = !1, this._storeEffectOnSubMeshes = !1, this.animations = null, this.onDisposeObservable = new L, this._onDisposeObserver = null, this._onUnBindObservable = null, this._onBindObserver = null, this._alphaMode = 2, this._needDepthPrePass = !1, this.disableDepthWrite = !1, this.disableColorWrite = !1, this.forceDepthWrite = !1, this.depthFunction = 0, this.separateCullingPass = !1, this._fogEnabled = !0, this.pointSize = 1, this.zOffset = 0, this.zOffsetUnits = 0, this.stencil = new pt, this._useUBO = !1, this._fillMode = I.TriangleFillMode, this._cachedDepthWriteState = !1, this._cachedColorWriteState = !1, this._cachedDepthFunctionState = 0, this._indexInSceneMaterialArray = -1, this.meshMap = null, this._parentContainer = null, this._uniformBufferLayoutBuilt = !1, this._eventInfo = {}, this._callbackPluginEventGeneric = () => { }, this._callbackPluginEventIsReadyForSubMesh = () => { }, this._callbackPluginEventPrepareDefines = () => { }, this._callbackPluginEventPrepareDefinesBeforeAttributes = () => { }, this._callbackPluginEventHardBindForSubMesh = () => { }, this._callbackPluginEventBindForSubMesh = () => { }, this._callbackPluginEventHasRenderTargetTextures = () => { }, this._callbackPluginEventFillRenderTargetTextures = () => { }, this._forceAlphaTest = !1, this._transparencyMode = null, this.name = e; const s = t || ce.LastCreatedScene; s && (this._scene = s, this._dirtyCallbacks = {}, this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this), this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this), this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this), this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this), this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this), this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this), this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this), this.id = e || G.RandomId(), this.uniqueId = this._scene.getUniqueId(), this._materialContext = this._scene.getEngine().createMaterialContext(), this._drawWrapper = new Li(this._scene.getEngine(), !1), this._drawWrapper.materialContext = this._materialContext, this._scene.useRightHandedSystem ? this.sideOrientation = I.ClockWiseSideOrientation : this.sideOrientation = I.CounterClockWiseSideOrientation, this._uniformBuffer = new U(this._scene.getEngine(), void 0, void 0, e), this._useUBO = this.getScene().getEngine().supportsUniformBuffers, i || this._scene.addMaterial(this), this._scene.useMaterialMeshMap && (this.meshMap = {}), I.OnEventObservable.notifyObservers(this, Ue.Created)) } toString(e) { return "Name: " + this.name } getClassName() { return "Material" } get _isMaterial() { return !0 } get isFrozen() { return this.checkReadyOnlyOnce } freeze() { this.markDirty(), this.checkReadyOnlyOnce = !0 } unfreeze() { this.markDirty(), this.checkReadyOnlyOnce = !1 } isReady(e, t) { return !0 } isReadyForSubMesh(e, t, i) { const s = t.materialDefines; return s ? (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = s, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), this._eventInfo.isReadyForSubMesh) : !1 } getEffect() { return this._drawWrapper.effect } getScene() { return this._scene } get transparencyMode() { return this._transparencyMode } set transparencyMode(e) { this._transparencyMode !== e && (this._transparencyMode = e, this._forceAlphaTest = e === I.MATERIAL_ALPHATESTANDBLEND, this._markAllSubMeshesAsTexturesAndMiscDirty()) } get _disableAlphaBlending() { return this._transparencyMode === I.MATERIAL_OPAQUE || this._transparencyMode === I.MATERIAL_ALPHATEST } needAlphaBlending() { return this._disableAlphaBlending ? !1 : this.alpha < 1 } needAlphaBlendingForMesh(e) { return e.visibility < 1 ? !0 : this._disableAlphaBlending ? !1 : e.hasVertexAlpha || this.needAlphaBlending() } needAlphaTesting() { return !!this._forceAlphaTest } _shouldTurnAlphaTestOn(e) { return !this.needAlphaBlendingForMesh(e) && this.needAlphaTesting() } getAlphaTestTexture() { return null } markDirty(e = !1) { const t = this.getScene().meshes; for (const i of t) if (i.subMeshes) for (const s of i.subMeshes) s.getMaterial() === this && s.effect && (s.effect._wasPreviouslyReady = !1, s.effect._wasPreviouslyUsingInstances = null, s.effect._forceRebindOnNextCall = e); e && this.markAsDirty(I.AllDirtyFlag) } _preBind(e, t = null) { const i = this._scene.getEngine(), r = (t ?? this.sideOrientation) === I.ClockWiseSideOrientation; return i.enableEffect(e || this._getDrawWrapper()), i.setState(this.backFaceCulling, this.zOffset, !1, r, this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces, this.stencil, this.zOffsetUnits), r } bind(e, t) { } buildUniformLayout() { const e = this._uniformBuffer; this._eventInfo.ubo = e, this._callbackPluginEventGeneric(Ue.PrepareUniformBuffer, this._eventInfo), e.create(), this._uniformBufferLayoutBuilt = !0 } bindForSubMesh(e, t, i) { const s = i.effect; s && (this._eventInfo.subMesh = i, this._callbackPluginEventBindForSubMesh(this._eventInfo), s._forceRebindOnNextCall = !1) } bindOnlyWorldMatrix(e) { } bindView(e) { this._useUBO ? this._needToBindSceneUbo = !0 : e.setMatrix("view", this.getScene().getViewMatrix()) } bindViewProjection(e) { this._useUBO ? this._needToBindSceneUbo = !0 : (e.setMatrix("viewProjection", this.getScene().getTransformMatrix()), e.setMatrix("projection", this.getScene().getProjectionMatrix())) } bindEyePosition(e, t) { this._useUBO ? this._needToBindSceneUbo = !0 : this._scene.bindEyePosition(e, t) } _afterBind(e, t = null) { if (this._scene._cachedMaterial = this, this._needToBindSceneUbo && t && (this._needToBindSceneUbo = !1, le.BindSceneUniformBuffer(t, this.getScene().getSceneUniformBuffer()), this._scene.finalizeSceneUbo()), e ? this._scene._cachedVisibility = e.visibility : this._scene._cachedVisibility = 1, this._onBindObservable && e && this._onBindObservable.notifyObservers(e), this.disableDepthWrite) { const i = this._scene.getEngine(); this._cachedDepthWriteState = i.getDepthWrite(), i.setDepthWrite(!1) } if (this.disableColorWrite) { const i = this._scene.getEngine(); this._cachedColorWriteState = i.getColorWrite(), i.setColorWrite(!1) } if (this.depthFunction !== 0) { const i = this._scene.getEngine(); this._cachedDepthFunctionState = i.getDepthFunction() || 0, i.setDepthFunction(this.depthFunction) } } unbind() { this._onUnBindObservable && this._onUnBindObservable.notifyObservers(this), this.depthFunction !== 0 && this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState), this.disableDepthWrite && this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState), this.disableColorWrite && this._scene.getEngine().setColorWrite(this._cachedColorWriteState) } getAnimatables() { return this._eventInfo.animatables = [], this._callbackPluginEventGeneric(Ue.GetAnimatables, this._eventInfo), this._eventInfo.animatables } getActiveTextures() { return this._eventInfo.activeTextures = [], this._callbackPluginEventGeneric(Ue.GetActiveTextures, this._eventInfo), this._eventInfo.activeTextures } hasTexture(e) { return this._eventInfo.hasTexture = !1, this._eventInfo.texture = e, this._callbackPluginEventGeneric(Ue.HasTexture, this._eventInfo), this._eventInfo.hasTexture } clone(e) { return null } _clonePlugins(e, t) { const i = {}; if (this._serializePlugins(i), I._parsePlugins(i, e, this._scene, t), this.pluginManager) for (const s of this.pluginManager._plugins) { const r = e.pluginManager.getPlugin(s.name); s.copyTo(r) } } getBindedMeshes() { if (this.meshMap) { const e = []; for (const t in this.meshMap) { const i = this.meshMap[t]; i && e.push(i) } return e } else return this._scene.meshes.filter(t => t.material === this) } forceCompilation(e, t, i, s) { const r = Object.assign({ clipPlane: !1, useInstances: !1 }, i), n = this.getScene(), a = this.allowShaderHotSwapping; this.allowShaderHotSwapping = !1; const o = () => { if (!this._scene || !this._scene.getEngine()) return; const l = n.clipPlane; if (r.clipPlane && (n.clipPlane = new ot(0, 0, 0, 1)), this._storeEffectOnSubMeshes) { let h = !0, u = null; if (e.subMeshes) { const f = new nt(0, 0, 0, 0, 0, e, void 0, !1, !1); f.materialDefines && (f.materialDefines._renderId = -1), this.isReadyForSubMesh(e, f, r.useInstances) || (f.effect && f.effect.getCompilationError() && f.effect.allFallbacksProcessed() ? u = f.effect.getCompilationError() : (h = !1, setTimeout(o, 16))) } h && (this.allowShaderHotSwapping = a, u && s && s(u), t && t(this)) } else this.isReady() ? (this.allowShaderHotSwapping = a, t && t(this)) : setTimeout(o, 16); r.clipPlane && (n.clipPlane = l) }; o() } forceCompilationAsync(e, t) { return new Promise((i, s) => { this.forceCompilation(e, () => { i() }, t, r => { s(r) }) }) } markAsDirty(e) { this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism || (I._DirtyCallbackArray.length = 0, e & I.TextureDirtyFlag && I._DirtyCallbackArray.push(I._TextureDirtyCallBack), e & I.LightDirtyFlag && I._DirtyCallbackArray.push(I._LightsDirtyCallBack), e & I.FresnelDirtyFlag && I._DirtyCallbackArray.push(I._FresnelDirtyCallBack), e & I.AttributesDirtyFlag && I._DirtyCallbackArray.push(I._AttributeDirtyCallBack), e & I.MiscDirtyFlag && I._DirtyCallbackArray.push(I._MiscDirtyCallBack), e & I.PrePassDirtyFlag && I._DirtyCallbackArray.push(I._PrePassDirtyCallBack), I._DirtyCallbackArray.length && this._markAllSubMeshesAsDirty(I._RunDirtyCallBacks), this.getScene().resetCachedMaterial()) } resetDrawCache() { const e = this.getScene().meshes; for (const t of e) if (t.subMeshes) for (const i of t.subMeshes) i.getMaterial() === this && i.resetDrawCache() } _markAllSubMeshesAsDirty(e) { if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) return; const t = this.getScene().meshes; for (const i of t) if (i.subMeshes) { for (const s of i.subMeshes) if (s.getMaterial(!1) === this) for (const r of s._drawWrappers) !r || !r.defines || !r.defines.markAllAsDirty || this._materialContext === r.materialContext && e(r.defines) } } _markScenePrePassDirty() { if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) return; const e = this.getScene().enablePrePassRenderer(); e && e.markAsDirty() } _markAllSubMeshesAsAllDirty() { this._markAllSubMeshesAsDirty(I._AllDirtyCallBack) } _markAllSubMeshesAsImageProcessingDirty() { this._markAllSubMeshesAsDirty(I._ImageProcessingDirtyCallBack) } _markAllSubMeshesAsTexturesDirty() { this._markAllSubMeshesAsDirty(I._TextureDirtyCallBack) } _markAllSubMeshesAsFresnelDirty() { this._markAllSubMeshesAsDirty(I._FresnelDirtyCallBack) } _markAllSubMeshesAsFresnelAndMiscDirty() { this._markAllSubMeshesAsDirty(I._FresnelAndMiscDirtyCallBack) } _markAllSubMeshesAsLightsDirty() { this._markAllSubMeshesAsDirty(I._LightsDirtyCallBack) } _markAllSubMeshesAsAttributesDirty() { this._markAllSubMeshesAsDirty(I._AttributeDirtyCallBack) } _markAllSubMeshesAsMiscDirty() { this._markAllSubMeshesAsDirty(I._MiscDirtyCallBack) } _markAllSubMeshesAsPrePassDirty() { this._markAllSubMeshesAsDirty(I._MiscDirtyCallBack) } _markAllSubMeshesAsTexturesAndMiscDirty() { this._markAllSubMeshesAsDirty(I._TextureAndMiscDirtyCallBack) } _checkScenePerformancePriority() { if (this._scene.performancePriority !== ut.BackwardCompatible) { this.checkReadyOnlyOnce = !0; const e = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => { this.checkReadyOnlyOnce = !1 }); this.onDisposeObservable.add(() => { this._scene.onScenePerformancePriorityChangedObservable.remove(e) }) } } setPrePassRenderer(e) { return !1 } dispose(e, t, i) { const s = this.getScene(); if (s.stopAnimation(this), s.freeProcessedMaterials(), s.removeMaterial(this), this._eventInfo.forceDisposeTextures = t, this._callbackPluginEventGeneric(Ue.Disposed, this._eventInfo), this._parentContainer) { const r = this._parentContainer.materials.indexOf(this); r > -1 && this._parentContainer.materials.splice(r, 1), this._parentContainer = null } if (i !== !0) if (this.meshMap) for (const r in this.meshMap) { const n = this.meshMap[r]; n && (n.material = null, this.releaseVertexArrayObject(n, e)) } else { const r = s.meshes; for (const n of r) n.material === this && !n.sourceMesh && (n.material = null, this.releaseVertexArrayObject(n, e)) } this._uniformBuffer.dispose(), e && this._drawWrapper.effect && (this._storeEffectOnSubMeshes || this._drawWrapper.effect.dispose(), this._drawWrapper.effect = null), this.metadata = null, this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this._onBindObservable && this._onBindObservable.clear(), this._onUnBindObservable && this._onUnBindObservable.clear(), this._onEffectCreatedObservable && this._onEffectCreatedObservable.clear(), this._eventInfo && (this._eventInfo = {}) } releaseVertexArrayObject(e, t) { const i = e.geometry; if (i) if (this._storeEffectOnSubMeshes) { if (e.subMeshes) for (const s of e.subMeshes) i._releaseVertexArrayObject(s.effect), t && s.effect && s.effect.dispose() } else i._releaseVertexArrayObject(this._drawWrapper.effect) } serialize() { const e = re.Serialize(this); return e.stencil = this.stencil.serialize(), e.uniqueId = this.uniqueId, this._serializePlugins(e), e } _serializePlugins(e) { if (e.plugins = {}, this.pluginManager) for (const t of this.pluginManager._plugins) e.plugins[t.getClassName()] = t.serialize() } static Parse(e, t, i) { if (!e.customType) e.customType = "BABYLON.StandardMaterial"; else if (e.customType === "BABYLON.PBRMaterial" && e.overloadedAlbedo && (e.customType = "BABYLON.LegacyPBRMaterial", !BABYLON.LegacyPBRMaterial)) return O.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."), null; const r = G.Instantiate(e.customType).Parse(e, t, i); return r._loadedUniqueId = e.uniqueId, r } static _parsePlugins(e, t, i, s) { var r; if (e.plugins) for (const n in e.plugins) { const a = e.plugins[n]; let o = (r = t.pluginManager) === null || r === void 0 ? void 0 : r.getPlugin(a.name); if (!o) { const l = G.Instantiate("BABYLON." + n); l && (o = new l(t)) } o == null || o.parse(a, i, s) } } } I.TriangleFillMode = 0, I.WireFrameFillMode = 1, I.PointFillMode = 2, I.PointListDrawMode = 3, I.LineListDrawMode = 4, I.LineLoopDrawMode = 5, I.LineStripDrawMode = 6, I.TriangleStripDrawMode = 7, I.TriangleFanDrawMode = 8, I.ClockWiseSideOrientation = 0, I.CounterClockWiseSideOrientation = 1, I.TextureDirtyFlag = 1, I.LightDirtyFlag = 2, I.FresnelDirtyFlag = 4, I.AttributesDirtyFlag = 8, I.MiscDirtyFlag = 16, I.PrePassDirtyFlag = 32, I.AllDirtyFlag = 63, I.MATERIAL_OPAQUE = 0, I.MATERIAL_ALPHATEST = 1, I.MATERIAL_ALPHABLEND = 2, I.MATERIAL_ALPHATESTANDBLEND = 3, I.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0, I.MATERIAL_NORMALBLENDMETHOD_RNM = 1, I.OnEventObservable = new L, I._AllDirtyCallBack = c => c.markAllAsDirty(), I._ImageProcessingDirtyCallBack = c => c.markAsImageProcessingDirty(), I._TextureDirtyCallBack = c => c.markAsTexturesDirty(), I._FresnelDirtyCallBack = c => c.markAsFresnelDirty(), I._MiscDirtyCallBack = c => c.markAsMiscDirty(), I._PrePassDirtyCallBack = c => c.markAsPrePassDirty(), I._LightsDirtyCallBack = c => c.markAsLightDirty(), I._AttributeDirtyCallBack = c => c.markAsAttributesDirty(), I._FresnelAndMiscDirtyCallBack = c => { I._FresnelDirtyCallBack(c), I._MiscDirtyCallBack(c) }, I._TextureAndMiscDirtyCallBack = c => { I._TextureDirtyCallBack(c), I._MiscDirtyCallBack(c) }, I._DirtyCallbackArray = [], I._RunDirtyCallBacks = c => { for (const e of I._DirtyCallbackArray) e(c) }, T([M()], I.prototype, "id", void 0), T([M()], I.prototype, "uniqueId", void 0), T([M()], I.prototype, "name", void 0), T([M()], I.prototype, "metadata", void 0), T([M()], I.prototype, "checkReadyOnEveryCall", void 0), T([M()], I.prototype, "checkReadyOnlyOnce", void 0), T([M()], I.prototype, "state", void 0), T([M("alpha")], I.prototype, "_alpha", void 0), T([M("backFaceCulling")], I.prototype, "_backFaceCulling", void 0), T([M("cullBackFaces")], I.prototype, "_cullBackFaces", void 0), T([M()], I.prototype, "sideOrientation", void 0), T([M("alphaMode")], I.prototype, "_alphaMode", void 0), T([M()], I.prototype, "_needDepthPrePass", void 0), T([M()], I.prototype, "disableDepthWrite", void 0), T([M()], I.prototype, "disableColorWrite", void 0), T([M()], I.prototype, "forceDepthWrite", void 0), T([M()], I.prototype, "depthFunction", void 0), T([M()], I.prototype, "separateCullingPass", void 0), T([M("fogEnabled")], I.prototype, "_fogEnabled", void 0), T([M()], I.prototype, "pointSize", void 0), T([M()], I.prototype, "zOffset", void 0), T([M()], I.prototype, "zOffsetUnits", void 0), T([M()], I.prototype, "pointsCloud", null), T([M()], I.prototype, "fillMode", null), T([M()], I.prototype, "useLogarithmicDepth", null), T([M()], I.prototype, "transparencyMode", null); class Kt extends I { get subMaterials() { return this._subMaterials } set subMaterials(e) { this._subMaterials = e, this._hookArray(e) } getChildren() { return this.subMaterials } constructor(e, t) { super(e, t, !0), this._waitingSubMaterialsUniqueIds = [], this.getScene().addMultiMaterial(this), this.subMaterials = [], this._storeEffectOnSubMeshes = !0 } _hookArray(e) { const t = e.push; e.push = (...s) => { const r = t.apply(e, s); return this._markAllSubMeshesAsTexturesDirty(), r }; const i = e.splice; e.splice = (s, r) => { const n = i.apply(e, [s, r]); return this._markAllSubMeshesAsTexturesDirty(), n } } getSubMaterial(e) { return e < 0 || e >= this.subMaterials.length ? this.getScene().defaultMaterial : this.subMaterials[e] } getActiveTextures() { return super.getActiveTextures().concat(...this.subMaterials.map(e => e ? e.getActiveTextures() : [])) } hasTexture(e) { var t; if (super.hasTexture(e)) return !0; for (let i = 0; i < this.subMaterials.length; i++)if (!((t = this.subMaterials[i]) === null || t === void 0) && t.hasTexture(e)) return !0; return !1 } getClassName() { return "MultiMaterial" } isReadyForSubMesh(e, t, i) { for (let s = 0; s < this.subMaterials.length; s++) { const r = this.subMaterials[s]; if (r) { if (r._storeEffectOnSubMeshes) { if (!r.isReadyForSubMesh(e, t, i)) return !1; continue } if (!r.isReady(e)) return !1 } } return !0 } clone(e, t) { const i = new Kt(e, this.getScene()); for (let s = 0; s < this.subMaterials.length; s++) { let r = null; const n = this.subMaterials[s]; t && n ? r = n.clone(e + "-" + n.name) : r = this.subMaterials[s], i.subMaterials.push(r) } return i } serialize() { const e = {}; e.name = this.name, e.id = this.id, e.uniqueId = this.uniqueId, ne && (e.tags = ne.GetTags(this)), e.materialsUniqueIds = [], e.materials = []; for (let t = 0; t < this.subMaterials.length; t++) { const i = this.subMaterials[t]; i ? (e.materialsUniqueIds.push(i.uniqueId), e.materials.push(i.id)) : (e.materialsUniqueIds.push(null), e.materials.push(null)) } return e } dispose(e, t, i) { const s = this.getScene(); if (!s) return; if (i) for (let n = 0; n < this.subMaterials.length; n++) { const a = this.subMaterials[n]; a && a.dispose(e, t) } const r = s.multiMaterials.indexOf(this); r >= 0 && s.multiMaterials.splice(r, 1), super.dispose(e, t) } static ParseMultiMaterial(e, t) { const i = new Kt(e.name, t); return i.id = e.id, i._loadedUniqueId = e.uniqueId, ne && ne.AddTagsTo(i, e.tags), e.materialsUniqueIds ? i._waitingSubMaterialsUniqueIds = e.materialsUniqueIds : e.materials.forEach(s => i.subMaterials.push(t.getLastMaterialById(s))), i } } at("BABYLON.MultiMaterial", Kt); class dn { constructor(e, t) { this.distanceOrScreenCoverage = e, this.mesh = t } } class _n { constructor() { this.visibleInstances = {}, this.batchCache = new Hs, this.batchCacheReplacementModeInFrozenMode = new Hs, this.instancesBufferSize = 32 * 16 * 4 } } class Hs { constructor() { this.mustReturn = !1, this.visibleInstances = new Array, this.renderSelf = [], this.hardwareInstancedRendering = [] } } class gn { constructor() { this.instancesCount = 0, this.matrixBuffer = null, this.previousMatrixBuffer = null, this.matrixBufferSize = 32 * 16, this.matrixData = null, this.boundingVectors = [], this.worldMatrices = null } } class mn { constructor() { this._areNormalsFrozen = !1, this._source = null, this.meshMap = null, this._preActivateId = -1, this._LODLevels = new Array, this._useLODScreenCoverage = !1, this._effectiveMaterial = null, this._forcedInstanceCount = 0, this._overrideRenderingFillMode = null } } class ie extends Je {
        static _GetDefaultSideOrientation(e) { return e || ie.FRONTSIDE } get useLODScreenCoverage() { return this._internalMeshDataInfo._useLODScreenCoverage } set useLODScreenCoverage(e) { this._internalMeshDataInfo._useLODScreenCoverage = e, this._sortLODLevels() } get computeBonesUsingShaders() { return this._internalAbstractMeshDataInfo._computeBonesUsingShaders } set computeBonesUsingShaders(e) { this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== e && (e && this._internalMeshDataInfo._sourcePositions && (this.setVerticesData(d.PositionKind, this._internalMeshDataInfo._sourcePositions, !0), this._internalMeshDataInfo._sourceNormals && this.setVerticesData(d.NormalKind, this._internalMeshDataInfo._sourceNormals, !0), this._internalMeshDataInfo._sourcePositions = null, this._internalMeshDataInfo._sourceNormals = null), this._internalAbstractMeshDataInfo._computeBonesUsingShaders = e, this._markSubMeshesAsAttributesDirty()) } get onBeforeRenderObservable() { return this._internalMeshDataInfo._onBeforeRenderObservable || (this._internalMeshDataInfo._onBeforeRenderObservable = new L), this._internalMeshDataInfo._onBeforeRenderObservable } get onBeforeBindObservable() { return this._internalMeshDataInfo._onBeforeBindObservable || (this._internalMeshDataInfo._onBeforeBindObservable = new L), this._internalMeshDataInfo._onBeforeBindObservable } get onAfterRenderObservable() { return this._internalMeshDataInfo._onAfterRenderObservable || (this._internalMeshDataInfo._onAfterRenderObservable = new L), this._internalMeshDataInfo._onAfterRenderObservable } get onBetweenPassObservable() { return this._internalMeshDataInfo._onBetweenPassObservable || (this._internalMeshDataInfo._onBetweenPassObservable = new L), this._internalMeshDataInfo._onBetweenPassObservable } get onBeforeDrawObservable() { return this._internalMeshDataInfo._onBeforeDrawObservable || (this._internalMeshDataInfo._onBeforeDrawObservable = new L), this._internalMeshDataInfo._onBeforeDrawObservable } set onBeforeDraw(e) { this._onBeforeDrawObserver && this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver), this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(e) } get hasInstances() { return this.instances.length > 0 } get hasThinInstances() { return (this.forcedInstanceCount || this._thinInstanceDataStorage.instancesCount || 0) > 0 } get forcedInstanceCount() { return this._internalMeshDataInfo._forcedInstanceCount } set forcedInstanceCount(e) { this._internalMeshDataInfo._forcedInstanceCount = e } get overrideRenderingFillMode() { return this._internalMeshDataInfo._overrideRenderingFillMode } set overrideRenderingFillMode(e) { this._internalMeshDataInfo._overrideRenderingFillMode = e } get source() { return this._internalMeshDataInfo._source } get cloneMeshMap() { return this._internalMeshDataInfo.meshMap } get isUnIndexed() { return this._unIndexed } set isUnIndexed(e) { this._unIndexed !== e && (this._unIndexed = e, this._markSubMeshesAsAttributesDirty()) } get worldMatrixInstancedBuffer() { return this._instanceDataStorage.instancesData } get previousWorldMatrixInstancedBuffer() { return this._instanceDataStorage.instancesPreviousData } get manualUpdateOfWorldMatrixInstancedBuffer() { return this._instanceDataStorage.manualUpdate } set manualUpdateOfWorldMatrixInstancedBuffer(e) { this._instanceDataStorage.manualUpdate = e } get manualUpdateOfPreviousWorldMatrixInstancedBuffer() { return this._instanceDataStorage.previousManualUpdate } set manualUpdateOfPreviousWorldMatrixInstancedBuffer(e) { this._instanceDataStorage.previousManualUpdate = e } get forceWorldMatrixInstancedBufferUpdate() { return this._instanceDataStorage.forceMatrixUpdates } set forceWorldMatrixInstancedBufferUpdate(e) { this._instanceDataStorage.forceMatrixUpdates = e } constructor(e, t = null, i = null, s = null, r, n = !0) { if (super(e, t), this._internalMeshDataInfo = new mn, this.delayLoadState = 0, this.instances = [], this._creationDataStorage = null, this._geometry = null, this._instanceDataStorage = new _n, this._thinInstanceDataStorage = new gn, this._shouldGenerateFlatShading = !1, this._originalBuilderSideOrientation = ie.DEFAULTSIDE, this.overrideMaterialSideOrientation = null, this.ignoreCameraMaxZ = !1, t = this.getScene(), this._onBeforeDraw = (a, o, l) => { a && l && (this._uniformBuffer ? this.transferToEffect(o) : l.bindOnlyWorldMatrix(o)) }, s) { if (s._geometry && s._geometry.applyToMesh(this), us.DeepCopy(s, this, ["name", "material", "skeleton", "instances", "parent", "uniqueId", "source", "metadata", "morphTargetManager", "hasInstances", "worldMatrixInstancedBuffer", "previousWorldMatrixInstancedBuffer", "hasLODLevels", "geometry", "isBlocked", "areNormalsFrozen", "facetNb", "isFacetDataEnabled", "lightSources", "useBones", "isAnInstance", "collider", "edgesRenderer", "forward", "up", "right", "absolutePosition", "absoluteScaling", "absoluteRotationQuaternion", "isWorldMatrixFrozen", "nonUniformScaling", "behaviors", "worldMatrixFromCache", "hasThinInstances", "cloneMeshMap", "hasBoundingInfo", "physicsBody", "physicsImpostor"], ["_poseMatrix"]), this._internalMeshDataInfo._source = s, t.useClonedMeshMap && (s._internalMeshDataInfo.meshMap || (s._internalMeshDataInfo.meshMap = {}), s._internalMeshDataInfo.meshMap[this.uniqueId] = this), this._originalBuilderSideOrientation = s._originalBuilderSideOrientation, this._creationDataStorage = s._creationDataStorage, s._ranges) { const a = s._ranges; for (const o in a) Object.prototype.hasOwnProperty.call(a, o) && a[o] && this.createAnimationRange(o, a[o].from, a[o].to) } if (s.metadata && s.metadata.clone ? this.metadata = s.metadata.clone() : this.metadata = s.metadata, this._internalMetadata = s._internalMetadata, ne && ne.HasTags(s) && ne.AddTagsTo(this, ne.GetTags(s, !0)), this.setEnabled(s.isEnabled(!1)), this.parent = s.parent, this.setPivotMatrix(s.getPivotMatrix()), this.id = e + "." + s.id, this.material = s.material, !r) { const a = s.getDescendants(!0); for (let o = 0; o < a.length; o++) { const l = a[o]; l.clone && l.clone(e + "." + l.name, this) } } if (s.morphTargetManager && (this.morphTargetManager = s.morphTargetManager), t.getPhysicsEngine) { const a = t.getPhysicsEngine(); if (n && a) if (a.getPluginVersion() === 1) { const o = a.getImpostorForPhysicsObject(s); o && (this.physicsImpostor = o.clone(this)) } else a.getPluginVersion() === 2 && s.physicsBody && s.physicsBody.clone(this) } for (let a = 0; a < t.particleSystems.length; a++) { const o = t.particleSystems[a]; o.emitter === s && o.clone(o.name, this) } this.skeleton = s.skeleton, this.refreshBoundingInfo(!0, !0), this.computeWorldMatrix(!0) } i !== null && (this.parent = i), this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays, this._internalMeshDataInfo._onMeshReadyObserverAdded = a => { a.unregisterOnNextCall = !0, this.isReady(!0) ? this.onMeshReadyObservable.notifyObservers(this) : this._internalMeshDataInfo._checkReadinessObserver || (this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(() => { this.isReady(!0) && (this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver), this._internalMeshDataInfo._checkReadinessObserver = null, this.onMeshReadyObservable.notifyObservers(this)) })) }, this.onMeshReadyObservable = new L(this._internalMeshDataInfo._onMeshReadyObserverAdded), s && s.onClonedObservable.notifyObservers(this) } instantiateHierarchy(e = null, t, i) { const s = this.getTotalVertices() === 0 || t && t.doNotInstantiate && (t.doNotInstantiate === !0 || t.doNotInstantiate(this)) ? this.clone("Clone of " + (this.name || this.id), e || this.parent, !0) : this.createInstance("instance of " + (this.name || this.id)); s.parent = e || this.parent, s.position = this.position.clone(), s.scaling = this.scaling.clone(), this.rotationQuaternion ? s.rotationQuaternion = this.rotationQuaternion.clone() : s.rotation = this.rotation.clone(), i && i(this, s); for (const r of this.getChildTransformNodes(!0)) r.getClassName() === "InstancedMesh" && s.getClassName() === "Mesh" && r.sourceMesh === this ? r.instantiateHierarchy(s, { doNotInstantiate: t && t.doNotInstantiate || !1, newSourcedMesh: s }, i) : r.instantiateHierarchy(s, t, i); return s } getClassName() { return "Mesh" } get _isMesh() { return !0 } toString(e) { let t = super.toString(e); if (t += ", n vertices: " + this.getTotalVertices(), t += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE"), this.animations) for (let i = 0; i < this.animations.length; i++)t += ", animation[0]: " + this.animations[i].toString(e); if (e) if (this._geometry) { const i = this.getIndices(), s = this.getVerticesData(d.PositionKind); s && i && (t += ", flat shading: " + (s.length / 3 === i.length ? "YES" : "NO")) } else t += ", flat shading: UNKNOWN"; return t } _unBindEffect() { super._unBindEffect(); for (const e of this.instances) e._unBindEffect() } get hasLODLevels() { return this._internalMeshDataInfo._LODLevels.length > 0 } getLODLevels() { return this._internalMeshDataInfo._LODLevels } _sortLODLevels() { const e = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1; this._internalMeshDataInfo._LODLevels.sort((t, i) => t.distanceOrScreenCoverage < i.distanceOrScreenCoverage ? e : t.distanceOrScreenCoverage > i.distanceOrScreenCoverage ? -e : 0) } addLODLevel(e, t) { if (t && t._masterMesh) return O.Warn("You cannot use a mesh as LOD level twice"), this; const i = new dn(e, t); return this._internalMeshDataInfo._LODLevels.push(i), t && (t._masterMesh = this), this._sortLODLevels(), this } getLODLevelAtDistance(e) { const t = this._internalMeshDataInfo; for (let i = 0; i < t._LODLevels.length; i++) { const s = t._LODLevels[i]; if (s.distanceOrScreenCoverage === e) return s.mesh } return null } removeLODLevel(e) { const t = this._internalMeshDataInfo; for (let i = 0; i < t._LODLevels.length; i++)t._LODLevels[i].mesh === e && (t._LODLevels.splice(i, 1), e && (e._masterMesh = null)); return this._sortLODLevels(), this } getLOD(e, t) { const i = this._internalMeshDataInfo; if (!i._LODLevels || i._LODLevels.length === 0) return this; const s = t || this.getBoundingInfo().boundingSphere, r = e.mode === Q.ORTHOGRAPHIC_CAMERA ? e.minZ : s.centerWorld.subtract(e.globalPosition).length(); let n = r, a = 1; if (i._useLODScreenCoverage) { const o = e.screenArea; let l = s.radiusWorld * e.minZ / r; l = l * l * Math.PI, n = l / o, a = -1 } if (a * i._LODLevels[i._LODLevels.length - 1].distanceOrScreenCoverage > a * n) return this.onLODLevelSelection && this.onLODLevelSelection(n, this, this), this; for (let o = 0; o < i._LODLevels.length; o++) { const l = i._LODLevels[o]; if (a * l.distanceOrScreenCoverage < a * n) { if (l.mesh) { if (l.mesh.delayLoadState === 4) return l.mesh._checkDelayState(), this; if (l.mesh.delayLoadState === 2) return this; l.mesh._preActivate(), l.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache) } return this.onLODLevelSelection && this.onLODLevelSelection(n, this, l.mesh), l.mesh } } return this.onLODLevelSelection && this.onLODLevelSelection(n, this, this), this } get geometry() { return this._geometry } getTotalVertices() { return this._geometry === null || this._geometry === void 0 ? 0 : this._geometry.getTotalVertices() } getVerticesData(e, t, i, s) { var r, n; if (!this._geometry) return null; let a = s || (n = (r = this._userInstancedBuffersStorage) === null || r === void 0 ? void 0 : r.vertexBuffers[e]) === null || n === void 0 ? void 0 : n.getFloatData(this.instances.length + 1, i || t && this._geometry.meshes.length !== 1); return a || (a = this._geometry.getVerticesData(e, t, i)), a } getVertexBuffer(e, t) { var i, s; return this._geometry ? (s = t || (i = this._userInstancedBuffersStorage) === null || i === void 0 ? void 0 : i.vertexBuffers[e]) !== null && s !== void 0 ? s : this._geometry.getVertexBuffer(e) : null } isVerticesDataPresent(e, t) { var i; return this._geometry ? !t && ((i = this._userInstancedBuffersStorage) === null || i === void 0 ? void 0 : i.vertexBuffers[e]) !== void 0 || this._geometry.isVerticesDataPresent(e) : this._delayInfo ? this._delayInfo.indexOf(e) !== -1 : !1 } isVertexBufferUpdatable(e, t) { var i; if (!this._geometry) return this._delayInfo ? this._delayInfo.indexOf(e) !== -1 : !1; if (!t) { const s = (i = this._userInstancedBuffersStorage) === null || i === void 0 ? void 0 : i.vertexBuffers[e]; if (s) return s.isUpdatable() } return this._geometry.isVertexBufferUpdatable(e) } getVerticesDataKinds(e) { if (!this._geometry) { const i = []; return this._delayInfo && this._delayInfo.forEach(function (s) { i.push(s) }), i } const t = this._geometry.getVerticesDataKinds(); if (!e && this._userInstancedBuffersStorage) for (const i in this._userInstancedBuffersStorage.vertexBuffers) t.indexOf(i) === -1 && t.push(i); return t } getTotalIndices() { return this._geometry ? this._geometry.getTotalIndices() : 0 } getIndices(e, t) { return this._geometry ? this._geometry.getIndices(e, t) : [] } get isBlocked() { return this._masterMesh !== null && this._masterMesh !== void 0 } isReady(e = !1, t = !1) { var i, s, r, n, a, o, l; if (this.delayLoadState === 2 || !super.isReady(e)) return !1; if (!this.subMeshes || this.subMeshes.length === 0 || !e) return !0; const h = this.getEngine(), u = this.getScene(), f = t || h.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances); this.computeWorldMatrix(); const _ = this.material || u.defaultMaterial; if (_) { if (_._storeEffectOnSubMeshes) for (const v of this.subMeshes) { const E = v.getMaterial(); if (E) { if (E._storeEffectOnSubMeshes) { if (!E.isReadyForSubMesh(this, v, f)) return !1 } else if (!E.isReady(this, f)) return !1 } } else if (!_.isReady(this, f)) return !1 } const p = h.currentRenderPassId; for (const v of this.lightSources) { const E = v.getShadowGenerators(); if (!E) continue; const m = E.values(); for (let x = m.next(); x.done !== !0; x = m.next()) { const C = x.value; if (C && (!(!((i = C.getShadowMap()) === null || i === void 0) && i.renderList) || !((s = C.getShadowMap()) === null || s === void 0) && s.renderList && ((n = (r = C.getShadowMap()) === null || r === void 0 ? void 0 : r.renderList) === null || n === void 0 ? void 0 : n.indexOf(this)) !== -1)) { const y = (a = C.getShadowMap().renderPassIds) !== null && a !== void 0 ? a : [h.currentRenderPassId]; for (let b = 0; b < y.length; ++b) { h.currentRenderPassId = y[b]; for (const R of this.subMeshes) if (!C.isReady(R, f, (l = (o = R.getMaterial()) === null || o === void 0 ? void 0 : o.needAlphaBlendingForMesh(this)) !== null && l !== void 0 ? l : !1)) return h.currentRenderPassId = p, !1 } h.currentRenderPassId = p } } } for (const v of this._internalMeshDataInfo._LODLevels) if (v.mesh && !v.mesh.isReady(f)) return !1; return !0 } get areNormalsFrozen() { return this._internalMeshDataInfo._areNormalsFrozen } freezeNormals() { return this._internalMeshDataInfo._areNormalsFrozen = !0, this } unfreezeNormals() { return this._internalMeshDataInfo._areNormalsFrozen = !1, this } set overridenInstanceCount(e) { this._instanceDataStorage.overridenInstanceCount = e } _preActivate() { const e = this._internalMeshDataInfo, t = this.getScene().getRenderId(); return e._preActivateId === t ? this : (e._preActivateId = t, this._instanceDataStorage.visibleInstances = null, this) } _preActivateForIntermediateRendering(e) { return this._instanceDataStorage.visibleInstances && (this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = e), this } _registerInstanceForRenderId(e, t) { return this._instanceDataStorage.visibleInstances || (this._instanceDataStorage.visibleInstances = { defaultRenderId: t, selfDefaultRenderId: this._renderId }), this._instanceDataStorage.visibleInstances[t] || (this._instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen && (this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null), this._instanceDataStorage.previousRenderId = t, this._instanceDataStorage.visibleInstances[t] = new Array), this._instanceDataStorage.visibleInstances[t].push(e), this } _afterComputeWorldMatrix() { super._afterComputeWorldMatrix(), this.hasThinInstances && (this.doNotSyncBoundingInfo || this.thinInstanceRefreshBoundingInfo(!1)) } _postActivate() { this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup && (this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer), this.edgesRenderer.customInstances.push(this.getWorldMatrix())) } refreshBoundingInfo(e = !1, t = !1) { if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) return this; const i = this.geometry ? this.geometry.boundingBias : null; return this._refreshBoundingInfo(this._getPositionData(e, t), i), this } _createGlobalSubMesh(e) { const t = this.getTotalVertices(); if (!t || !this.getIndices()) return null; if (this.subMeshes && this.subMeshes.length > 0) { const i = this.getIndices(); if (!i) return null; const s = i.length; let r = !1; if (e) r = !0; else for (const n of this.subMeshes) { if (n.indexStart + n.indexCount > s) { r = !0; break } if (n.verticesStart + n.verticesCount > t) { r = !0; break } } if (!r) return this.subMeshes[0] } return this.releaseSubMeshes(), new nt(0, 0, t, 0, this.getTotalIndices(), this) } subdivide(e) { if (e < 1) return; const t = this.getTotalIndices(); let i = t / e | 0, s = 0; for (; i % 3 !== 0;)i++; this.releaseSubMeshes(); for (let r = 0; r < e && !(s >= t); r++)nt.CreateFromIndices(0, s, r === e - 1 ? t - s : i, this, void 0, !1), s += i; this.refreshBoundingInfo(), this.synchronizeInstances() } setVerticesData(e, t, i = !1, s) { if (this._geometry) this._geometry.setVerticesData(e, t, i, s); else { const r = new Y; r.set(t, e); const n = this.getScene(); new Ge(Ge.RandomId(), n, r, i, this) } return this } removeVerticesData(e) { this._geometry && this._geometry.removeVerticesData(e) } markVerticesDataAsUpdatable(e, t = !0) { const i = this.getVertexBuffer(e); !i || i.isUpdatable() === t || this.setVerticesData(e, this.getVerticesData(e), t) } setVerticesBuffer(e, t = !0) { return this._geometry || (this._geometry = Ge.CreateGeometryForMesh(this)), this._geometry.setVerticesBuffer(e, null, t), this } updateVerticesData(e, t, i, s) { return this._geometry ? (s ? (this.makeGeometryUnique(), this.updateVerticesData(e, t, i, !1)) : this._geometry.updateVerticesData(e, t, i), this) : this } updateMeshPositions(e, t = !0) { const i = this.getVerticesData(d.PositionKind); if (!i) return this; if (e(i), this.updateVerticesData(d.PositionKind, i, !1, !1), t) { const s = this.getIndices(), r = this.getVerticesData(d.NormalKind); if (!r) return this; Y.ComputeNormals(i, s, r), this.updateVerticesData(d.NormalKind, r, !1, !1) } return this } makeGeometryUnique() { if (!this._geometry) return this; if (this._geometry.meshes.length === 1) return this; const e = this._geometry, t = this._geometry.copy(Ge.RandomId()); return e.releaseForMesh(this, !0), t.applyToMesh(this), this } setIndexBuffer(e, t, i) { let s = this._geometry; s || (s = new Ge(Ge.RandomId(), this.getScene(), void 0, void 0, this)), s.setIndexBuffer(e, t, i) } setIndices(e, t = null, i = !1) { if (this._geometry) this._geometry.setIndices(e, t, i); else { const s = new Y; s.indices = e; const r = this.getScene(); new Ge(Ge.RandomId(), r, s, i, this) } return this } updateIndices(e, t, i = !1) { return this._geometry ? (this._geometry.updateIndices(e, t, i), this) : this } toLeftHanded() { return this._geometry ? (this._geometry.toLeftHanded(), this) : this } _bind(e, t, i, s = !0) { if (!this._geometry) return this; const r = this.getScene().getEngine(); this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets && this.morphTargetManager._bind(t); let n; if (this._unIndexed) n = null; else switch (this._getRenderingFillMode(i)) { case I.PointFillMode: n = null; break; case I.WireFrameFillMode: n = e._getLinesIndexBuffer(this.getIndices(), r); break; default: case I.TriangleFillMode: n = this._geometry.getIndexBuffer(); break }return !s || !this._userInstancedBuffersStorage || this.hasThinInstances ? this._geometry._bind(t, n) : this._geometry._bind(t, n, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects), this } _draw(e, t, i) { if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) return this; this._internalMeshDataInfo._onBeforeDrawObservable && this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this); const r = this.getScene().getEngine(); return this._unIndexed || t == I.PointFillMode ? r.drawArraysType(t, e.verticesStart, e.verticesCount, this.forcedInstanceCount || i) : t == I.WireFrameFillMode ? r.drawElementsType(t, 0, e._linesIndexCount, this.forcedInstanceCount || i) : r.drawElementsType(t, e.indexStart, e.indexCount, this.forcedInstanceCount || i), this } registerBeforeRender(e) { return this.onBeforeRenderObservable.add(e), this } unregisterBeforeRender(e) { return this.onBeforeRenderObservable.removeCallback(e), this } registerAfterRender(e) { return this.onAfterRenderObservable.add(e), this } unregisterAfterRender(e) { return this.onAfterRenderObservable.removeCallback(e), this } _getInstancesRenderList(e, t = !1) { if (this._instanceDataStorage.isFrozen) { if (t) return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[e] = !1, this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[e] = !0, this._instanceDataStorage.batchCacheReplacementModeInFrozenMode; if (this._instanceDataStorage.previousBatch) return this._instanceDataStorage.previousBatch } const i = this.getScene(), s = i._isInIntermediateRendering(), r = s ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances, n = this._instanceDataStorage.batchCache; if (n.mustReturn = !1, n.renderSelf[e] = t || !r && this.isEnabled() && this.isVisible, n.visibleInstances[e] = null, this._instanceDataStorage.visibleInstances && !t) { const a = this._instanceDataStorage.visibleInstances, o = i.getRenderId(), l = s ? a.intermediateDefaultRenderId : a.defaultRenderId; n.visibleInstances[e] = a[o], !n.visibleInstances[e] && l && (n.visibleInstances[e] = a[l]) } return n.hardwareInstancedRendering[e] = !t && this._instanceDataStorage.hardwareInstancedRendering && n.visibleInstances[e] !== null && n.visibleInstances[e] !== void 0, this._instanceDataStorage.previousBatch = n, n } _renderWithInstances(e, t, i, s, r) { var n; const a = i.visibleInstances[e._id], o = a ? a.length : 0, l = this._instanceDataStorage, h = l.instancesBufferSize; let u = l.instancesBuffer, f = l.instancesPreviousBuffer; const p = (o + 1) * 16 * 4; for (; l.instancesBufferSize < p;)l.instancesBufferSize *= 2; (!l.instancesData || h != l.instancesBufferSize) && (l.instancesData = new Float32Array(l.instancesBufferSize / 4)), (this._scene.needsPreviousWorldMatrices && !l.instancesPreviousData || h != l.instancesBufferSize) && (l.instancesPreviousData = new Float32Array(l.instancesBufferSize / 4)); let v = 0, E = 0; const m = i.renderSelf[e._id], x = !u || h !== l.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !l.instancesPreviousBuffer; if (!this._instanceDataStorage.manualUpdate && (!l.isFrozen || x)) { const C = this.getWorldMatrix(); if (m && (this._scene.needsPreviousWorldMatrices && (l.masterMeshPreviousWorldMatrix ? (l.masterMeshPreviousWorldMatrix.copyToArray(l.instancesPreviousData, v), l.masterMeshPreviousWorldMatrix.copyFrom(C)) : (l.masterMeshPreviousWorldMatrix = C.clone(), l.masterMeshPreviousWorldMatrix.copyToArray(l.instancesPreviousData, v))), C.copyToArray(l.instancesData, v), v += 16, E++), a) { if (ie.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && (!((n = e.getMaterial()) === null || n === void 0) && n.needAlphaBlendingForMesh(e.getRenderingMesh()))) { const S = this._scene.activeCamera.globalPosition; for (let y = 0; y < a.length; y++) { const b = a[y]; b._distanceToCamera = g.Distance(b.getBoundingInfo().boundingSphere.centerWorld, S) } a.sort((y, b) => y._distanceToCamera > b._distanceToCamera ? -1 : y._distanceToCamera < b._distanceToCamera ? 1 : 0) } for (let S = 0; S < a.length; S++) { const y = a[S], b = y.getWorldMatrix(); b.copyToArray(l.instancesData, v), this._scene.needsPreviousWorldMatrices && (y._previousWorldMatrix ? (y._previousWorldMatrix.copyToArray(l.instancesPreviousData, v), y._previousWorldMatrix.copyFrom(b)) : (y._previousWorldMatrix = b.clone(), y._previousWorldMatrix.copyToArray(l.instancesPreviousData, v))), v += 16, E++ } } } else E = (m ? 1 : 0) + o; return x ? (u && u.dispose(), f && f.dispose(), u = new Ai(r, l.instancesData, !0, 16, !1, !0), l.instancesBuffer = u, this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = { data: {}, vertexBuffers: {}, strides: {}, sizes: {}, vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0 }), this._userInstancedBuffersStorage.vertexBuffers.world0 = u.createVertexBuffer("world0", 0, 4), this._userInstancedBuffersStorage.vertexBuffers.world1 = u.createVertexBuffer("world1", 4, 4), this._userInstancedBuffersStorage.vertexBuffers.world2 = u.createVertexBuffer("world2", 8, 4), this._userInstancedBuffersStorage.vertexBuffers.world3 = u.createVertexBuffer("world3", 12, 4), this._scene.needsPreviousWorldMatrices && (f = new Ai(r, l.instancesPreviousData, !0, 16, !1, !0), l.instancesPreviousBuffer = f, this._userInstancedBuffersStorage.vertexBuffers.previousWorld0 = f.createVertexBuffer("previousWorld0", 0, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld1 = f.createVertexBuffer("previousWorld1", 4, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld2 = f.createVertexBuffer("previousWorld2", 8, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld3 = f.createVertexBuffer("previousWorld3", 12, 4)), this._invalidateInstanceVertexArrayObject()) : (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) && (u.updateDirectly(l.instancesData, 0, E), this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate) && f.updateDirectly(l.instancesPreviousData, 0, E)), this._processInstancedBuffers(a, m), this.getScene()._activeIndices.addCount(e.indexCount * E, !1), r._currentDrawContext && (r._currentDrawContext.useInstancing = !0), this._bind(e, s, t), this._draw(e, t, E), this._scene.needsPreviousWorldMatrices && !x && this._instanceDataStorage.manualUpdate && (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) && !this._instanceDataStorage.previousManualUpdate && f.updateDirectly(l.instancesData, 0, E), r.unbindInstanceAttributes(), this } _renderWithThinInstances(e, t, i, s) { var r, n; const a = (n = (r = this._thinInstanceDataStorage) === null || r === void 0 ? void 0 : r.instancesCount) !== null && n !== void 0 ? n : 0; this.getScene()._activeIndices.addCount(e.indexCount * a, !1), s._currentDrawContext && (s._currentDrawContext.useInstancing = !0), this._bind(e, i, t), this._draw(e, t, a), this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData && (this._thinInstanceDataStorage.previousMatrixBuffer ? this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, a) : this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, !1)), s.unbindInstanceAttributes() } _processInstancedBuffers(e, t) { } _processRendering(e, t, i, s, r, n, a, o) { const l = this.getScene(), h = l.getEngine(); if (s = this._getRenderingFillMode(s), n && t.getRenderingMesh().hasThinInstances) return this._renderWithThinInstances(t, s, i, h), this; if (n) this._renderWithInstances(t, s, r, i, h); else { h._currentDrawContext && (h._currentDrawContext.useInstancing = !1); let u = 0; r.renderSelf[t._id] && (a && a(!1, e.getWorldMatrix(), o), u++, this._draw(t, s, this._instanceDataStorage.overridenInstanceCount)); const f = r.visibleInstances[t._id]; if (f) { const _ = f.length; u += _; for (let p = 0; p < _; p++) { const E = f[p].getWorldMatrix(); a && a(!0, E, o), this._draw(t, s) } } l._activeIndices.addCount(t.indexCount * u, !1) } return this } _rebuild(e = !1) { if (this._instanceDataStorage.instancesBuffer && (e && this._instanceDataStorage.instancesBuffer.dispose(), this._instanceDataStorage.instancesBuffer = null), this._userInstancedBuffersStorage) { for (const t in this._userInstancedBuffersStorage.vertexBuffers) { const i = this._userInstancedBuffersStorage.vertexBuffers[t]; i && (e && i.dispose(), this._userInstancedBuffersStorage.vertexBuffers[t] = null) } this._userInstancedBuffersStorage.vertexArrayObjects && (this._userInstancedBuffersStorage.vertexArrayObjects = {}) } this._internalMeshDataInfo._effectiveMaterial = null, super._rebuild(e) } _freeze() { if (this.subMeshes) { for (let e = 0; e < this.subMeshes.length; e++)this._getInstancesRenderList(e); this._internalMeshDataInfo._effectiveMaterial = null, this._instanceDataStorage.isFrozen = !0 } } _unFreeze() { this._instanceDataStorage.isFrozen = !1, this._instanceDataStorage.previousBatch = null } renderWithRenderPassId(e, t, i, s, r = !0) { const n = this._scene.getEngine(), a = n.currentRenderPassId; if (e !== void 0 && (n.currentRenderPassId = e), s) (!r || r && s.isInFrustum(this._scene._frustumPlanes)) && this.render(s, !!t, i); else for (let o = 0; o < this.subMeshes.length; o++) { const l = this.subMeshes[o]; (!r || r && l.isInFrustum(this._scene._frustumPlanes)) && this.render(l, !!t, i) } return e !== void 0 && (n.currentRenderPassId = a), this } render(e, t, i) { var s, r, n, a, o; const l = this.getScene(); this._internalAbstractMeshDataInfo._isActiveIntermediate ? this._internalAbstractMeshDataInfo._isActiveIntermediate = !1 : this._internalAbstractMeshDataInfo._isActive = !1; const h = (r = (s = l.activeCameras) === null || s === void 0 ? void 0 : s.length) !== null && r !== void 0 ? r : 0; if ((h > 1 && l.activeCamera === l.activeCameras[0] || h <= 1) && this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) return this; const f = this._getInstancesRenderList(e._id, !!i); if (f.mustReturn) return this; if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) return this; const _ = l.getEngine(); let p = 0, v = null; this.ignoreCameraMaxZ && l.activeCamera && !l._isInIntermediateRendering() && (p = l.activeCamera.maxZ, v = l.activeCamera, l.activeCamera.maxZ = 0, l.updateTransformMatrix(!0)), this._internalMeshDataInfo._onBeforeRenderObservable && this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this); const E = e.getRenderingMesh(), m = f.hardwareInstancedRendering[e._id] || E.hasThinInstances || !!this._userInstancedBuffersStorage && !e.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh, x = this._instanceDataStorage, C = e.getMaterial(); if (!C) return v && (v.maxZ = p, l.updateTransformMatrix(!0)), this; if (!x.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== C) { if (C._storeEffectOnSubMeshes) { if (!C.isReadyForSubMesh(this, e, m)) return v && (v.maxZ = p, l.updateTransformMatrix(!0)), this } else if (!C.isReady(this, m)) return v && (v.maxZ = p, l.updateTransformMatrix(!0)), this; this._internalMeshDataInfo._effectiveMaterial = C } else if (C._storeEffectOnSubMeshes && !(!((n = e.effect) === null || n === void 0) && n._wasPreviouslyReady) || !C._storeEffectOnSubMeshes && !(!((a = C.getEffect()) === null || a === void 0) && a._wasPreviouslyReady)) return v && (v.maxZ = p, l.updateTransformMatrix(!0)), this; t && _.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode); let S; this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes ? S = e._drawWrapper : S = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper(); const y = (o = S == null ? void 0 : S.effect) !== null && o !== void 0 ? o : null; for (const J of l._beforeRenderingMeshStage) J.action(this, e, f, y); if (!S || !y) return v && (v.maxZ = p, l.updateTransformMatrix(!0)), this; const b = i || this; let R; if (!x.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null || this._internalMeshDataInfo._effectiveMaterial.twoSidedLighting)) { const J = b._getWorldMatrixDeterminant(); R = this.overrideMaterialSideOrientation, R == null && (R = this._internalMeshDataInfo._effectiveMaterial.sideOrientation), J < 0 && (R = R === I.ClockWiseSideOrientation ? I.CounterClockWiseSideOrientation : I.ClockWiseSideOrientation), x.sideOrientation = R } else R = x.sideOrientation; const w = this._internalMeshDataInfo._effectiveMaterial._preBind(S, R); this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite && _.setDepthWrite(!0); const N = this._internalMeshDataInfo._effectiveMaterial, X = N.fillMode; this._internalMeshDataInfo._onBeforeBindObservable && this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this), m || this._bind(e, y, X, !1); const fe = b.getWorldMatrix(); N._storeEffectOnSubMeshes ? N.bindForSubMesh(fe, this, e) : N.bind(fe, this), !N.backFaceCulling && N.separateCullingPass && (_.setState(!0, N.zOffset, !1, !w, N.cullBackFaces, N.stencil, N.zOffsetUnits), this._processRendering(this, e, y, X, f, m, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial), _.setState(!0, N.zOffset, !1, w, N.cullBackFaces, N.stencil, N.zOffsetUnits), this._internalMeshDataInfo._onBetweenPassObservable && this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(e)), this._processRendering(this, e, y, X, f, m, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial), this._internalMeshDataInfo._effectiveMaterial.unbind(); for (const J of l._afterRenderingMeshStage) J.action(this, e, f, y); return this._internalMeshDataInfo._onAfterRenderObservable && this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this), v && (v.maxZ = p, l.updateTransformMatrix(!0)), l.performancePriority === ut.Aggressive && !x.isFrozen && this._freeze(), this } cleanMatrixWeights() { this.isVerticesDataPresent(d.MatricesWeightsKind) && (this.isVerticesDataPresent(d.MatricesWeightsExtraKind) ? this._normalizeSkinWeightsAndExtra() : this._normalizeSkinFourWeights()) } _normalizeSkinFourWeights() { const e = this.getVerticesData(d.MatricesWeightsKind), t = e.length; for (let i = 0; i < t; i += 4) { const s = e[i] + e[i + 1] + e[i + 2] + e[i + 3]; if (s === 0) e[i] = 1; else { const r = 1 / s; e[i] *= r, e[i + 1] *= r, e[i + 2] *= r, e[i + 3] *= r } } this.setVerticesData(d.MatricesWeightsKind, e) } _normalizeSkinWeightsAndExtra() { const e = this.getVerticesData(d.MatricesWeightsExtraKind), t = this.getVerticesData(d.MatricesWeightsKind), i = t.length; for (let s = 0; s < i; s += 4) { let r = t[s] + t[s + 1] + t[s + 2] + t[s + 3]; if (r += e[s] + e[s + 1] + e[s + 2] + e[s + 3], r === 0) t[s] = 1; else { const n = 1 / r; t[s] *= n, t[s + 1] *= n, t[s + 2] *= n, t[s + 3] *= n, e[s] *= n, e[s + 1] *= n, e[s + 2] *= n, e[s + 3] *= n } } this.setVerticesData(d.MatricesWeightsKind, t), this.setVerticesData(d.MatricesWeightsKind, e) } validateSkinning() {
            const e = this.getVerticesData(d.MatricesWeightsExtraKind), t = this.getVerticesData(d.MatricesWeightsKind); if (t === null || this.skeleton == null) return { skinned: !1, valid: !0, report: "not skinned" }; const i = t.length; let s = 0, r = 0, n = 0, a = 0; const o = e === null ? 4 : 8, l = []; for (let E = 0; E <= o; E++)l[E] = 0; const h = .001; for (let E = 0; E < i; E += 4) { let m = t[E], x = m, C = x === 0 ? 0 : 1; for (let S = 1; S < o; S++) { const y = S < 4 ? t[E + S] : e[E + S - 4]; y > m && s++, y !== 0 && C++, x += y, m = y } if (l[C]++, C > n && (n = C), x === 0) r++; else { const S = 1 / x; let y = 0; for (let b = 0; b < o; b++)b < 4 ? y += Math.abs(t[E + b] - t[E + b] * S) : y += Math.abs(e[E + b - 4] - e[E + b - 4] * S); y > h && a++ } } const u = this.skeleton.bones.length, f = this.getVerticesData(d.MatricesIndicesKind), _ = this.getVerticesData(d.MatricesIndicesExtraKind); let p = 0; for (let E = 0; E < i; E += 4)for (let m = 0; m < o; m++) { const x = m < 4 ? f[E + m] : _[E + m - 4]; (x >= u || x < 0) && p++ } const v = "Number of Weights = " + i / 4 + `
Maximum influences = `+ n + `
Missing Weights = `+ r + `
Not Sorted = `+ s + `
Not Normalized = `+ a + `
WeightCounts = [`+ l + `]
Number of bones = `+ u + `
Bad Bone Indices = `+ p; return { skinned: !0, valid: r === 0 && a === 0 && p === 0, report: v }
        } _checkDelayState() { const e = this.getScene(); return this._geometry ? this._geometry.load(e) : this.delayLoadState === 4 && (this.delayLoadState = 2, this._queueLoad(e)), this } _queueLoad(e) { e.addPendingData(this); const t = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1; return G.LoadFile(this.delayLoadingFile, i => { i instanceof ArrayBuffer ? this._delayLoadingFunction(i, this) : this._delayLoadingFunction(JSON.parse(i), this), this.instances.forEach(s => { s.refreshBoundingInfo(), s._syncSubMeshes() }), this.delayLoadState = 1, e.removePendingData(this) }, () => { }, e.offlineProvider, t), this } isInFrustum(e) { return this.delayLoadState === 2 || !super.isInFrustum(e) ? !1 : (this._checkDelayState(), !0) } setMaterialById(e) { const t = this.getScene().materials; let i; for (i = t.length - 1; i > -1; i--)if (t[i].id === e) return this.material = t[i], this; const s = this.getScene().multiMaterials; for (i = s.length - 1; i > -1; i--)if (s[i].id === e) return this.material = s[i], this; return this } getAnimatables() { const e = []; return this.material && e.push(this.material), this.skeleton && e.push(this.skeleton), e } bakeTransformIntoVertices(e) { if (!this.isVerticesDataPresent(d.PositionKind)) return this; const t = this.subMeshes.splice(0); this._resetPointsArrayCache(); let i = this.getVerticesData(d.PositionKind); const s = g.Zero(); let r; for (r = 0; r < i.length; r += 3)g.TransformCoordinatesFromFloatsToRef(i[r], i[r + 1], i[r + 2], e, s).toArray(i, r); if (this.setVerticesData(d.PositionKind, i, this.getVertexBuffer(d.PositionKind).isUpdatable()), this.isVerticesDataPresent(d.NormalKind)) { for (i = this.getVerticesData(d.NormalKind), r = 0; r < i.length; r += 3)g.TransformNormalFromFloatsToRef(i[r], i[r + 1], i[r + 2], e, s).normalize().toArray(i, r); this.setVerticesData(d.NormalKind, i, this.getVertexBuffer(d.NormalKind).isUpdatable()) } return e.determinant() < 0 && this.flipFaces(), this.releaseSubMeshes(), this.subMeshes = t, this } bakeCurrentTransformIntoVertices(e = !0) { return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)), this.resetLocalMatrix(e), this } get _positions() { return this._internalAbstractMeshDataInfo._positions ? this._internalAbstractMeshDataInfo._positions : this._geometry ? this._geometry._positions : null } _resetPointsArrayCache() { return this._geometry && this._geometry._resetPointsArrayCache(), this } _generatePointsArray() { return this._geometry ? this._geometry._generatePointsArray() : !1 } clone(e = "", t = null, i, s = !0) { return new ie(e, this.getScene(), t, this, i, s) } dispose(e, t = !1) { this.morphTargetManager = null, this._geometry && this._geometry.releaseForMesh(this, !0); const i = this._internalMeshDataInfo; if (i._onBeforeDrawObservable && i._onBeforeDrawObservable.clear(), i._onBeforeBindObservable && i._onBeforeBindObservable.clear(), i._onBeforeRenderObservable && i._onBeforeRenderObservable.clear(), i._onAfterRenderObservable && i._onAfterRenderObservable.clear(), i._onBetweenPassObservable && i._onBetweenPassObservable.clear(), this._scene.useClonedMeshMap) { if (i.meshMap) for (const s in i.meshMap) { const r = i.meshMap[s]; r && (r._internalMeshDataInfo._source = null, i.meshMap[s] = void 0) } i._source && i._source._internalMeshDataInfo.meshMap && (i._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0) } else { const s = this.getScene().meshes; for (const r of s) { const n = r; n._internalMeshDataInfo && n._internalMeshDataInfo._source && n._internalMeshDataInfo._source === this && (n._internalMeshDataInfo._source = null) } } i._source = null, this._instanceDataStorage.visibleInstances = {}, this._disposeInstanceSpecificData(), this._disposeThinInstanceSpecificData(), this._internalMeshDataInfo._checkReadinessObserver && this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver), super.dispose(e, t) } _disposeInstanceSpecificData() { } _disposeThinInstanceSpecificData() { } _invalidateInstanceVertexArrayObject() { } applyDisplacementMap(e, t, i, s, r, n, a = !1) { const o = this.getScene(), l = h => { const u = h.width, f = h.height, p = this.getEngine().createCanvas(u, f).getContext("2d"); p.drawImage(h, 0, 0); const v = p.getImageData(0, 0, u, f).data; this.applyDisplacementMapFromBuffer(v, u, f, t, i, r, n, a), s && s(this) }; return G.LoadImage(e, l, () => { }, o.offlineProvider), this } applyDisplacementMapFromBuffer(e, t, i, s, r, n, a, o = !1) { if (!this.isVerticesDataPresent(d.PositionKind) || !this.isVerticesDataPresent(d.NormalKind) || !this.isVerticesDataPresent(d.UVKind)) return O.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"), this; const l = this.getVerticesData(d.PositionKind, !0, !0), h = this.getVerticesData(d.NormalKind), u = this.getVerticesData(d.UVKind); let f = g.Zero(); const _ = g.Zero(), p = ge.Zero(); n = n || ge.Zero(), a = a || new ge(1, 1); for (let v = 0; v < l.length; v += 3) { g.FromArrayToRef(l, v, f), g.FromArrayToRef(h, v, _), ge.FromArrayToRef(u, v / 3 * 2, p); const E = Math.abs(p.x * a.x + n.x % 1) * (t - 1) % t | 0, m = Math.abs(p.y * a.y + n.y % 1) * (i - 1) % i | 0, x = (E + m * t) * 4, C = e[x] / 255, S = e[x + 1] / 255, y = e[x + 2] / 255, b = C * .3 + S * .59 + y * .11; _.normalize(), _.scaleInPlace(s + (r - s) * b), f = f.add(_), f.toArray(l, v) } return Y.ComputeNormals(l, this.getIndices(), h), o ? (this.setVerticesData(d.PositionKind, l), this.setVerticesData(d.NormalKind, h), this.setVerticesData(d.UVKind, u)) : (this.updateVerticesData(d.PositionKind, l), this.updateVerticesData(d.NormalKind, h)), this } _getFlattenedNormals(e, t) { const i = new Float32Array(e.length * 3); let s = 0; const r = this.overrideMaterialSideOrientation === (this._scene.useRightHandedSystem ? 1 : 0); for (let n = 0; n < e.length; n += 3) { const a = g.FromArray(t, e[n] * 3), o = g.FromArray(t, e[n + 1] * 3), l = g.FromArray(t, e[n + 2] * 3), h = a.subtract(o), u = l.subtract(o), f = g.Normalize(g.Cross(h, u)); r && f.scaleInPlace(-1); for (let _ = 0; _ < 3; _++)i[s++] = f.x, i[s++] = f.y, i[s++] = f.z } return i } _convertToUnIndexedMesh(e = !1) { const t = this.getVerticesDataKinds(), i = this.getIndices(), s = {}, r = (a, o) => { const l = new Float32Array(i.length * o); let h = 0; for (let u = 0; u < i.length; u++)for (let f = 0; f < o; f++)l[h++] = a[i[u] * o + f]; return l }, n = this.geometry ? this.subMeshes.slice(0) : []; for (const a of t) s[a] = this.getVerticesData(a); for (const a of t) { const o = this.getVertexBuffer(a), l = o.getStrideSize(); if (e && a === d.NormalKind) { const h = this._getFlattenedNormals(i, s[d.PositionKind]); this.setVerticesData(d.NormalKind, h, o.isUpdatable(), l) } else this.setVerticesData(a, r(s[a], l), o.isUpdatable(), l) } if (this.morphTargetManager) { for (let a = 0; a < this.morphTargetManager.numTargets; a++) { const o = this.morphTargetManager.getTarget(a), l = o.getPositions(); o.setPositions(r(l, 3)); const h = o.getNormals(); h && o.setNormals(e ? this._getFlattenedNormals(i, l) : r(h, 3)); const u = o.getTangents(); u && o.setTangents(r(u, 3)); const f = o.getUVs(); f && o.setUVs(r(f, 2)) } this.morphTargetManager.synchronize() } for (let a = 0; a < i.length; a++)i[a] = a; this.setIndices(i), this._unIndexed = !0, this.releaseSubMeshes(); for (const a of n) nt.AddToMesh(a.materialIndex, a.indexStart, a.indexCount, a.indexStart, a.indexCount, this); return this.synchronizeInstances(), this } convertToFlatShadedMesh() { return this._convertToUnIndexedMesh(!0) } convertToUnIndexedMesh() { return this._convertToUnIndexedMesh() } flipFaces(e = !1) { const t = Y.ExtractFromMesh(this); let i; if (e && this.isVerticesDataPresent(d.NormalKind) && t.normals) for (i = 0; i < t.normals.length; i++)t.normals[i] *= -1; if (t.indices) { let s; for (i = 0; i < t.indices.length; i += 3)s = t.indices[i + 1], t.indices[i + 1] = t.indices[i + 2], t.indices[i + 2] = s } return t.applyToMesh(this, this.isVertexBufferUpdatable(d.PositionKind)), this } increaseVertices(e = 1) { const t = Y.ExtractFromMesh(this), i = t.indices && !Array.isArray(t.indices) && Array.from ? Array.from(t.indices) : t.indices, s = t.positions && !Array.isArray(t.positions) && Array.from ? Array.from(t.positions) : t.positions, r = t.uvs && !Array.isArray(t.uvs) && Array.from ? Array.from(t.uvs) : t.uvs, n = t.normals && !Array.isArray(t.normals) && Array.from ? Array.from(t.normals) : t.normals; if (!i || !s) O.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions"); else { t.indices = i, t.positions = s, r && (t.uvs = r), n && (t.normals = n); const a = e + 1, o = new Array; for (let y = 0; y < a + 1; y++)o[y] = new Array; let l, h; const u = new g(0, 0, 0), f = new g(0, 0, 0), _ = new ge(0, 0), p = new Array, v = new Array, E = new Array; let m, x = s.length, C; r && (C = r.length); let S; n && (S = n.length); for (let y = 0; y < i.length; y += 3) { v[0] = i[y], v[1] = i[y + 1], v[2] = i[y + 2]; for (let b = 0; b < 3; b++)if (l = v[b], h = v[(b + 1) % 3], E[l] === void 0 && E[h] === void 0 ? (E[l] = new Array, E[h] = new Array) : (E[l] === void 0 && (E[l] = new Array), E[h] === void 0 && (E[h] = new Array)), E[l][h] === void 0 && E[h][l] === void 0) { E[l][h] = [], u.x = (s[3 * h] - s[3 * l]) / a, u.y = (s[3 * h + 1] - s[3 * l + 1]) / a, u.z = (s[3 * h + 2] - s[3 * l + 2]) / a, n && (f.x = (n[3 * h] - n[3 * l]) / a, f.y = (n[3 * h + 1] - n[3 * l + 1]) / a, f.z = (n[3 * h + 2] - n[3 * l + 2]) / a), r && (_.x = (r[2 * h] - r[2 * l]) / a, _.y = (r[2 * h + 1] - r[2 * l + 1]) / a), E[l][h].push(l); for (let R = 1; R < a; R++)E[l][h].push(s.length / 3), s[x++] = s[3 * l] + R * u.x, s[x++] = s[3 * l + 1] + R * u.y, s[x++] = s[3 * l + 2] + R * u.z, n && (n[S++] = n[3 * l] + R * f.x, n[S++] = n[3 * l + 1] + R * f.y, n[S++] = n[3 * l + 2] + R * f.z), r && (r[C++] = r[2 * l] + R * _.x, r[C++] = r[2 * l + 1] + R * _.y); E[l][h].push(h), E[h][l] = new Array, m = E[l][h].length; for (let R = 0; R < m; R++)E[h][l][R] = E[l][h][m - 1 - R] } o[0][0] = i[y], o[1][0] = E[i[y]][i[y + 1]][1], o[1][1] = E[i[y]][i[y + 2]][1]; for (let b = 2; b < a; b++) { o[b][0] = E[i[y]][i[y + 1]][b], o[b][b] = E[i[y]][i[y + 2]][b], u.x = (s[3 * o[b][b]] - s[3 * o[b][0]]) / b, u.y = (s[3 * o[b][b] + 1] - s[3 * o[b][0] + 1]) / b, u.z = (s[3 * o[b][b] + 2] - s[3 * o[b][0] + 2]) / b, n && (f.x = (n[3 * o[b][b]] - n[3 * o[b][0]]) / b, f.y = (n[3 * o[b][b] + 1] - n[3 * o[b][0] + 1]) / b, f.z = (n[3 * o[b][b] + 2] - n[3 * o[b][0] + 2]) / b), r && (_.x = (r[2 * o[b][b]] - r[2 * o[b][0]]) / b, _.y = (r[2 * o[b][b] + 1] - r[2 * o[b][0] + 1]) / b); for (let R = 1; R < b; R++)o[b][R] = s.length / 3, s[x++] = s[3 * o[b][0]] + R * u.x, s[x++] = s[3 * o[b][0] + 1] + R * u.y, s[x++] = s[3 * o[b][0] + 2] + R * u.z, n && (n[S++] = n[3 * o[b][0]] + R * f.x, n[S++] = n[3 * o[b][0] + 1] + R * f.y, n[S++] = n[3 * o[b][0] + 2] + R * f.z), r && (r[C++] = r[2 * o[b][0]] + R * _.x, r[C++] = r[2 * o[b][0] + 1] + R * _.y) } o[a] = E[i[y + 1]][i[y + 2]], p.push(o[0][0], o[1][0], o[1][1]); for (let b = 1; b < a; b++) { let R; for (R = 0; R < b; R++)p.push(o[b][R], o[b + 1][R], o[b + 1][R + 1]), p.push(o[b][R], o[b + 1][R + 1], o[b][R + 1]); p.push(o[b][R], o[b + 1][R], o[b + 1][R + 1]) } } t.indices = p, t.applyToMesh(this, this.isVertexBufferUpdatable(d.PositionKind)) } } forceSharedVertices() { const e = Y.ExtractFromMesh(this), t = e.uvs, i = e.indices, s = e.positions, r = e.colors, n = e.matricesIndices, a = e.matricesWeights, o = e.matricesIndicesExtra, l = e.matricesWeightsExtra; if (i === void 0 || s === void 0 || i === null || s === null) O.Warn("VertexData contains empty entries"); else { const h = new Array, u = new Array, f = new Array, _ = new Array, p = new Array, v = new Array, E = new Array, m = new Array; let x = new Array, C = 0; const S = {}; let y, b; for (let w = 0; w < i.length; w += 3) { b = [i[w], i[w + 1], i[w + 2]], x = []; for (let N = 0; N < 3; N++) { x[N] = ""; for (let X = 0; X < 3; X++)Math.abs(s[3 * b[N] + X]) < 1e-8 && (s[3 * b[N] + X] = 0), x[N] += s[3 * b[N] + X] + "|" } if (!(x[0] == x[1] || x[0] == x[2] || x[1] == x[2])) for (let N = 0; N < 3; N++) { if (y = S[x[N]], y === void 0) { S[x[N]] = C, y = C++; for (let X = 0; X < 3; X++)h.push(s[3 * b[N] + X]); if (r != null) for (let X = 0; X < 4; X++)_.push(r[4 * b[N] + X]); if (t != null) for (let X = 0; X < 2; X++)f.push(t[2 * b[N] + X]); if (n != null) for (let X = 0; X < 4; X++)p.push(n[4 * b[N] + X]); if (a != null) for (let X = 0; X < 4; X++)v.push(a[4 * b[N] + X]); if (o != null) for (let X = 0; X < 4; X++)E.push(o[4 * b[N] + X]); if (l != null) for (let X = 0; X < 4; X++)m.push(l[4 * b[N] + X]) } u.push(y) } } const R = new Array; Y.ComputeNormals(h, u, R), e.positions = h, e.indices = u, e.normals = R, t != null && (e.uvs = f), r != null && (e.colors = _), n != null && (e.matricesIndices = p), a != null && (e.matricesWeights = v), o != null && (e.matricesIndicesExtra = E), a != null && (e.matricesWeightsExtra = m), e.applyToMesh(this, this.isVertexBufferUpdatable(d.PositionKind)) } } static _instancedMeshFactory(e, t) { throw K("InstancedMesh") } static _PhysicsImpostorParser(e, t, i) { throw K("PhysicsImpostor") } createInstance(e) { return ie._instancedMeshFactory(e, this) } synchronizeInstances() { for (let e = 0; e < this.instances.length; e++)this.instances[e]._syncSubMeshes(); return this } optimizeIndices(e) { const t = this.getIndices(), i = this.getVerticesData(d.PositionKind); if (!i || !t) return this; const s = []; for (let n = 0; n < i.length; n = n + 3)s.push(g.FromArray(i, n)); const r = []; return Ti.SyncAsyncForLoop(s.length, 40, n => { const a = s.length - 1 - n, o = s[a]; for (let l = 0; l < a; ++l) { const h = s[l]; if (o.equals(h)) { r[a] = l; break } } }, () => { for (let a = 0; a < t.length; ++a)t[a] = r[t[a]] || t[a]; const n = this.subMeshes.slice(0); this.setIndices(t), this.subMeshes = n, e && e(this) }), this } serialize(e = {}) { e.name = this.name, e.id = this.id, e.uniqueId = this.uniqueId, e.type = this.getClassName(), ne && ne.HasTags(this) && (e.tags = ne.GetTags(this)), e.position = this.position.asArray(), this.rotationQuaternion ? e.rotationQuaternion = this.rotationQuaternion.asArray() : this.rotation && (e.rotation = this.rotation.asArray()), e.scaling = this.scaling.asArray(), this._postMultiplyPivotMatrix ? e.pivotMatrix = this.getPivotMatrix().asArray() : e.localMatrix = this.getPivotMatrix().asArray(), e.isEnabled = this.isEnabled(!1), e.isVisible = this.isVisible, e.infiniteDistance = this.infiniteDistance, e.pickable = this.isPickable, e.receiveShadows = this.receiveShadows, e.billboardMode = this.billboardMode, e.visibility = this.visibility, e.checkCollisions = this.checkCollisions, e.isBlocker = this.isBlocker, e.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation, this.parent && this.parent._serializeAsParent(e), e.isUnIndexed = this.isUnIndexed; const t = this._geometry; if (t && this.subMeshes) { e.geometryUniqueId = t.uniqueId, e.geometryId = t.id, e.subMeshes = []; for (let i = 0; i < this.subMeshes.length; i++) { const s = this.subMeshes[i]; e.subMeshes.push({ materialIndex: s.materialIndex, verticesStart: s.verticesStart, verticesCount: s.verticesCount, indexStart: s.indexStart, indexCount: s.indexCount }) } } if (this.material ? this.material.doNotSerialize || (e.materialUniqueId = this.material.uniqueId, e.materialId = this.material.id) : (this.material = null, e.materialUniqueId = this._scene.defaultMaterial.uniqueId, e.materialId = this._scene.defaultMaterial.id), this.morphTargetManager && (e.morphTargetManagerId = this.morphTargetManager.uniqueId), this.skeleton && (e.skeletonId = this.skeleton.id, e.numBoneInfluencers = this.numBoneInfluencers), this.getScene()._getComponent(j.NAME_PHYSICSENGINE)) { const i = this.getPhysicsImpostor(); i && (e.physicsMass = i.getParam("mass"), e.physicsFriction = i.getParam("friction"), e.physicsRestitution = i.getParam("mass"), e.physicsImpostor = i.type) } this.metadata && (e.metadata = this.metadata), e.instances = []; for (let i = 0; i < this.instances.length; i++) { const s = this.instances[i]; if (s.doNotSerialize) continue; const r = { name: s.name, id: s.id, isEnabled: s.isEnabled(!1), isVisible: s.isVisible, isPickable: s.isPickable, checkCollisions: s.checkCollisions, position: s.position.asArray(), scaling: s.scaling.asArray() }; if (s.parent && s.parent._serializeAsParent(r), s.rotationQuaternion ? r.rotationQuaternion = s.rotationQuaternion.asArray() : s.rotation && (r.rotation = s.rotation.asArray()), this.getScene()._getComponent(j.NAME_PHYSICSENGINE)) { const n = s.getPhysicsImpostor(); n && (r.physicsMass = n.getParam("mass"), r.physicsFriction = n.getParam("friction"), r.physicsRestitution = n.getParam("mass"), r.physicsImpostor = n.type) } s.metadata && (r.metadata = s.metadata), s.actionManager && (r.actions = s.actionManager.serialize(s.name)), e.instances.push(r), re.AppendSerializedAnimations(s, r), r.ranges = s.serializeAnimationRanges() } if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData && (e.thinInstances = { instancesCount: this._thinInstanceDataStorage.instancesCount, matrixData: Array.from(this._thinInstanceDataStorage.matrixData), matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize, enablePicking: this.thinInstanceEnablePicking }, this._userThinInstanceBuffersStorage)) { const i = { data: {}, sizes: {}, strides: {} }; for (const s in this._userThinInstanceBuffersStorage.data) i.data[s] = Array.from(this._userThinInstanceBuffersStorage.data[s]), i.sizes[s] = this._userThinInstanceBuffersStorage.sizes[s], i.strides[s] = this._userThinInstanceBuffersStorage.strides[s]; e.thinInstances.userThinInstance = i } return re.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.layerMask = this.layerMask, e.alphaIndex = this.alphaIndex, e.hasVertexAlpha = this.hasVertexAlpha, e.overlayAlpha = this.overlayAlpha, e.overlayColor = this.overlayColor.asArray(), e.renderOverlay = this.renderOverlay, e.applyFog = this.applyFog, this.actionManager && (e.actions = this.actionManager.serialize(this.name)), e } _syncGeometryWithMorphTargetManager() { if (!this.geometry) return; this._markSubMeshesAsAttributesDirty(); const e = this._internalAbstractMeshDataInfo._morphTargetManager; if (e && e.vertexCount) { if (e.vertexCount !== this.getTotalVertices()) { O.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."), this.morphTargetManager = null; return } if (e.isUsingTextureForTargets) return; for (let t = 0; t < e.numInfluencers; t++) { const i = e.getActiveTarget(t), s = i.getPositions(); if (!s) { O.Error("Invalid morph target. Target must have positions."); return } this.geometry.setVerticesData(d.PositionKind + t, s, !1, 3); const r = i.getNormals(); r && this.geometry.setVerticesData(d.NormalKind + t, r, !1, 3); const n = i.getTangents(); n && this.geometry.setVerticesData(d.TangentKind + t, n, !1, 3); const a = i.getUVs(); a && this.geometry.setVerticesData(d.UVKind + "_" + t, a, !1, 2) } } else { let t = 0; for (; this.geometry.isVerticesDataPresent(d.PositionKind + t);)this.geometry.removeVerticesData(d.PositionKind + t), this.geometry.isVerticesDataPresent(d.NormalKind + t) && this.geometry.removeVerticesData(d.NormalKind + t), this.geometry.isVerticesDataPresent(d.TangentKind + t) && this.geometry.removeVerticesData(d.TangentKind + t), this.geometry.isVerticesDataPresent(d.UVKind + t) && this.geometry.removeVerticesData(d.UVKind + "_" + t), t++ } } static Parse(e, t, i) { let s; if (e.type && e.type === "LinesMesh" ? s = ie._LinesMeshParser(e, t) : e.type && e.type === "GroundMesh" ? s = ie._GroundMeshParser(e, t) : e.type && e.type === "GoldbergMesh" ? s = ie._GoldbergMeshParser(e, t) : e.type && e.type === "GreasedLineMesh" ? s = ie._GreasedLineMeshParser(e, t) : e.type && e.type === "TrailMesh" ? s = ie._TrailMeshParser(e, t) : s = new ie(e.name, t), s.id = e.id, s._waitingParsedUniqueId = e.uniqueId, ne && ne.AddTagsTo(s, e.tags), s.position = g.FromArray(e.position), e.metadata !== void 0 && (s.metadata = e.metadata), e.rotationQuaternion ? s.rotationQuaternion = q.FromArray(e.rotationQuaternion) : e.rotation && (s.rotation = g.FromArray(e.rotation)), s.scaling = g.FromArray(e.scaling), e.localMatrix ? s.setPreTransformMatrix(A.FromArray(e.localMatrix)) : e.pivotMatrix && s.setPivotMatrix(A.FromArray(e.pivotMatrix)), s.setEnabled(e.isEnabled), s.isVisible = e.isVisible, s.infiniteDistance = e.infiniteDistance, s.showBoundingBox = e.showBoundingBox, s.showSubMeshesBoundingBox = e.showSubMeshesBoundingBox, e.applyFog !== void 0 && (s.applyFog = e.applyFog), e.pickable !== void 0 && (s.isPickable = e.pickable), e.alphaIndex !== void 0 && (s.alphaIndex = e.alphaIndex), s.receiveShadows = e.receiveShadows, e.billboardMode !== void 0 && (s.billboardMode = e.billboardMode), e.visibility !== void 0 && (s.visibility = e.visibility), s.checkCollisions = e.checkCollisions, e.overrideMaterialSideOrientation !== void 0 && (s.overrideMaterialSideOrientation = e.overrideMaterialSideOrientation), e.isBlocker !== void 0 && (s.isBlocker = e.isBlocker), s._shouldGenerateFlatShading = e.useFlatShading, e.freezeWorldMatrix && (s._waitingData.freezeWorldMatrix = e.freezeWorldMatrix), e.parentId !== void 0 && (s._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (s._waitingParentInstanceIndex = e.parentInstanceIndex), e.actions !== void 0 && (s._waitingData.actions = e.actions), e.overlayAlpha !== void 0 && (s.overlayAlpha = e.overlayAlpha), e.overlayColor !== void 0 && (s.overlayColor = te.FromArray(e.overlayColor)), e.renderOverlay !== void 0 && (s.renderOverlay = e.renderOverlay), s.isUnIndexed = !!e.isUnIndexed, s.hasVertexAlpha = e.hasVertexAlpha, e.delayLoadingFile ? (s.delayLoadState = 4, s.delayLoadingFile = i + e.delayLoadingFile, s.buildBoundingInfo(g.FromArray(e.boundingBoxMinimum), g.FromArray(e.boundingBoxMaximum)), e._binaryInfo && (s._binaryInfo = e._binaryInfo), s._delayInfo = [], e.hasUVs && s._delayInfo.push(d.UVKind), e.hasUVs2 && s._delayInfo.push(d.UV2Kind), e.hasUVs3 && s._delayInfo.push(d.UV3Kind), e.hasUVs4 && s._delayInfo.push(d.UV4Kind), e.hasUVs5 && s._delayInfo.push(d.UV5Kind), e.hasUVs6 && s._delayInfo.push(d.UV6Kind), e.hasColors && s._delayInfo.push(d.ColorKind), e.hasMatricesIndices && s._delayInfo.push(d.MatricesIndicesKind), e.hasMatricesWeights && s._delayInfo.push(d.MatricesWeightsKind), s._delayLoadingFunction = Ge._ImportGeometry, Ye.ForceFullSceneLoadingForIncremental && s._checkDelayState()) : Ge._ImportGeometry(e, s), e.materialUniqueId ? s._waitingMaterialId = e.materialUniqueId : e.materialId && (s._waitingMaterialId = e.materialId), e.morphTargetManagerId > -1 && (s.morphTargetManager = t.getMorphTargetManagerById(e.morphTargetManagerId)), e.skeletonId !== void 0 && e.skeletonId !== null && (s.skeleton = t.getLastSkeletonById(e.skeletonId), e.numBoneInfluencers && (s.numBoneInfluencers = e.numBoneInfluencers)), e.animations) { for (let r = 0; r < e.animations.length; r++) { const n = e.animations[r], a = Yt("BABYLON.Animation"); a && s.animations.push(a.Parse(n)) } We.ParseAnimationRanges(s, e, t) } if (e.autoAnimate && t.beginAnimation(s, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), e.layerMask && !isNaN(e.layerMask) ? s.layerMask = Math.abs(parseInt(e.layerMask)) : s.layerMask = 268435455, e.physicsImpostor && ie._PhysicsImpostorParser(t, s, e), e.lodMeshIds && (s._waitingData.lods = { ids: e.lodMeshIds, distances: e.lodDistances ? e.lodDistances : null, coverages: e.lodCoverages ? e.lodCoverages : null }), e.instances) for (let r = 0; r < e.instances.length; r++) { const n = e.instances[r], a = s.createInstance(n.name); if (n.id && (a.id = n.id), ne && (n.tags ? ne.AddTagsTo(a, n.tags) : ne.AddTagsTo(a, e.tags)), a.position = g.FromArray(n.position), n.metadata !== void 0 && (a.metadata = n.metadata), n.parentId !== void 0 && (a._waitingParentId = n.parentId), n.parentInstanceIndex !== void 0 && (a._waitingParentInstanceIndex = n.parentInstanceIndex), n.isEnabled !== void 0 && n.isEnabled !== null && a.setEnabled(n.isEnabled), n.isVisible !== void 0 && n.isVisible !== null && (a.isVisible = n.isVisible), n.isPickable !== void 0 && n.isPickable !== null && (a.isPickable = n.isPickable), n.rotationQuaternion ? a.rotationQuaternion = q.FromArray(n.rotationQuaternion) : n.rotation && (a.rotation = g.FromArray(n.rotation)), a.scaling = g.FromArray(n.scaling), n.checkCollisions != null && n.checkCollisions != null && (a.checkCollisions = n.checkCollisions), n.pickable != null && n.pickable != null && (a.isPickable = n.pickable), n.showBoundingBox != null && n.showBoundingBox != null && (a.showBoundingBox = n.showBoundingBox), n.showSubMeshesBoundingBox != null && n.showSubMeshesBoundingBox != null && (a.showSubMeshesBoundingBox = n.showSubMeshesBoundingBox), n.alphaIndex != null && n.showSubMeshesBoundingBox != null && (a.alphaIndex = n.alphaIndex), n.physicsImpostor && ie._PhysicsImpostorParser(t, a, n), n.actions !== void 0 && (a._waitingData.actions = n.actions), n.animations) { for (let o = 0; o < n.animations.length; o++) { const l = n.animations[o], h = Yt("BABYLON.Animation"); h && a.animations.push(h.Parse(l)) } We.ParseAnimationRanges(a, n, t), n.autoAnimate && t.beginAnimation(a, n.autoAnimateFrom, n.autoAnimateTo, n.autoAnimateLoop, n.autoAnimateSpeed || 1) } } if (e.thinInstances) { const r = e.thinInstances; if (s.thinInstanceEnablePicking = !!r.enablePicking, r.matrixData ? (s.thinInstanceSetBuffer("matrix", new Float32Array(r.matrixData), 16, !1), s._thinInstanceDataStorage.matrixBufferSize = r.matrixBufferSize, s._thinInstanceDataStorage.instancesCount = r.instancesCount) : s._thinInstanceDataStorage.matrixBufferSize = r.matrixBufferSize, e.thinInstances.userThinInstance) { const n = e.thinInstances.userThinInstance; for (const a in n.data) s.thinInstanceSetBuffer(a, new Float32Array(n.data[a]), n.strides[a], !1), s._userThinInstanceBuffersStorage.sizes[a] = n.sizes[a] } } return s } setPositionsForCPUSkinning() { const e = this._internalMeshDataInfo; if (!e._sourcePositions) { const t = this.getVerticesData(d.PositionKind); if (!t) return e._sourcePositions; e._sourcePositions = new Float32Array(t), this.isVertexBufferUpdatable(d.PositionKind) || this.setVerticesData(d.PositionKind, t, !0) } return e._sourcePositions } setNormalsForCPUSkinning() { const e = this._internalMeshDataInfo; if (!e._sourceNormals) { const t = this.getVerticesData(d.NormalKind); if (!t) return e._sourceNormals; e._sourceNormals = new Float32Array(t), this.isVertexBufferUpdatable(d.NormalKind) || this.setVerticesData(d.NormalKind, t, !0) } return e._sourceNormals } applySkeleton(e) { if (!this.geometry) return this; if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) return this; if (this.geometry._softwareSkinningFrameId = this.getScene().getFrameId(), !this.isVerticesDataPresent(d.PositionKind)) return this; if (!this.isVerticesDataPresent(d.MatricesIndicesKind)) return this; if (!this.isVerticesDataPresent(d.MatricesWeightsKind)) return this; const t = this.isVerticesDataPresent(d.NormalKind), i = this._internalMeshDataInfo; if (!i._sourcePositions) { const m = this.subMeshes.slice(); this.setPositionsForCPUSkinning(), this.subMeshes = m } t && !i._sourceNormals && this.setNormalsForCPUSkinning(); let s = this.getVerticesData(d.PositionKind); if (!s) return this; s instanceof Float32Array || (s = new Float32Array(s)); let r = this.getVerticesData(d.NormalKind); if (t) { if (!r) return this; r instanceof Float32Array || (r = new Float32Array(r)) } const n = this.getVerticesData(d.MatricesIndicesKind), a = this.getVerticesData(d.MatricesWeightsKind); if (!a || !n) return this; const o = this.numBoneInfluencers > 4, l = o ? this.getVerticesData(d.MatricesIndicesExtraKind) : null, h = o ? this.getVerticesData(d.MatricesWeightsExtraKind) : null, u = e.getTransformMatrices(this), f = g.Zero(), _ = new A, p = new A; let v = 0, E; for (let m = 0; m < s.length; m += 3, v += 4) { let x; for (E = 0; E < 4; E++)x = a[v + E], x > 0 && (A.FromFloat32ArrayToRefScaled(u, Math.floor(n[v + E] * 16), x, p), _.addToSelf(p)); if (o) for (E = 0; E < 4; E++)x = h[v + E], x > 0 && (A.FromFloat32ArrayToRefScaled(u, Math.floor(l[v + E] * 16), x, p), _.addToSelf(p)); g.TransformCoordinatesFromFloatsToRef(i._sourcePositions[m], i._sourcePositions[m + 1], i._sourcePositions[m + 2], _, f), f.toArray(s, m), t && (g.TransformNormalFromFloatsToRef(i._sourceNormals[m], i._sourceNormals[m + 1], i._sourceNormals[m + 2], _, f), f.toArray(r, m)), _.reset() } return this.updateVerticesData(d.PositionKind, s), t && this.updateVerticesData(d.NormalKind, r), this } static MinMax(e) { let t = null, i = null; return e.forEach(function (s) { const n = s.getBoundingInfo().boundingBox; !t || !i ? (t = n.minimumWorld, i = n.maximumWorld) : (t.minimizeInPlace(n.minimumWorld), i.maximizeInPlace(n.maximumWorld)) }), !t || !i ? { min: g.Zero(), max: g.Zero() } : { min: t, max: i } } static Center(e) { const t = e instanceof Array ? ie.MinMax(e) : e; return g.Center(t.min, t.max) } static MergeMeshes(e, t = !0, i, s, r, n) { return Xi(ie._MergeMeshesCoroutine(e, t, i, s, r, n, !1)) } static MergeMeshesAsync(e, t = !0, i, s, r, n) { return Kr(ie._MergeMeshesCoroutine(e, t, i, s, r, n, !0), Hr()) } static *_MergeMeshesCoroutine(e, t = !0, i, s, r, n, a) { if (e = e.filter(Boolean), e.length === 0) return null; let o; if (!i) { let R = 0; for (o = 0; o < e.length; o++)if (R += e[o].getTotalVertices(), R >= 65536) return O.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"), null } n && (r = !1); const l = new Array, h = new Array, u = new Array, f = e[0].overrideMaterialSideOrientation; for (o = 0; o < e.length; o++) { const R = e[o]; if (R.isAnInstance) return O.Warn("Cannot merge instance meshes."), null; if (f !== R.overrideMaterialSideOrientation) return O.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values."), null; if (r && u.push(R.getTotalIndices()), n) if (R.material) { const w = R.material; if (w instanceof Kt) { for (let N = 0; N < w.subMaterials.length; N++)l.indexOf(w.subMaterials[N]) < 0 && l.push(w.subMaterials[N]); for (let N = 0; N < R.subMeshes.length; N++)h.push(l.indexOf(w.subMaterials[R.subMeshes[N].materialIndex])), u.push(R.subMeshes[N].indexCount) } else { l.indexOf(w) < 0 && l.push(w); for (let N = 0; N < R.subMeshes.length; N++)h.push(l.indexOf(w)), u.push(R.subMeshes[N].indexCount) } } else for (let w = 0; w < R.subMeshes.length; w++)h.push(0), u.push(R.subMeshes[w].indexCount) } const _ = e[0], p = R => { const w = R.computeWorldMatrix(!0); return { vertexData: Y.ExtractFromMesh(R, !1, !1), transform: w } }, { vertexData: v, transform: E } = p(_); a && (yield); const m = new Array(e.length - 1); for (let R = 1; R < e.length; R++)m[R - 1] = p(e[R]), a && (yield); const x = v._mergeCoroutine(E, m, i, a, !t); let C = x.next(); for (; !C.done;)a && (yield), C = x.next(); const S = C.value; s || (s = new ie(_.name + "_merged", _.getScene())); const y = S._applyToCoroutine(s, void 0, a); let b = y.next(); for (; !b.done;)a && (yield), b = y.next(); if (s.checkCollisions = _.checkCollisions, s.overrideMaterialSideOrientation = _.overrideMaterialSideOrientation, t) for (o = 0; o < e.length; o++)e[o].dispose(); if (r || n) { s.releaseSubMeshes(), o = 0; let R = 0; for (; o < u.length;)nt.CreateFromIndices(0, R, u[o], s, void 0, !1), R += u[o], o++; for (const w of s.subMeshes) w.refreshBoundingInfo(); s.computeWorldMatrix(!0) } if (n) { const R = new Kt(_.name + "_merged", _.getScene()); R.subMaterials = l; for (let w = 0; w < s.subMeshes.length; w++)s.subMeshes[w].materialIndex = h[w]; s.material = R } else s.material = _.material; return s } addInstance(e) { e._indexInSourceMeshInstanceArray = this.instances.length, this.instances.push(e) } removeInstance(e) { const t = e._indexInSourceMeshInstanceArray; if (t != -1) { if (t !== this.instances.length - 1) { const i = this.instances[this.instances.length - 1]; this.instances[t] = i, i._indexInSourceMeshInstanceArray = t } e._indexInSourceMeshInstanceArray = -1, this.instances.pop() } } _shouldConvertRHS() { return this.overrideMaterialSideOrientation === I.CounterClockWiseSideOrientation } _getRenderingFillMode(e) { var t; const i = this.getScene(); return i.forcePointsCloud ? I.PointFillMode : i.forceWireframe ? I.WireFrameFillMode : (t = this.overrideRenderingFillMode) !== null && t !== void 0 ? t : e } setMaterialByID(e) { return this.setMaterialById(e) } static CreateRibbon(e, t, i, s, r, n, a, o, l) { throw new Error("Import MeshBuilder to populate this function") } static CreateDisc(e, t, i, s, r, n) { throw new Error("Import MeshBuilder to populate this function") } static CreateBox(e, t, i, s, r) { throw new Error("Import MeshBuilder to populate this function") } static CreateSphere(e, t, i, s, r, n) { throw new Error("Import MeshBuilder to populate this function") } static CreateHemisphere(e, t, i, s) { throw new Error("Import MeshBuilder to populate this function") } static CreateCylinder(e, t, i, s, r, n, a, o, l) { throw new Error("Import MeshBuilder to populate this function") } static CreateTorus(e, t, i, s, r, n, a) { throw new Error("Import MeshBuilder to populate this function") } static CreateTorusKnot(e, t, i, s, r, n, a, o, l, h) { throw new Error("Import MeshBuilder to populate this function") } static CreateLines(e, t, i, s, r) { throw new Error("Import MeshBuilder to populate this function") } static CreateDashedLines(e, t, i, s, r, n, a, o) { throw new Error("Import MeshBuilder to populate this function") } static CreatePolygon(e, t, i, s, r, n, a) { throw new Error("Import MeshBuilder to populate this function") } static ExtrudePolygon(e, t, i, s, r, n, a, o) { throw new Error("Import MeshBuilder to populate this function") } static ExtrudeShape(e, t, i, s, r, n, a, o, l, h) { throw new Error("Import MeshBuilder to populate this function") } static ExtrudeShapeCustom(e, t, i, s, r, n, a, o, l, h, u, f) { throw new Error("Import MeshBuilder to populate this function") } static CreateLathe(e, t, i, s, r, n, a) { throw new Error("Import MeshBuilder to populate this function") } static CreatePlane(e, t, i, s, r) { throw new Error("Import MeshBuilder to populate this function") } static CreateGround(e, t, i, s, r, n) { throw new Error("Import MeshBuilder to populate this function") } static CreateTiledGround(e, t, i, s, r, n, a, o, l) { throw new Error("Import MeshBuilder to populate this function") } static CreateGroundFromHeightMap(e, t, i, s, r, n, a, o, l, h, u) { throw new Error("Import MeshBuilder to populate this function") } static CreateTube(e, t, i, s, r, n, a, o, l, h) { throw new Error("Import MeshBuilder to populate this function") } static CreatePolyhedron(e, t, i) { throw new Error("Import MeshBuilder to populate this function") } static CreateIcoSphere(e, t, i) { throw new Error("Import MeshBuilder to populate this function") } static CreateDecal(e, t, i, s, r, n) { throw new Error("Import MeshBuilder to populate this function") } static CreateCapsule(e, t, i) { throw new Error("Import MeshBuilder to populate this function") } static ExtendToGoldberg(e) { throw new Error("Import MeshBuilder to populate this function") }
    } ie.FRONTSIDE = Y.FRONTSIDE, ie.BACKSIDE = Y.BACKSIDE, ie.DOUBLESIDE = Y.DOUBLESIDE, ie.DEFAULTSIDE = Y.DEFAULTSIDE, ie.NO_CAP = 0, ie.CAP_START = 1, ie.CAP_END = 2, ie.CAP_ALL = 3, ie.NO_FLIP = 0, ie.FLIP_TILE = 1, ie.ROTATE_TILE = 2, ie.FLIP_ROW = 3, ie.ROTATE_ROW = 4, ie.FLIP_N_ROTATE_TILE = 5, ie.FLIP_N_ROTATE_ROW = 6, ie.CENTER = 0, ie.LEFT = 1, ie.RIGHT = 2, ie.TOP = 3, ie.BOTTOM = 4, ie.INSTANCEDMESH_SORT_TRANSPARENT = !1, ie._GroundMeshParser = (c, e) => { throw K("GroundMesh") }, ie._GoldbergMeshParser = (c, e) => { throw K("GoldbergMesh") }, ie._LinesMeshParser = (c, e) => { throw K("LinesMesh") }, ie._GreasedLineMeshParser = (c, e) => { throw K("GreasedLineMesh") }, ie._GreasedLineRibbonMeshParser = (c, e) => { throw K("GreasedLineRibbonMesh") }, ie._TrailMeshParser = (c, e) => { throw K("TrailMesh") }, at("BABYLON.Mesh", ie); function ji(c) { const e = [], t = [], i = [], s = [], r = c.width || c.size || 1, n = c.height || c.size || 1, a = c.sideOrientation === 0 ? 0 : c.sideOrientation || Y.DEFAULTSIDE, o = r / 2, l = n / 2; t.push(-o, -l, 0), i.push(0, 0, -1), s.push(0, Qe.UseOpenGLOrientationForUV ? 1 : 0), t.push(o, -l, 0), i.push(0, 0, -1), s.push(1, Qe.UseOpenGLOrientationForUV ? 1 : 0), t.push(o, l, 0), i.push(0, 0, -1), s.push(1, Qe.UseOpenGLOrientationForUV ? 0 : 1), t.push(-o, l, 0), i.push(0, 0, -1), s.push(0, Qe.UseOpenGLOrientationForUV ? 0 : 1), e.push(0), e.push(1), e.push(2), e.push(0), e.push(2), e.push(3), Y._ComputeSides(a, t, e, i, s, c.frontUVs, c.backUVs); const h = new Y; return h.indices = e, h.positions = t, h.normals = i, h.uvs = s, h } function pn(c, e = {}, t = null) { const i = new ie(c, t); return e.sideOrientation = ie._GetDefaultSideOrientation(e.sideOrientation), i._originalBuilderSideOrientation = e.sideOrientation, ji(e).applyToMesh(i, e.updatable), e.sourcePlane && (i.translate(e.sourcePlane.normal, -e.sourcePlane.d), i.setDirection(e.sourcePlane.normal.scale(-1))), i } Y.CreatePlane = ji, ie.CreatePlane = (c, e, t, i, s) => pn(c, { size: e, width: e, height: e, sideOrientation: s, updatable: i }, t); class Ks { constructor() { this.previousWorldMatrices = {}, this.previousBones = {} } static AddUniforms(e) { e.push("previousWorld", "previousViewProjection", "mPreviousBones") } static AddSamplers(e) { } bindForSubMesh(e, t, i, s, r) { if (t.prePassRenderer && t.prePassRenderer.enabled && t.prePassRenderer.currentRTisSceneRT && t.prePassRenderer.getIndex(2) !== -1) { this.previousWorldMatrices[i.uniqueId] || (this.previousWorldMatrices[i.uniqueId] = s.clone()), this.previousViewProjection || (this.previousViewProjection = t.getTransformMatrix().clone(), this.currentViewProjection = t.getTransformMatrix().clone()); const n = t.getEngine(); this.currentViewProjection.updateFlag !== t.getTransformMatrix().updateFlag ? (this._lastUpdateFrameId = n.frameId, this.previousViewProjection.copyFrom(this.currentViewProjection), this.currentViewProjection.copyFrom(t.getTransformMatrix())) : this._lastUpdateFrameId !== n.frameId && (this._lastUpdateFrameId = n.frameId, this.previousViewProjection.copyFrom(this.currentViewProjection)), e.setMatrix("previousWorld", this.previousWorldMatrices[i.uniqueId]), e.setMatrix("previousViewProjection", this.previousViewProjection), this.previousWorldMatrices[i.uniqueId] = s.clone() } } } class vn extends I { constructor(e, t, i = !0) { super(e, t), this._normalMatrix = new A, this._storeEffectOnSubMeshes = i } getEffect() { return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect() } isReady(e, t) { return e ? !this._storeEffectOnSubMeshes || !e.subMeshes || e.subMeshes.length === 0 ? !0 : this.isReadyForSubMesh(e, e.subMeshes[0], t) : !1 } _isReadyForSubMesh(e) { const t = e.materialDefines; return !!(!this.checkReadyOnEveryCall && e.effect && t && t._renderId === this.getScene().getRenderId()) } bindOnlyWorldMatrix(e) { this._activeEffect.setMatrix("world", e) } bindOnlyNormalMatrix(e) { this._activeEffect.setMatrix("normalMatrix", e) } bind(e, t) { t && this.bindForSubMesh(e, t, t.subMeshes[0]) } _afterBind(e, t = null) { super._afterBind(e, t), this.getScene()._cachedEffect = t, t && (t._forceRebindOnNextCall = !1) } _mustRebind(e, t, i = 1) { return e.isCachedMaterialInvalid(this, t, i) } dispose(e, t, i) { this._activeEffect = void 0, super.dispose(e, t, i) } } class Zi { get wrapU() { return this._wrapU } set wrapU(e) { this._wrapU = e } get wrapV() { return this._wrapV } set wrapV(e) { this._wrapV = e } get coordinatesMode() { return 0 } get isCube() { return this._texture ? this._texture.isCube : !1 } set isCube(e) { this._texture && (this._texture.isCube = e) } get is3D() { return this._texture ? this._texture.is3D : !1 } set is3D(e) { this._texture && (this._texture.is3D = e) } get is2DArray() { return this._texture ? this._texture.is2DArray : !1 } set is2DArray(e) { this._texture && (this._texture.is2DArray = e) } getClassName() { return "ThinTexture" } static _IsRenderTargetWrapper(e) { return (e == null ? void 0 : e._shareDepth) !== void 0 } constructor(e) { this._wrapU = 1, this._wrapV = 1, this.wrapR = 1, this.anisotropicFilteringLevel = 4, this.delayLoadState = 0, this._texture = null, this._engine = null, this._cachedSize = lt.Zero(), this._cachedBaseSize = lt.Zero(), this._initialSamplingMode = 2, this._texture = Zi._IsRenderTargetWrapper(e) ? e.texture : e, this._texture && (this._engine = this._texture.getEngine()) } isReady() { return this.delayLoadState === 4 ? (this.delayLoad(), !1) : this._texture ? this._texture.isReady : !1 } delayLoad() { } getInternalTexture() { return this._texture } getSize() { if (this._texture) { if (this._texture.width) return this._cachedSize.width = this._texture.width, this._cachedSize.height = this._texture.height, this._cachedSize; if (this._texture._size) return this._cachedSize.width = this._texture._size, this._cachedSize.height = this._texture._size, this._cachedSize } return this._cachedSize } getBaseSize() { return !this.isReady() || !this._texture ? (this._cachedBaseSize.width = 0, this._cachedBaseSize.height = 0, this._cachedBaseSize) : this._texture._size ? (this._cachedBaseSize.width = this._texture._size, this._cachedBaseSize.height = this._texture._size, this._cachedBaseSize) : (this._cachedBaseSize.width = this._texture.baseWidth, this._cachedBaseSize.height = this._texture.baseHeight, this._cachedBaseSize) } get samplingMode() { return this._texture ? this._texture.samplingMode : this._initialSamplingMode } updateSamplingMode(e) { this._texture && this._engine && this._engine.updateTextureSamplingMode(e, this._texture) } releaseInternalTexture() { this._texture && (this._texture.dispose(), this._texture = null) } dispose() { this._texture && (this.releaseInternalTexture(), this._engine = null) } } class pe extends Zi { set hasAlpha(e) { this._hasAlpha !== e && (this._hasAlpha = e, this._scene && this._scene.markAllMaterialsAsDirty(1, t => t.hasTexture(this))) } get hasAlpha() { return this._hasAlpha } set getAlphaFromRGB(e) { this._getAlphaFromRGB !== e && (this._getAlphaFromRGB = e, this._scene && this._scene.markAllMaterialsAsDirty(1, t => t.hasTexture(this))) } get getAlphaFromRGB() { return this._getAlphaFromRGB } set coordinatesIndex(e) { this._coordinatesIndex !== e && (this._coordinatesIndex = e, this._scene && this._scene.markAllMaterialsAsDirty(1, t => t.hasTexture(this))) } get coordinatesIndex() { return this._coordinatesIndex } set coordinatesMode(e) { this._coordinatesMode !== e && (this._coordinatesMode = e, this._scene && this._scene.markAllMaterialsAsDirty(1, t => t.hasTexture(this))) } get coordinatesMode() { return this._coordinatesMode } get wrapU() { return this._wrapU } set wrapU(e) { this._wrapU = e } get wrapV() { return this._wrapV } set wrapV(e) { this._wrapV = e } get isCube() { return this._texture ? this._texture.isCube : this._isCube } set isCube(e) { this._texture ? this._texture.isCube = e : this._isCube = e } get is3D() { return this._texture ? this._texture.is3D : !1 } set is3D(e) { this._texture && (this._texture.is3D = e) } get is2DArray() { return this._texture ? this._texture.is2DArray : !1 } set is2DArray(e) { this._texture && (this._texture.is2DArray = e) } get gammaSpace() { if (this._texture) this._texture._gammaSpace === null && (this._texture._gammaSpace = this._gammaSpace); else return this._gammaSpace; return this._texture._gammaSpace && !this._texture._useSRGBBuffer } set gammaSpace(e) { var t; if (this._texture) { if (this._texture._gammaSpace === e) return; this._texture._gammaSpace = e } else { if (this._gammaSpace === e) return; this._gammaSpace = e } (t = this.getScene()) === null || t === void 0 || t.markAllMaterialsAsDirty(1, i => i.hasTexture(this)) } get isRGBD() { return this._texture != null && this._texture._isRGBD } set isRGBD(e) { var t; e !== this.isRGBD && (this._texture && (this._texture._isRGBD = e), (t = this.getScene()) === null || t === void 0 || t.markAllMaterialsAsDirty(1, i => i.hasTexture(this))) } get noMipmap() { return !1 } get lodGenerationOffset() { return this._texture ? this._texture._lodGenerationOffset : 0 } set lodGenerationOffset(e) { this._texture && (this._texture._lodGenerationOffset = e) } get lodGenerationScale() { return this._texture ? this._texture._lodGenerationScale : 0 } set lodGenerationScale(e) { this._texture && (this._texture._lodGenerationScale = e) } get linearSpecularLOD() { return this._texture ? this._texture._linearSpecularLOD : !1 } set linearSpecularLOD(e) { this._texture && (this._texture._linearSpecularLOD = e) } get irradianceTexture() { return this._texture ? this._texture._irradianceTexture : null } set irradianceTexture(e) { this._texture && (this._texture._irradianceTexture = e) } get uid() { return this._uid || (this._uid = xs()), this._uid } toString() { return this.name } getClassName() { return "BaseTexture" } set onDispose(e) { this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e) } get isBlocking() { return !0 } get loadingError() { return this._loadingError } get errorObject() { return this._errorObject } constructor(e, t = null) { super(null), this.metadata = null, this.reservedDataStore = null, this._hasAlpha = !1, this._getAlphaFromRGB = !1, this.level = 1, this._coordinatesIndex = 0, this.optimizeUVAllocation = !0, this._coordinatesMode = 0, this.wrapR = 1, this.anisotropicFilteringLevel = pe.DEFAULT_ANISOTROPIC_FILTERING_LEVEL, this._isCube = !1, this._gammaSpace = !0, this.invertZ = !1, this.lodLevelInAlpha = !1, this.isRenderTarget = !1, this._prefiltered = !1, this._forceSerialize = !1, this.animations = [], this.onDisposeObservable = new L, this._onDisposeObserver = null, this._scene = null, this._uid = null, this._parentContainer = null, this._loadingError = !1, e ? pe._IsScene(e) ? this._scene = e : this._engine = e : this._scene = ce.LastCreatedScene, this._scene && (this.uniqueId = this._scene.getUniqueId(), this._scene.addTexture(this), this._engine = this._scene.getEngine()), this._texture = t, this._uid = null } getScene() { return this._scene } _getEngine() { return this._engine } checkTransformsAreIdentical(e) { return e !== null } getTextureMatrix() { return A.IdentityReadOnly } getReflectionTextureMatrix() { return A.IdentityReadOnly } getRefractionTextureMatrix() { return this.getReflectionTextureMatrix() } isReadyOrNotBlocking() { return !this.isBlocking || this.isReady() || this.loadingError } scale(e) { } get canRescale() { return !1 } _getFromCache(e, t, i, s, r, n) { const a = this._getEngine(); if (!a) return null; const o = a._getUseSRGBBuffer(!!r, t), l = a.getLoadedTexturesCache(); for (let h = 0; h < l.length; h++) { const u = l[h]; if ((r === void 0 || o === u._useSRGBBuffer) && (s === void 0 || s === u.invertY) && u.url === e && u.generateMipMaps === !t && (!i || i === u.samplingMode) && (n === void 0 || n === u.isCube)) return u.incrementReferences(), u } return null } _rebuild() { } clone() { return null } get textureType() { return this._texture && this._texture.type !== void 0 ? this._texture.type : 0 } get textureFormat() { return this._texture && this._texture.format !== void 0 ? this._texture.format : 5 } _markAllSubMeshesAsTexturesDirty() { const e = this.getScene(); e && e.markAllMaterialsAsDirty(1) } readPixels(e = 0, t = 0, i = null, s = !0, r = !1, n = 0, a = 0, o = Number.MAX_VALUE, l = Number.MAX_VALUE) { if (!this._texture) return null; const h = this._getEngine(); if (!h) return null; const u = this.getSize(); let f = u.width, _ = u.height; t !== 0 && (f = f / Math.pow(2, t), _ = _ / Math.pow(2, t), f = Math.round(f), _ = Math.round(_)), o = Math.min(f, o), l = Math.min(_, l); try { return this._texture.isCube ? h._readTexturePixels(this._texture, o, l, e, t, i, s, r, n, a) : h._readTexturePixels(this._texture, o, l, -1, t, i, s, r, n, a) } catch { return null } } _readPixelsSync(e = 0, t = 0, i = null, s = !0, r = !1) { if (!this._texture) return null; const n = this.getSize(); let a = n.width, o = n.height; const l = this._getEngine(); if (!l) return null; t != 0 && (a = a / Math.pow(2, t), o = o / Math.pow(2, t), a = Math.round(a), o = Math.round(o)); try { return this._texture.isCube ? l._readTexturePixelsSync(this._texture, a, o, e, t, i, s, r) : l._readTexturePixelsSync(this._texture, a, o, -1, t, i, s, r) } catch { return null } } get _lodTextureHigh() { return this._texture ? this._texture._lodTextureHigh : null } get _lodTextureMid() { return this._texture ? this._texture._lodTextureMid : null } get _lodTextureLow() { return this._texture ? this._texture._lodTextureLow : null } dispose() { if (this._scene) { this._scene.stopAnimation && this._scene.stopAnimation(this), this._scene.removePendingData(this); const e = this._scene.textures.indexOf(this); if (e >= 0 && this._scene.textures.splice(e, 1), this._scene.onTextureRemovedObservable.notifyObservers(this), this._scene = null, this._parentContainer) { const t = this._parentContainer.textures.indexOf(this); t > -1 && this._parentContainer.textures.splice(t, 1), this._parentContainer = null } } this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.metadata = null, super.dispose() } serialize(e = !1) { if (!this.name && !e) return null; const t = re.Serialize(this); return re.AppendSerializedAnimations(this, t), t } static WhenAllReady(e, t) { let i = e.length; if (i === 0) { t(); return } for (let s = 0; s < e.length; s++) { const r = e[s]; if (r.isReady()) --i === 0 && t(); else { const n = r.onLoadObservable; n ? n.addOnce(() => { --i === 0 && t() }) : --i === 0 && t() } } } static _IsScene(e) { return e.getClassName() === "Scene" } } pe.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4, T([M()], pe.prototype, "uniqueId", void 0), T([M()], pe.prototype, "name", void 0), T([M()], pe.prototype, "metadata", void 0), T([M("hasAlpha")], pe.prototype, "_hasAlpha", void 0), T([M("getAlphaFromRGB")], pe.prototype, "_getAlphaFromRGB", void 0), T([M()], pe.prototype, "level", void 0), T([M("coordinatesIndex")], pe.prototype, "_coordinatesIndex", void 0), T([M()], pe.prototype, "optimizeUVAllocation", void 0), T([M("coordinatesMode")], pe.prototype, "_coordinatesMode", void 0), T([M()], pe.prototype, "wrapU", null), T([M()], pe.prototype, "wrapV", null), T([M()], pe.prototype, "wrapR", void 0), T([M()], pe.prototype, "anisotropicFilteringLevel", void 0), T([M()], pe.prototype, "isCube", null), T([M()], pe.prototype, "is3D", null), T([M()], pe.prototype, "is2DArray", null), T([M()], pe.prototype, "gammaSpace", null), T([M()], pe.prototype, "invertZ", void 0), T([M()], pe.prototype, "lodLevelInAlpha", void 0), T([M()], pe.prototype, "lodGenerationOffset", null), T([M()], pe.prototype, "lodGenerationScale", null), T([M()], pe.prototype, "linearSpecularLOD", null), T([st()], pe.prototype, "irradianceTexture", null), T([M()], pe.prototype, "isRenderTarget", void 0); function Ys(c, e, t = !1) { const i = e.width, s = e.height; if (c instanceof Float32Array) { let l = c.byteLength / c.BYTES_PER_ELEMENT; const h = new Uint8Array(l); for (; --l >= 0;) { let u = c[l]; u < 0 ? u = 0 : u > 1 && (u = 1), h[l] = u * 255 } c = h } const r = document.createElement("canvas"); r.width = i, r.height = s; const n = r.getContext("2d"); if (!n) return null; const a = n.createImageData(i, s); if (a.data.set(c), n.putImageData(a, 0, 0), t) { const l = document.createElement("canvas"); l.width = i, l.height = s; const h = l.getContext("2d"); return h ? (h.translate(0, s), h.scale(1, -1), h.drawImage(r, 0, 0), l.toDataURL("image/png")) : null } return r.toDataURL("image/png") } function En(c, e = 0, t = 0) { const i = c.getInternalTexture(); if (!i) return null; const s = c._readPixelsSync(e, t); return s ? Ys(s, c.getSize(), i.invertY) : null } async function bn(c, e = 0, t = 0) { const i = c.getInternalTexture(); if (!i) return null; const s = await c.readPixels(e, t); return s ? Ys(s, c.getSize(), i.invertY) : null } class V extends pe { static _CreateVideoTexture(e, t, i, s = !1, r = !1, n = V.TRILINEAR_SAMPLINGMODE, a = {}, o, l = 5) { throw K("VideoTexture") } get noMipmap() { return this._noMipmap } get mimeType() { return this._mimeType } set isBlocking(e) { this._isBlocking = e } get isBlocking() { return this._isBlocking } get invertY() { return this._invertY } constructor(e, t, i, s, r = V.TRILINEAR_SAMPLINGMODE, n = null, a = null, o = null, l = !1, h, u, f, _, p) { var v, E, m, x, C, S, y, b, R, w; super(t), this.url = null, this.uOffset = 0, this.vOffset = 0, this.uScale = 1, this.vScale = 1, this.uAng = 0, this.vAng = 0, this.wAng = 0, this.uRotationCenter = .5, this.vRotationCenter = .5, this.wRotationCenter = .5, this.homogeneousRotationInUVTransform = !1, this.inspectableCustomProperties = null, this._noMipmap = !1, this._invertY = !1, this._rowGenerationMatrix = null, this._cachedTextureMatrix = null, this._projectionModeMatrix = null, this._t0 = null, this._t1 = null, this._t2 = null, this._cachedUOffset = -1, this._cachedVOffset = -1, this._cachedUScale = 0, this._cachedVScale = 0, this._cachedUAng = -1, this._cachedVAng = -1, this._cachedWAng = -1, this._cachedReflectionProjectionMatrixId = -1, this._cachedURotationCenter = -1, this._cachedVRotationCenter = -1, this._cachedWRotationCenter = -1, this._cachedHomogeneousRotationInUVTransform = !1, this._cachedReflectionTextureMatrix = null, this._cachedReflectionUOffset = -1, this._cachedReflectionVOffset = -1, this._cachedReflectionUScale = 0, this._cachedReflectionVScale = 0, this._cachedReflectionCoordinatesMode = -1, this._buffer = null, this._deleteBuffer = !1, this._format = null, this._delayedOnLoad = null, this._delayedOnError = null, this.onLoadObservable = new L, this._isBlocking = !0, this.name = e || "", this.url = e; let N, X = !1, fe = null, J = !0; typeof i == "object" && i !== null ? (N = (v = i.noMipmap) !== null && v !== void 0 ? v : !1, s = (E = i.invertY) !== null && E !== void 0 ? E : !Qe.UseOpenGLOrientationForUV, r = (m = i.samplingMode) !== null && m !== void 0 ? m : V.TRILINEAR_SAMPLINGMODE, n = (x = i.onLoad) !== null && x !== void 0 ? x : null, a = (C = i.onError) !== null && C !== void 0 ? C : null, o = (S = i.buffer) !== null && S !== void 0 ? S : null, l = (y = i.deleteBuffer) !== null && y !== void 0 ? y : !1, h = i.format, u = i.mimeType, f = i.loaderOptions, _ = i.creationFlags, X = (b = i.useSRGBBuffer) !== null && b !== void 0 ? b : !1, fe = (R = i.internalTexture) !== null && R !== void 0 ? R : null, J = (w = i.gammaSpace) !== null && w !== void 0 ? w : J) : N = !!i, this._gammaSpace = J, this._noMipmap = N, this._invertY = s === void 0 ? !Qe.UseOpenGLOrientationForUV : s, this._initialSamplingMode = r, this._buffer = o, this._deleteBuffer = l, this._mimeType = u, this._loaderOptions = f, this._creationFlags = _, this._useSRGBBuffer = X, this._forcedExtension = p, h && (this._format = h); const ae = this.getScene(), ee = this._getEngine(); if (!ee) return; ee.onBeforeTextureInitObservable.notifyObservers(this); const Me = () => { this._texture && (this._texture._invertVScale && (this.vScale *= -1, this.vOffset += 1), this._texture._cachedWrapU !== null && (this.wrapU = this._texture._cachedWrapU, this._texture._cachedWrapU = null), this._texture._cachedWrapV !== null && (this.wrapV = this._texture._cachedWrapV, this._texture._cachedWrapV = null), this._texture._cachedWrapR !== null && (this.wrapR = this._texture._cachedWrapR, this._texture._cachedWrapR = null)), this.onLoadObservable.hasObservers() && this.onLoadObservable.notifyObservers(this), n && n(), !this.isBlocking && ae && ae.resetCachedMaterial() }, Ae = (Se, xe) => { this._loadingError = !0, this._errorObject = { message: Se, exception: xe }, a && a(Se, xe), V.OnTextureLoadErrorObservable.notifyObservers(this) }; if (!this.url && !fe) { this._delayedOnLoad = Me, this._delayedOnError = Ae; return } if (this._texture = fe ?? this._getFromCache(this.url, N, r, this._invertY, X, this.isCube), this._texture) if (this._texture.isReady) vi.SetImmediate(() => Me()); else { const Se = this._texture.onLoadedObservable.add(Me); this._texture.onErrorObservable.add(xe => { var Re; Ae(xe.message, xe.exception), (Re = this._texture) === null || Re === void 0 || Re.onLoadedObservable.remove(Se) }) } else if (!ae || !ae.useDelayedTextureLoading) { try { this._texture = ee.createTexture(this.url, N, this._invertY, ae, r, Me, Ae, this._buffer, void 0, this._format, this._forcedExtension, u, f, _, X) } catch (Se) { throw Ae("error loading", Se), Se } l && (this._buffer = null) } else this.delayLoadState = 4, this._delayedOnLoad = Me, this._delayedOnError = Ae } updateURL(e, t = null, i, s) { this.url && (this.releaseInternalTexture(), this.getScene().markAllMaterialsAsDirty(1, r => r.hasTexture(this))), (!this.name || this.name.startsWith("data:")) && (this.name = e), this.url = e, this._buffer = t, this._forcedExtension = s, this.delayLoadState = 4, i && (this._delayedOnLoad = i), this.delayLoad() } delayLoad() { if (this.delayLoadState !== 4) return; const e = this.getScene(); e && (this.delayLoadState = 1, this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer, this.isCube), this._texture ? this._delayedOnLoad && (this._texture.isReady ? vi.SetImmediate(this._delayedOnLoad) : this._texture.onLoadedObservable.add(this._delayedOnLoad)) : (this._texture = e.getEngine().createTexture(this.url, this._noMipmap, this._invertY, e, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer), this._deleteBuffer && (this._buffer = null)), this._delayedOnLoad = null, this._delayedOnError = null) } _prepareRowForTextureGeneration(e, t, i, s) { e *= this._cachedUScale, t *= this._cachedVScale, e -= this.uRotationCenter * this._cachedUScale, t -= this.vRotationCenter * this._cachedVScale, i -= this.wRotationCenter, g.TransformCoordinatesFromFloatsToRef(e, t, i, this._rowGenerationMatrix, s), s.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset, s.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset, s.z += this.wRotationCenter } checkTransformsAreIdentical(e) { return e !== null && this.uOffset === e.uOffset && this.vOffset === e.vOffset && this.uScale === e.uScale && this.vScale === e.vScale && this.uAng === e.uAng && this.vAng === e.vAng && this.wAng === e.wAng } getTextureMatrix(e = 1) { if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * e === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) return this._cachedTextureMatrix; this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale * e, this._cachedVScale = this.vScale, this._cachedUAng = this.uAng, this._cachedVAng = this.vAng, this._cachedWAng = this.wAng, this._cachedURotationCenter = this.uRotationCenter, this._cachedVRotationCenter = this.vRotationCenter, this._cachedWRotationCenter = this.wRotationCenter, this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform, (!this._cachedTextureMatrix || !this._rowGenerationMatrix) && (this._cachedTextureMatrix = A.Zero(), this._rowGenerationMatrix = new A, this._t0 = g.Zero(), this._t1 = g.Zero(), this._t2 = g.Zero()), A.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix), this.homogeneousRotationInUVTransform ? (A.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, D.Matrix[0]), A.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, D.Matrix[1]), A.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, D.Matrix[2]), A.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, D.Matrix[3]), D.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[1], this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[2], this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[3], this._cachedTextureMatrix), this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1)) : (this._prepareRowForTextureGeneration(0, 0, 0, this._t0), this._prepareRowForTextureGeneration(1, 0, 0, this._t1), this._prepareRowForTextureGeneration(0, 1, 0, this._t2), this._t1.subtractInPlace(this._t0), this._t2.subtractInPlace(this._t0), A.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix)); const t = this.getScene(); return t ? (this.optimizeUVAllocation && t.markAllMaterialsAsDirty(1, i => i.hasTexture(this)), this._cachedTextureMatrix) : this._cachedTextureMatrix } getReflectionTextureMatrix() { const e = this.getScene(); if (!e) return this._cachedReflectionTextureMatrix; if (this.uOffset === this._cachedReflectionUOffset && this.vOffset === this._cachedReflectionVOffset && this.uScale === this._cachedReflectionUScale && this.vScale === this._cachedReflectionVScale && this.coordinatesMode === this._cachedReflectionCoordinatesMode) if (this.coordinatesMode === V.PROJECTION_MODE) { if (this._cachedReflectionProjectionMatrixId === e.getProjectionMatrix().updateFlag) return this._cachedReflectionTextureMatrix } else return this._cachedReflectionTextureMatrix; this._cachedReflectionTextureMatrix || (this._cachedReflectionTextureMatrix = A.Zero()), this._projectionModeMatrix || (this._projectionModeMatrix = A.Zero()); const t = this._cachedReflectionCoordinatesMode !== this.coordinatesMode; switch (this._cachedReflectionUOffset = this.uOffset, this._cachedReflectionVOffset = this.vOffset, this._cachedReflectionUScale = this.uScale, this._cachedReflectionVScale = this.vScale, this._cachedReflectionCoordinatesMode = this.coordinatesMode, this.coordinatesMode) { case V.PLANAR_MODE: { A.IdentityToRef(this._cachedReflectionTextureMatrix), this._cachedReflectionTextureMatrix[0] = this.uScale, this._cachedReflectionTextureMatrix[5] = this.vScale, this._cachedReflectionTextureMatrix[12] = this.uOffset, this._cachedReflectionTextureMatrix[13] = this.vOffset; break } case V.PROJECTION_MODE: { A.FromValuesToRef(.5, 0, 0, 0, 0, -.5, 0, 0, 0, 0, 0, 0, .5, .5, 1, 1, this._projectionModeMatrix); const i = e.getProjectionMatrix(); this._cachedReflectionProjectionMatrixId = i.updateFlag, i.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix); break } default: A.IdentityToRef(this._cachedReflectionTextureMatrix); break }return t && e.markAllMaterialsAsDirty(1, i => i.hasTexture(this)), this._cachedReflectionTextureMatrix } clone() { const e = { noMipmap: this._noMipmap, invertY: this._invertY, samplingMode: this.samplingMode, onLoad: void 0, onError: void 0, buffer: this._texture ? this._texture._buffer : void 0, deleteBuffer: this._deleteBuffer, format: this.textureFormat, mimeType: this.mimeType, loaderOptions: this._loaderOptions, creationFlags: this._creationFlags, useSRGBBuffer: this._useSRGBBuffer }; return re.Clone(() => new V(this._texture ? this._texture.url : null, this.getScene(), e), this) } serialize() { var e, t; const i = this.name; V.SerializeBuffers || this.name.startsWith("data:") && (this.name = ""), this.name.startsWith("data:") && this.url === this.name && (this.url = ""); const s = super.serialize(V._SerializeInternalTextureUniqueId); return s ? ((V.SerializeBuffers || V.ForceSerializeBuffers) && (typeof this._buffer == "string" && this._buffer.substr(0, 5) === "data:" ? (s.base64String = this._buffer, s.name = s.name.replace("data:", "")) : this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array ? s.base64String = "data:image/png;base64," + fs(this._buffer) : (V.ForceSerializeBuffers || this.url && this.url.startsWith("blob:") || this._forceSerialize) && (s.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? En(this) : bn(this))), s.invertY = this._invertY, s.samplingMode = this.samplingMode, s._creationFlags = this._creationFlags, s._useSRGBBuffer = this._useSRGBBuffer, V._SerializeInternalTextureUniqueId && (s.internalTextureUniqueId = (t = (e = this._texture) === null || e === void 0 ? void 0 : e.uniqueId) !== null && t !== void 0 ? t : void 0), s.noMipmap = this._noMipmap, this.name = i, s) : null } getClassName() { return "Texture" } dispose() { super.dispose(), this.onLoadObservable.clear(), this._delayedOnLoad = null, this._delayedOnError = null, this._buffer = null } static Parse(e, t, i) { if (e.customType) { const l = ni.Instantiate(e.customType).Parse(e, t, i); return e.samplingMode && l.updateSamplingMode && l._samplingMode && l._samplingMode !== e.samplingMode && l.updateSamplingMode(e.samplingMode), l } if (e.isCube && !e.isRenderTarget) return V._CubeTextureParser(e, t, i); const s = e.internalTextureUniqueId !== void 0; if (!e.name && !e.isRenderTarget && !s) return null; let r; if (s) { const o = t.getEngine().getLoadedTexturesCache(); for (const l of o) if (l.uniqueId === e.internalTextureUniqueId) { r = l; break } } const n = o => { var l; if (o && o._texture && (o._texture._cachedWrapU = null, o._texture._cachedWrapV = null, o._texture._cachedWrapR = null), e.samplingMode) { const h = e.samplingMode; o && o.samplingMode !== h && o.updateSamplingMode(h) } if (o && e.animations) for (let h = 0; h < e.animations.length; h++) { const u = e.animations[h], f = Yt("BABYLON.Animation"); f && o.animations.push(f.Parse(u)) } s && !r && ((l = o == null ? void 0 : o._texture) === null || l === void 0 || l._setUniqueId(e.internalTextureUniqueId)) }; return re.Parse(() => { var o, l, h; let u = !0; if (e.noMipmap && (u = !1), e.mirrorPlane) { const f = V._CreateMirror(e.name, e.renderTargetSize, t, u); return f._waitingRenderList = e.renderList, f.mirrorPlane = ot.FromArray(e.mirrorPlane), n(f), f } else if (e.isRenderTarget) { let f = null; if (e.isCube) { if (t.reflectionProbes) for (let _ = 0; _ < t.reflectionProbes.length; _++) { const p = t.reflectionProbes[_]; if (p.name === e.name) return p.cubeTexture } } else f = V._CreateRenderTargetTexture(e.name, e.renderTargetSize, t, u, (o = e._creationFlags) !== null && o !== void 0 ? o : 0), f._waitingRenderList = e.renderList; return n(f), f } else if (e.isVideo) { const f = V._CreateVideoTexture(i + (e.url || e.name), i + (e.src || e.url), t, u, e.invertY, e.samplingMode, e.settings || {}); return n(f), f } else { let f; if (e.base64String && !r) f = V.CreateFromBase64String(e.base64String, e.base64String, t, !u, e.invertY, e.samplingMode, () => { n(f) }, (l = e._creationFlags) !== null && l !== void 0 ? l : 0, (h = e._useSRGBBuffer) !== null && h !== void 0 ? h : !1), f.name = e.name; else { let _; e.name && (e.name.indexOf("://") > 0 || e.name.startsWith("data:")) ? _ = e.name : _ = i + e.name, e.url && (e.url.startsWith("data:") || V.UseSerializedUrlIfAny) && (_ = e.url); const p = { noMipmap: !u, invertY: e.invertY, samplingMode: e.samplingMode, onLoad: () => { n(f) }, internalTexture: r }; f = new V(_, t, p) } return f } }, e, t) } static CreateFromBase64String(e, t, i, s, r, n = V.TRILINEAR_SAMPLINGMODE, a = null, o = null, l = 5, h) { return new V("data:" + t, i, s, r, n, a, o, e, !1, l, void 0, void 0, h) } static LoadFromDataString(e, t, i, s = !1, r, n = !0, a = V.TRILINEAR_SAMPLINGMODE, o = null, l = null, h = 5, u) { return e.substr(0, 5) !== "data:" && (e = "data:" + e), new V(e, i, r, n, a, o, l, t, s, h, void 0, void 0, u) } } V.SerializeBuffers = !0, V.ForceSerializeBuffers = !1, V.OnTextureLoadErrorObservable = new L, V._SerializeInternalTextureUniqueId = !1, V._CubeTextureParser = (c, e, t) => { throw K("CubeTexture") }, V._CreateMirror = (c, e, t, i) => { throw K("MirrorTexture") }, V._CreateRenderTargetTexture = (c, e, t, i, s) => { throw K("RenderTargetTexture") }, V.NEAREST_SAMPLINGMODE = 1, V.NEAREST_NEAREST_MIPLINEAR = 8, V.BILINEAR_SAMPLINGMODE = 2, V.LINEAR_LINEAR_MIPNEAREST = 11, V.TRILINEAR_SAMPLINGMODE = 3, V.LINEAR_LINEAR_MIPLINEAR = 3, V.NEAREST_NEAREST_MIPNEAREST = 4, V.NEAREST_LINEAR_MIPNEAREST = 5, V.NEAREST_LINEAR_MIPLINEAR = 6, V.NEAREST_LINEAR = 7, V.NEAREST_NEAREST = 1, V.LINEAR_NEAREST_MIPNEAREST = 9, V.LINEAR_NEAREST_MIPLINEAR = 10, V.LINEAR_LINEAR = 2, V.LINEAR_NEAREST = 12, V.EXPLICIT_MODE = 0, V.SPHERICAL_MODE = 1, V.PLANAR_MODE = 2, V.CUBIC_MODE = 3, V.PROJECTION_MODE = 4, V.SKYBOX_MODE = 5, V.INVCUBIC_MODE = 6, V.EQUIRECTANGULAR_MODE = 7, V.FIXED_EQUIRECTANGULAR_MODE = 8, V.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9, V.CLAMP_ADDRESSMODE = 0, V.WRAP_ADDRESSMODE = 1, V.MIRROR_ADDRESSMODE = 2, V.UseSerializedUrlIfAny = !1, T([M()], V.prototype, "url", void 0), T([M()], V.prototype, "uOffset", void 0), T([M()], V.prototype, "vOffset", void 0), T([M()], V.prototype, "uScale", void 0), T([M()], V.prototype, "vScale", void 0), T([M()], V.prototype, "uAng", void 0), T([M()], V.prototype, "vAng", void 0), T([M()], V.prototype, "wAng", void 0), T([M()], V.prototype, "uRotationCenter", void 0), T([M()], V.prototype, "vRotationCenter", void 0), T([M()], V.prototype, "wRotationCenter", void 0), T([M()], V.prototype, "homogeneousRotationInUVTransform", void 0), T([M()], V.prototype, "isBlocking", null), at("BABYLON.Texture", V), re._TextureParser = V.Parse; class se { static get DiffuseTextureEnabled() { return this._DiffuseTextureEnabled } static set DiffuseTextureEnabled(e) { this._DiffuseTextureEnabled !== e && (this._DiffuseTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get DetailTextureEnabled() { return this._DetailTextureEnabled } static set DetailTextureEnabled(e) { this._DetailTextureEnabled !== e && (this._DetailTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get DecalMapEnabled() { return this._DecalMapEnabled } static set DecalMapEnabled(e) { this._DecalMapEnabled !== e && (this._DecalMapEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get AmbientTextureEnabled() { return this._AmbientTextureEnabled } static set AmbientTextureEnabled(e) { this._AmbientTextureEnabled !== e && (this._AmbientTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get OpacityTextureEnabled() { return this._OpacityTextureEnabled } static set OpacityTextureEnabled(e) { this._OpacityTextureEnabled !== e && (this._OpacityTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get ReflectionTextureEnabled() { return this._ReflectionTextureEnabled } static set ReflectionTextureEnabled(e) { this._ReflectionTextureEnabled !== e && (this._ReflectionTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get EmissiveTextureEnabled() { return this._EmissiveTextureEnabled } static set EmissiveTextureEnabled(e) { this._EmissiveTextureEnabled !== e && (this._EmissiveTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get SpecularTextureEnabled() { return this._SpecularTextureEnabled } static set SpecularTextureEnabled(e) { this._SpecularTextureEnabled !== e && (this._SpecularTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get BumpTextureEnabled() { return this._BumpTextureEnabled } static set BumpTextureEnabled(e) { this._BumpTextureEnabled !== e && (this._BumpTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get LightmapTextureEnabled() { return this._LightmapTextureEnabled } static set LightmapTextureEnabled(e) { this._LightmapTextureEnabled !== e && (this._LightmapTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get RefractionTextureEnabled() { return this._RefractionTextureEnabled } static set RefractionTextureEnabled(e) { this._RefractionTextureEnabled !== e && (this._RefractionTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get ColorGradingTextureEnabled() { return this._ColorGradingTextureEnabled } static set ColorGradingTextureEnabled(e) { this._ColorGradingTextureEnabled !== e && (this._ColorGradingTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get FresnelEnabled() { return this._FresnelEnabled } static set FresnelEnabled(e) { this._FresnelEnabled !== e && (this._FresnelEnabled = e, P.MarkAllMaterialsAsDirty(4)) } static get ClearCoatTextureEnabled() { return this._ClearCoatTextureEnabled } static set ClearCoatTextureEnabled(e) { this._ClearCoatTextureEnabled !== e && (this._ClearCoatTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get ClearCoatBumpTextureEnabled() { return this._ClearCoatBumpTextureEnabled } static set ClearCoatBumpTextureEnabled(e) { this._ClearCoatBumpTextureEnabled !== e && (this._ClearCoatBumpTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get ClearCoatTintTextureEnabled() { return this._ClearCoatTintTextureEnabled } static set ClearCoatTintTextureEnabled(e) { this._ClearCoatTintTextureEnabled !== e && (this._ClearCoatTintTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get SheenTextureEnabled() { return this._SheenTextureEnabled } static set SheenTextureEnabled(e) { this._SheenTextureEnabled !== e && (this._SheenTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get AnisotropicTextureEnabled() { return this._AnisotropicTextureEnabled } static set AnisotropicTextureEnabled(e) { this._AnisotropicTextureEnabled !== e && (this._AnisotropicTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get ThicknessTextureEnabled() { return this._ThicknessTextureEnabled } static set ThicknessTextureEnabled(e) { this._ThicknessTextureEnabled !== e && (this._ThicknessTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get RefractionIntensityTextureEnabled() { return this._ThicknessTextureEnabled } static set RefractionIntensityTextureEnabled(e) { this._RefractionIntensityTextureEnabled !== e && (this._RefractionIntensityTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get TranslucencyIntensityTextureEnabled() { return this._ThicknessTextureEnabled } static set TranslucencyIntensityTextureEnabled(e) { this._TranslucencyIntensityTextureEnabled !== e && (this._TranslucencyIntensityTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } static get IridescenceTextureEnabled() { return this._IridescenceTextureEnabled } static set IridescenceTextureEnabled(e) { this._IridescenceTextureEnabled !== e && (this._IridescenceTextureEnabled = e, P.MarkAllMaterialsAsDirty(1)) } } se._DiffuseTextureEnabled = !0, se._DetailTextureEnabled = !0, se._DecalMapEnabled = !0, se._AmbientTextureEnabled = !0, se._OpacityTextureEnabled = !0, se._ReflectionTextureEnabled = !0, se._EmissiveTextureEnabled = !0, se._SpecularTextureEnabled = !0, se._BumpTextureEnabled = !0, se._LightmapTextureEnabled = !0, se._RefractionTextureEnabled = !0, se._ColorGradingTextureEnabled = !0, se._FresnelEnabled = !0, se._ClearCoatTextureEnabled = !0, se._ClearCoatBumpTextureEnabled = !0, se._ClearCoatTintTextureEnabled = !0, se._SheenTextureEnabled = !0, se._AnisotropicTextureEnabled = !0, se._ThicknessTextureEnabled = !0, se._RefractionIntensityTextureEnabled = !0, se._TranslucencyIntensityTextureEnabled = !0, se._IridescenceTextureEnabled = !0; const Tn = "decalFragmentDeclaration", xn = `#ifdef DECAL
uniform vec4 vDecalInfos;
#endif
`; k.IncludesShadersStore[Tn] = xn; const An = "defaultFragmentDeclaration", Sn = `uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
uniform vec3 vEmissiveColor;uniform vec3 vAmbientColor;uniform float visibility;
#ifdef DIFFUSE
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY 
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#ifdef ALPHATEST
uniform float alphaCutOff;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFRACTION
uniform vec4 vRefractionInfos;
#ifndef REFRACTIONMAP_3D
uniform mat4 refractionMatrix;
#endif
#ifdef REFRACTIONFRESNEL
uniform vec4 refractionLeftColor;uniform vec4 refractionRightColor;
#endif
#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)
uniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; 
#endif
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
#endif
#ifdef DIFFUSEFRESNEL
uniform vec4 diffuseLeftColor;uniform vec4 diffuseRightColor;
#endif
#ifdef OPACITYFRESNEL
uniform vec4 opacityParts;
#endif
#ifdef EMISSIVEFRESNEL
uniform vec4 emissiveLeftColor;uniform vec4 emissiveRightColor;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)
uniform mat4 reflectionMatrix;
#endif
#ifndef REFLECTIONMAP_SKYBOX
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; 
#endif
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 reflectionLeftColor;uniform vec4 reflectionRightColor;
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#include<decalFragmentDeclaration>
#define ADDITIONAL_FRAGMENT_DECLARATION
`; k.IncludesShadersStore[An] = Sn; const Rn = "sceneUboDeclaration", yn = `layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;mat4 projection;vec4 vEyePosition;};
`; k.IncludesShadersStore[Rn] = yn; const Mn = "meshUboDeclaration", Cn = `#ifdef WEBGL2
uniform mat4 world;uniform float visibility;
#else
layout(std140,column_major) uniform;uniform Mesh
{mat4 world;float visibility;};
#endif
#define WORLD_UBO
`; k.IncludesShadersStore[Mn] = Cn; const In = "defaultUboDeclaration", Pn = `layout(std140,column_major) uniform;uniform Material
{vec4 diffuseLeftColor;vec4 diffuseRightColor;vec4 opacityParts;vec4 reflectionLeftColor;vec4 reflectionRightColor;vec4 refractionLeftColor;vec4 refractionRightColor;vec4 emissiveLeftColor;vec4 emissiveRightColor;vec2 vDiffuseInfos;vec2 vAmbientInfos;vec2 vOpacityInfos;vec2 vReflectionInfos;vec3 vReflectionPosition;vec3 vReflectionSize;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec2 vSpecularInfos;vec3 vBumpInfos;mat4 diffuseMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 reflectionMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 specularMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;float pointSize;float alphaCutOff;mat4 refractionMatrix;vec4 vRefractionInfos;vec3 vRefractionPosition;vec3 vRefractionSize;vec4 vSpecularColor;vec3 vEmissiveColor;vec4 vDiffuseColor;vec3 vAmbientColor;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`; k.IncludesShadersStore[In] = Pn; const Dn = "prePassDeclaration", Fn = `#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`; k.IncludesShadersStore[Dn] = Fn; const wn = "oitDeclaration", On = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;
#endif
`; k.IncludesShadersStore[wn] = On; const Ln = "mainUVVaryingDeclaration", Nn = `#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`; k.IncludesShadersStore[Ln] = Nn; const Bn = "helperFunctions", Un = `const float PI=3.1415926535897932384626433832795;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
mat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{return value*value;}
vec3 square(vec3 value)
{return value*value;}
float pow5(float value) {float sq=value*value;return sq*sq*value;}
float getLuminance(vec3 color)
{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}
float getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}
float dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}
const float rgbdMaxRange=255.0;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(clamp(rgb,0.,1.),D); }
vec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
`; k.IncludesShadersStore[Bn] = Un; const kn = "lightFragmentDeclaration", Vn = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X};
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#endif
`; k.IncludesShadersStore[kn] = Vn; const Wn = "lightUboDeclaration", Gn = `#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X}; 
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`; k.IncludesShadersStore[Wn] = Gn; const Xn = "lightsFragmentFunctions", zn = `struct lightingInfo
{vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef NDOTL
float ndl;
#endif
};lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 lightVectorW;float attenuation=1.0;if (lightData.w==0.)
{vec3 direction=lightData.xyz-vPositionW;attenuation=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}
else
{lightVectorW=normalize(-lightData.xyz);}
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;
#endif
return result;}
lightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 direction=lightData.xyz-vPositionW;vec3 lightVectorW=normalize(direction);float attenuation=max(0.,1.0-length(direction)/range);float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)
{cosAngle=max(0.,pow(cosAngle,lightData.w));attenuation*=cosAngle;float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;
#endif
return result;}
result.diffuse=vec3(0.);
#ifdef SPECULARTERM
result.specular=vec3(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;}
lightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {lightingInfo result;float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=mix(groundColor,diffuseColor,ndl);
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightData.xyz);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;
#endif
return result;}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return textureColor;}`; k.IncludesShadersStore[Xn] = zn; const Hn = "shadowsFragmentFunctions", Kn = `#ifdef SHADOWS
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}
#define inline
float computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);}
#define inline
float computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}
#define inline
float computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
#else
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define GREATEST_LESS_THAN_ONE 0.99999994
/* disable_uniformity_analysis */
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.)
);const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}
else
{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
if (numBlocker<1.0) {return 1.0;}
else
{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#endif
#endif
`; k.IncludesShadersStore[Hn] = Kn; const Yn = "samplerFragmentDeclaration", qn = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`; k.IncludesShadersStore[Yn] = qn; const jn = "fresnelFunction", Zn = `#ifdef FRESNEL
float computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)
{float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);return clamp(fresnelTerm,0.,1.);}
#endif
`; k.IncludesShadersStore[jn] = Zn; const $n = "reflectionFunction", Qn = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*(view*worldPos));}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*vec4(positionW,1.));}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`; k.IncludesShadersStore[$n] = Qn; const Jn = "imageProcessingDeclaration", ea = `#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`; k.IncludesShadersStore[Jn] = ea; const ta = "imageProcessingFunctions", ia = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;}
#endif
#ifdef TONEMAPPING_ACES
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);vec3 RRTAndODTFit(vec3 v)
{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}
vec3 ACESFitted(vec3 color)
{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
vec4 applyImageProcessing(vec4 result) {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#ifdef TONEMAPPING
#ifdef TONEMAPPING_ACES
result.rgb=ACESFitted(result.rgb);
#else
const float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
#endif
result.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return result;}`; k.IncludesShadersStore[ta] = ia; const sa = "bumpFragmentMainFunctions", ra = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#if defined(WEBGL2) || defined(WEBGPU)
mat4 toNormalMatrix(mat4 wMatrix)
{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}
#else
mat4 toNormalMatrix(mat4 m)
{float
a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],
a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],
a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],
a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],
b00=a00*a11-a01*a10,
b01=a00*a12-a02*a10,
b02=a00*a13-a03*a10,
b03=a01*a12-a02*a11,
b04=a01*a13-a03*a11,
b05=a02*a13-a03*a12,
b06=a20*a31-a21*a30,
b07=a20*a32-a22*a30,
b08=a20*a33-a23*a30,
b09=a21*a32-a22*a31,
b10=a21*a33-a23*a31,
b11=a22*a33-a23*a32,
det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(
a11*b11-a12*b10+a13*b09,
a02*b10-a01*b11-a03*b09,
a31*b05-a32*b04+a33*b03,
a22*b04-a21*b05-a23*b03,
a12*b08-a10*b11-a13*b07,
a00*b11-a02*b08+a03*b07,
a32*b02-a30*b05-a33*b01,
a20*b05-a22*b02+a23*b01,
a10*b10-a11*b08+a13*b06,
a01*b08-a00*b10-a03*b06,
a30*b04-a31*b02+a33*b00,
a21*b02-a20*b04-a23*b00,
a11*b07-a10*b09-a12*b06,
a00*b09-a01*b07+a02*b06,
a31*b01-a30*b03-a32*b00,
a20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],
mi[0][1],mi[1][1],mi[2][1],mi[3][1],
mi[0][2],mi[1][2],mi[2][2],mi[3][2],
mi[0][3],mi[1][3],mi[2][3],mi[3][3]);}
#endif
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}
#endif
`; k.IncludesShadersStore[sa] = ra; const na = "bumpFragmentFunctions", aa = `#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)
{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)
{}
else if (currSampledHeight>currRayHeight)
{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}
else
{currRayHeight-=stepSize;vLastOffset=vCurrOffset;
#ifdef PARALLAX_RHS
vCurrOffset-=stepSize*vMaxOffset;
#else
vCurrOffset+=stepSize*vMaxOffset;
#endif
lastSampledHeight=currSampledHeight;}}
return vCurrOffset;}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;
#ifdef PARALLAX_RHS
return texCoordOffset;
#else
return -texCoordOffset;
#endif
}
#endif
`; k.IncludesShadersStore[na] = aa; const oa = "clipPlaneFragmentDeclaration", la = `#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`; k.IncludesShadersStore[oa] = la; const ha = "logDepthDeclaration", ca = `#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;varying float vFragmentDepth;
#endif
`; k.IncludesShadersStore[ha] = ca; const ua = "fogFragmentDeclaration", fa = `#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()
{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)
{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}
else if (FOGMODE_EXP==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}
else if (FOGMODE_EXP2==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}
return clamp(fogCoeff,0.0,1.0);}
#endif
`; k.IncludesShadersStore[ua] = fa; const da = "clipPlaneFragment", _a = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{discard;}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{discard;}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{discard;}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{discard;}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{discard;}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{discard;}
#endif
`; k.IncludesShadersStore[da] = _a; const ga = "bumpFragment", ma = `vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
#define CUSTOM_FRAGMENT_BUMP_FRAGMENT
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`; k.IncludesShadersStore[ga] = ma; const pa = "decalFragment", va = `#ifdef DECAL
#ifdef GAMMADECAL
decalColor.rgb=toLinearSpace(decalColor.rgb);
#endif
#ifdef DECAL_SMOOTHALPHA
decalColor.a*=decalColor.a;
#endif
surfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);
#endif
`; k.IncludesShadersStore[pa] = va; const Ea = "depthPrePass", ba = `#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);return;
#endif
`; k.IncludesShadersStore[Ea] = ba; const Ta = "lightFragment", xa = `#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {index{X}=i;break;}}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{index{X}+=1;float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
aggShadow+=shadow;numLights+=1.0;
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`; k.IncludesShadersStore[Ta] = xa; const Aa = "logDepthFragment", Sa = `#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`; k.IncludesShadersStore[Aa] = Sa; const Ra = "fogFragment", ya = `#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`; k.IncludesShadersStore[Ra] = ya; const Ma = "oitFragment", Ca = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);return;}
#endif
`; k.IncludesShadersStore[Ma] = Ca; const Ia = "defaultPixelShader", Pa = `#include<__decl__defaultFragment>
#if defined(BUMP) || !defined(NORMAL)
#extension GL_OES_standard_derivatives : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
#include<oitDeclaration>
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef REFRACTION
#ifdef REFRACTIONMAP_3D
uniform samplerCube refractionCubeSampler;
#else
uniform sampler2D refraction2DSampler;
#endif
#endif
#if defined(SPECULARTERM)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)
#endif
#include<fresnelFunction>
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
uniform samplerCube reflectionCubeSampler;
#else
uniform sampler2D reflection2DSampler;
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#include<reflectionFunction>
#endif
#include<imageProcessingDeclaration>
#include<imageProcessingFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));
#endif
#include<bumpFragment>
#ifdef TWOSIDEDLIGHTING
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);
#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)
if (baseColor.a<alphaCutOff)
discard;
#endif
#ifdef ALPHAFROMDIFFUSE
alpha*=baseColor.a;
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
baseColor.rgb*=vDiffuseInfos.y;
#endif
#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)
#endif
#include<depthPrePass>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor.rgb*=vColor.rgb;
#endif
#ifdef DETAIL
baseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);
#endif
#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)
#endif
#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE
vec3 baseAmbientColor=vec3(1.,1.,1.);
#ifdef AMBIENT
baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;
#endif
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;
#ifdef SPECULAR
vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;
#ifdef GLOSSINESS
glossiness=glossiness*specularMapColor.a;
#endif
#endif
#else
float glossiness=0.;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
float shadow=1.;float aggShadow=0.;float numLights=0.;
#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
aggShadow=aggShadow/numLights;vec4 refractionColor=vec4(0.,0.,0.,1.);
#ifdef REFRACTION
vec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));
#ifdef REFRACTIONMAP_3D
#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;vec4 refractionLookup=textureCube(refractionCubeSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=texture2D(refraction2DSampler,refractionCoords);
#endif
#ifdef RGBDREFRACTION
refractionColor.rgb=fromRGBD(refractionColor);
#endif
#ifdef IS_REFRACTION_LINEAR
refractionColor.rgb=toGammaSpace(refractionColor.rgb);
#endif
refractionColor.rgb*=vRefractionInfos.x;
#endif
vec4 reflectionColor=vec4(0.,0.,0.,1.);
#ifdef REFLECTION
vec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
vReflectionUVW.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
#ifdef ROUGHNESS
float bias=vReflectionInfos.y;
#ifdef SPECULARTERM
#ifdef SPECULAR
#ifdef GLOSSINESS
bias*=(1.0-specularMapColor.a);
#endif
#endif
#endif
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);
#else
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);
#endif
#else
vec2 coords=vReflectionUVW.xy;
#ifdef REFLECTIONMAP_PROJECTION
coords/=vReflectionUVW.z;
#endif
coords.y=1.0-coords.y;reflectionColor=texture2D(reflection2DSampler,coords);
#endif
#ifdef RGBDREFLECTION
reflectionColor.rgb=fromRGBD(reflectionColor);
#endif
#ifdef IS_REFLECTION_LINEAR
reflectionColor.rgb=toGammaSpace(reflectionColor.rgb);
#endif
reflectionColor.rgb*=vReflectionInfos.x;
#ifdef REFLECTIONFRESNEL
float reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);
#ifdef REFLECTIONFRESNELFROMSPECULAR
#ifdef SPECULARTERM
reflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#endif
#endif
#ifdef REFRACTIONFRESNEL
float refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#ifdef OPACITYRGB
opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;
#else
alpha*=opacityMap.a*vOpacityInfos.y;
#endif
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef OPACITYFRESNEL
float opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;
#endif
#ifdef ALPHATEST
#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS
if (alpha<alphaCutOff)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
vec3 emissiveColor=vEmissiveColor;
#ifdef EMISSIVE
emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;
#endif
#ifdef EMISSIVEFRESNEL
float emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;
#endif
#ifdef DIFFUSEFRESNEL
float diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;
#endif
#ifdef EMISSIVEASILLUMINATION
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
#ifdef LINKEMISSIVEWITHDIFFUSE
vec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#endif
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#ifdef SPECULAROVERALPHA
alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#else
vec3 finalSpecular=vec3(0.0);
#endif
#ifdef REFLECTIONOVERALPHA
alpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#ifdef EMISSIVEASILLUMINATION
vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);
#else
vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);
#endif
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
color.rgb*=lightmapColor.rgb;
#else
color.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
#define CUSTOM_FRAGMENT_BEFORE_FOG
color.rgb=max(color.rgb,0.);
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
color.rgb=toLinearSpace(color.rgb);
#else
#ifdef IMAGEPROCESSING
color.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);
#endif
#endif
color.a*=visibility;
#ifdef PREMULTIPLYALPHA
color.rgb*=color.a;
#endif
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;gl_FragData[0]=color; 
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_IRRADIANCE
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); 
#else
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); 
#endif
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#if defined(SPECULARTERM)
#if defined(SPECULAR)
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; 
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;
#endif
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=color;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {frontColor.rgb+=color.rgb*color.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-color.a);} else {backColor+=color;}
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}
`; k.ShadersStore[Ia] = Pa; const Da = "decalVertexDeclaration", Fa = `#ifdef DECAL
uniform vec4 vDecalInfos;uniform mat4 decalMatrix;
#endif
`; k.IncludesShadersStore[Da] = Fa; const wa = "defaultVertexDeclaration", Oa = `uniform mat4 viewProjection;uniform mat4 view;
#ifdef DIFFUSE
uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;uniform mat4 specularMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform mat4 bumpMatrix;
#endif
#ifdef REFLECTION
uniform mat4 reflectionMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;uniform mat4 detailMatrix;
#endif
#include<decalVertexDeclaration>
#define ADDITIONAL_VERTEX_DECLARATION
`; k.IncludesShadersStore[wa] = Oa; const La = "uvAttributeDeclaration", Na = `#ifdef UV{X}
attribute vec2 uv{X};
#endif
`; k.IncludesShadersStore[La] = Na; const Ba = "bonesDeclaration", Ua = `#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform highp sampler2D boneSampler;uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#endif
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}
#endif
#endif
#endif
`; k.IncludesShadersStore[Ba] = Ua; const ka = "bakedVertexAnimationDeclaration", Va = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}
#endif
`; k.IncludesShadersStore[ka] = Va; const Wa = "instancesDeclaration", Ga = `#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`; k.IncludesShadersStore[Wa] = Ga; const Xa = "prePassVertexDeclaration", za = `#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;
#endif
#endif
`; k.IncludesShadersStore[Xa] = za; const Ha = "samplerVertexDeclaration", Ka = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`; k.IncludesShadersStore[Ha] = Ka; const Ya = "bumpVertexDeclaration", qa = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`; k.IncludesShadersStore[Ya] = qa; const ja = "clipPlaneVertexDeclaration", Za = `#ifdef CLIPPLANE
uniform vec4 vClipPlane;varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;varying float fClipDistance6;
#endif
`; k.IncludesShadersStore[ja] = Za; const $a = "fogVertexDeclaration", Qa = `#ifdef FOG
varying vec3 vFogDistance;
#endif
`; k.IncludesShadersStore[$a] = Qa; const Ja = "lightVxFragmentDeclaration", eo = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`; k.IncludesShadersStore[Ja] = eo; const to = "lightVxUboDeclaration", io = `#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`; k.IncludesShadersStore[to] = io; const so = "morphTargetsVertexGlobalDeclaration", ro = `#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}
#endif
#endif
`; k.IncludesShadersStore[so] = ro; const no = "morphTargetsVertexDeclaration", ao = `#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#endif
#endif
`; k.IncludesShadersStore[no] = ao; const oo = "morphTargetsVertexGlobal", lo = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`; k.IncludesShadersStore[oo] = lo; const ho = "morphTargetsVertex", co = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE 
vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`; k.IncludesShadersStore[ho] = co; const uo = "instancesVertex", fo = `#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`; k.IncludesShadersStore[uo] = fo; const _o = "bonesVertex", go = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`; k.IncludesShadersStore[_o] = go; const mo = "bakedVertexAnimation", po = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;}
#endif
`; k.IncludesShadersStore[mo] = po; const vo = "prePassVertex", Eo = `#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`; k.IncludesShadersStore[vo] = Eo; const bo = "uvVariableDeclaration", To = `#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`; k.IncludesShadersStore[bo] = To; const xo = "samplerVertexImplementation", Ao = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}
#ifdef UV2
else if (v_INFONAME_==1.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}
#endif
#endif
`; k.IncludesShadersStore[xo] = Ao; const So = "bumpVertex", Ro = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`; k.IncludesShadersStore[So] = Ro; const yo = "clipPlaneVertex", Mo = `#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`; k.IncludesShadersStore[yo] = Mo; const Co = "fogVertex", Io = `#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`; k.IncludesShadersStore[Co] = Io; const Po = "shadowsVertex", Do = `#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`; k.IncludesShadersStore[Po] = Do; const Fo = "vertexColorMixing", wo = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`; k.IncludesShadersStore[Fo] = wo; const Oo = "pointCloudVertex", Lo = `#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
`; k.IncludesShadersStore[Oo] = Lo; const No = "logDepthVertex", Bo = `#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`; k.IncludesShadersStore[No] = Bo; const Uo = "defaultVertexShader", ko = `#include<__decl__defaultVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<mainUVVaryingDeclaration>[1..7]
#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#if defined(SPECULARTERM)
#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)
#endif
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
vPositionW=vec3(worldPos);
#include<prePassVertex>
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#if defined(SPECULARTERM)
#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)
#endif
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#include<pointCloudVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`; k.ShadersStore[Uo] = ko; class Vo { constructor() { this._defines = {}, this._currentRank = 32, this._maxRank = -1, this._mesh = null } unBindMesh() { this._mesh = null } addFallback(e, t) { this._defines[e] || (e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e), this._defines[e] = new Array), this._defines[e].push(t) } addCPUSkinningFallback(e, t) { this._mesh = t, e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e) } get hasMoreFallbacks() { return this._currentRank <= this._maxRank } reduce(e, t) { if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) { this._mesh.computeBonesUsingShaders = !1, e = e.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0"), t._bonesComputationForcedToCPU = !0; const i = this._mesh.getScene(); for (let s = 0; s < i.meshes.length; s++) { const r = i.meshes[s]; if (!r.material) { !this._mesh.material && r.computeBonesUsingShaders && r.numBoneInfluencers > 0 && (r.computeBonesUsingShaders = !1); continue } if (!(!r.computeBonesUsingShaders || r.numBoneInfluencers === 0)) { if (r.material.getEffect() === t) r.computeBonesUsingShaders = !1; else if (r.subMeshes) { for (const n of r.subMeshes) if (n.effect === t) { r.computeBonesUsingShaders = !1; break } } } } } else { const i = this._defines[this._currentRank]; if (i) for (let s = 0; s < i.length; s++)e = e.replace("#define " + i[s], ""); this._currentRank++ } return e } } const Wo = new RegExp("^([gimus]+)!"); class Mt {
        constructor(e) { this._plugins = [], this._activePlugins = [], this._activePluginsForExtraEvents = [], this._material = e, this._scene = e.getScene(), this._engine = this._scene.getEngine() } _addPlugin(e) { for (let s = 0; s < this._plugins.length; ++s)if (this._plugins[s].name === e.name) return !1; if (this._material._uniformBufferLayoutBuilt) throw `The plugin "${e.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`; const t = e.getClassName(); Mt._MaterialPluginClassToMainDefine[t] || (Mt._MaterialPluginClassToMainDefine[t] = "MATERIALPLUGIN_" + ++Mt._MaterialPluginCounter), this._material._callbackPluginEventGeneric = (s, r) => this._handlePluginEvent(s, r), this._plugins.push(e), this._plugins.sort((s, r) => s.priority - r.priority), this._codeInjectionPoints = {}; const i = {}; i[Mt._MaterialPluginClassToMainDefine[t]] = { type: "boolean", default: !0 }; for (const s of this._plugins) s.collectDefines(i), this._collectPointNames("vertex", s.getCustomCode("vertex")), this._collectPointNames("fragment", s.getCustomCode("fragment")); return this._defineNamesFromPlugins = i, !0 } _activatePlugin(e) { this._activePlugins.indexOf(e) === -1 && (this._activePlugins.push(e), this._activePlugins.sort((t, i) => t.priority - i.priority), this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this), this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this), this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this), this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this), e.registerForExtraEvents && (this._activePluginsForExtraEvents.push(e), this._activePluginsForExtraEvents.sort((t, i) => t.priority - i.priority), this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this), this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this), this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this))) } getPlugin(e) { for (let t = 0; t < this._plugins.length; ++t)if (this._plugins[t].name === e) return this._plugins[t]; return null } _handlePluginEventIsReadyForSubMesh(e) { let t = !0; for (const i of this._activePlugins) t = t && i.isReadyForSubMesh(e.defines, this._scene, this._engine, e.subMesh); e.isReadyForSubMesh = t } _handlePluginEventPrepareDefinesBeforeAttributes(e) { for (const t of this._activePlugins) t.prepareDefinesBeforeAttributes(e.defines, this._scene, e.mesh) } _handlePluginEventPrepareDefines(e) { for (const t of this._activePlugins) t.prepareDefines(e.defines, this._scene, e.mesh) } _handlePluginEventHardBindForSubMesh(e) { for (const t of this._activePluginsForExtraEvents) t.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh) } _handlePluginEventBindForSubMesh(e) { for (const t of this._activePlugins) t.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh) } _handlePluginEventHasRenderTargetTextures(e) { let t = !1; for (const i of this._activePluginsForExtraEvents) if (t = i.hasRenderTargetTextures(), t) break; e.hasRenderTargetTextures = t } _handlePluginEventFillRenderTargetTextures(e) { for (const t of this._activePluginsForExtraEvents) t.fillRenderTargetTextures(e.renderTargets) } _handlePluginEvent(e, t) {
            var i; switch (e) {
                case Ue.GetActiveTextures: { const s = t; for (const r of this._activePlugins) r.getActiveTextures(s.activeTextures); break } case Ue.GetAnimatables: { const s = t; for (const r of this._activePlugins) r.getAnimatables(s.animatables); break } case Ue.HasTexture: { const s = t; let r = !1; for (const n of this._activePlugins) if (r = n.hasTexture(s.texture), r) break; s.hasTexture = r; break } case Ue.Disposed: { const s = t; for (const r of this._plugins) r.dispose(s.forceDisposeTextures); break } case Ue.GetDefineNames: { const s = t; s.defineNames = this._defineNamesFromPlugins; break } case Ue.PrepareEffect: { const s = t; for (const r of this._activePlugins) s.fallbackRank = r.addFallbacks(s.defines, s.fallbacks, s.fallbackRank), r.getAttributes(s.attributes, this._scene, s.mesh); this._uniformList.length > 0 && s.uniforms.push(...this._uniformList), this._samplerList.length > 0 && s.samplers.push(...this._samplerList), this._uboList.length > 0 && s.uniformBuffersNames.push(...this._uboList), s.customCode = this._injectCustomCode(s, s.customCode); break } case Ue.PrepareUniformBuffer: {
                    const s = t; this._uboDeclaration = "", this._vertexDeclaration = "", this._fragmentDeclaration = "", this._uniformList = [], this._samplerList = [], this._uboList = []; for (const r of this._plugins) {
                        const n = r.getUniforms(); if (n) {
                            if (n.ubo) for (const a of n.ubo) {
                                if (a.size && a.type) {
                                    const o = (i = a.arraySize) !== null && i !== void 0 ? i : 0; s.ubo.addUniform(a.name, a.size, o), this._uboDeclaration += `${a.type} ${a.name}${o > 0 ? `[${o}]` : ""};
`} this._uniformList.push(a.name)
                            } n.vertex && (this._vertexDeclaration += n.vertex + `
`), n.fragment && (this._fragmentDeclaration += n.fragment + `
`)
                        } r.getSamplers(this._samplerList), r.getUniformBuffersNames(this._uboList)
                    } break
                }
            }
        } _collectPointNames(e, t) { if (t) for (const i in t) this._codeInjectionPoints[e] || (this._codeInjectionPoints[e] = {}), this._codeInjectionPoints[e][i] = !0 } _injectCustomCode(e, t) {
            return (i, s) => {
                var r, n; t && (s = t(i, s)), this._uboDeclaration && (s = s.replace("#define ADDITIONAL_UBO_DECLARATION", this._uboDeclaration)), this._vertexDeclaration && (s = s.replace("#define ADDITIONAL_VERTEX_DECLARATION", this._vertexDeclaration)), this._fragmentDeclaration && (s = s.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", this._fragmentDeclaration)); const a = (r = this._codeInjectionPoints) === null || r === void 0 ? void 0 : r[i]; if (!a) return s; let o = null; for (let l in a) {
                    let h = ""; for (const u of this._activePlugins) {
                        let f = (n = u.getCustomCode(i)) === null || n === void 0 ? void 0 : n[l]; if (f) {
                            if (u.resolveIncludes) { if (o === null) { const _ = we.GLSL; o = { defines: [], indexParameters: e.indexParameters, isFragment: !1, shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader, processor: void 0, supportsUniformBuffers: this._engine.supportsUniformBuffers, shadersRepository: k.GetShadersRepository(_), includesShadersStore: k.GetIncludesShadersStore(_), version: void 0, platformName: this._engine.shaderPlatformName, processingContext: void 0, isNDCHalfZRange: this._engine.isNDCHalfZRange, useReverseDepthBuffer: this._engine.useReverseDepthBuffer, processCodeAfterIncludes: void 0 } } o.isFragment = i === "fragment", ht._ProcessIncludes(f, o, _ => f = _) } h += f + `
`}
                    } if (h.length > 0) if (l.charAt(0) === "!") { l = l.substring(1); let u = "g"; if (l.charAt(0) === "!") u = "", l = l.substring(1); else { const v = Wo.exec(l); v && v.length >= 2 && (u = v[1], l = l.substring(u.length + 1)) } u.indexOf("g") < 0 && (u += "g"); const f = s, _ = new RegExp(l, u); let p = _.exec(f); for (; p !== null;) { let v = h; for (let E = 0; E < p.length; ++E)v = v.replace("$" + E, p[E]); s = s.replace(p[0], v), p = _.exec(f) } } else {
                        const u = "#define " + l; s = s.replace(u, `
`+ h + `
`+ u)
                    }
                } return s
            }
        }
    } Mt._MaterialPluginClassToMainDefine = {}, Mt._MaterialPluginCounter = 0, ce.OnEnginesDisposedObservable.add(() => { Xo() }); const Go = []; let qs = null; function Xo() { Go.length = 0, I.OnEventObservable.remove(qs), qs = null } class oi { _enable(e) { e && this._pluginManager._activatePlugin(this) } constructor(e, t, i, s, r = !0, n = !1, a = !1) { this.priority = 500, this.resolveIncludes = !1, this.registerForExtraEvents = !1, this._material = e, this.name = t, this.priority = i, this.resolveIncludes = a, e.pluginManager || (e.pluginManager = new Mt(e), e.onDisposeObservable.add(() => { e.pluginManager = void 0 })), this._pluginDefineNames = s, this._pluginManager = e.pluginManager, r && this._pluginManager._addPlugin(this), n && this._enable(!0), this.markAllDefinesAsDirty = e._dirtyCallbacks[63] } getClassName() { return "MaterialPluginBase" } isReadyForSubMesh(e, t, i, s) { return !0 } hardBindForSubMesh(e, t, i, s) { } bindForSubMesh(e, t, i, s) { } dispose(e) { } getCustomCode(e) { return null } collectDefines(e) { if (this._pluginDefineNames) for (const t of Object.keys(this._pluginDefineNames)) { if (t[0] === "_") continue; const i = typeof this._pluginDefineNames[t]; e[t] = { type: i === "number" ? "number" : i === "string" ? "string" : i === "boolean" ? "boolean" : "object", default: this._pluginDefineNames[t] } } } prepareDefinesBeforeAttributes(e, t, i) { } prepareDefines(e, t, i) { } hasTexture(e) { return !1 } hasRenderTargetTextures() { return !1 } fillRenderTargetTextures(e) { } getActiveTextures(e) { } getAnimatables(e) { } addFallbacks(e, t, i) { return i } getSamplers(e) { } getAttributes(e, t, i) { } getUniformBuffersNames(e) { } getUniforms() { return {} } copyTo(e) { re.Clone(() => e, this) } serialize() { return re.Serialize(this) } parse(e, t, i) { re.Parse(() => this, e, t, i) } } T([M()], oi.prototype, "name", void 0), T([M()], oi.prototype, "priority", void 0), T([M()], oi.prototype, "resolveIncludes", void 0), T([M()], oi.prototype, "registerForExtraEvents", void 0); class zo extends Cs { constructor() { super(...arguments), this.DETAIL = !1, this.DETAILDIRECTUV = 0, this.DETAIL_NORMALBLENDMETHOD = 0 } } class Bt extends oi { _markAllSubMeshesAsTexturesDirty() { this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsTexturesDirty() } constructor(e, t = !0) { super(e, "DetailMap", 140, new zo, t), this._texture = null, this.diffuseBlendLevel = 1, this.roughnessBlendLevel = 1, this.bumpLevel = 1, this._normalBlendMethod = I.MATERIAL_NORMALBLENDMETHOD_WHITEOUT, this._isEnabled = !1, this.isEnabled = !1, this._internalMarkAllSubMeshesAsTexturesDirty = e._dirtyCallbacks[1] } isReadyForSubMesh(e, t, i) { return this._isEnabled ? !(e._areTexturesDirty && t.texturesEnabled && i.getCaps().standardDerivatives && this._texture && se.DetailTextureEnabled && !this._texture.isReady()) : !0 } prepareDefines(e, t) { if (this._isEnabled) { e.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod; const i = t.getEngine(); e._areTexturesDirty && (i.getCaps().standardDerivatives && this._texture && se.DetailTextureEnabled && this._isEnabled ? (le.PrepareDefinesForMergedUV(this._texture, e, "DETAIL"), e.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod) : e.DETAIL = !1) } else e.DETAIL = !1 } bindForSubMesh(e, t) { if (!this._isEnabled) return; const i = this._material.isFrozen; (!e.useUbo || !i || !e.isSync) && this._texture && se.DetailTextureEnabled && (e.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel), le.BindTextureMatrix(this._texture, e, "detail")), t.texturesEnabled && this._texture && se.DetailTextureEnabled && e.setTexture("detailSampler", this._texture) } hasTexture(e) { return this._texture === e } getActiveTextures(e) { this._texture && e.push(this._texture) } getAnimatables(e) { this._texture && this._texture.animations && this._texture.animations.length > 0 && e.push(this._texture) } dispose(e) { var t; e && ((t = this._texture) === null || t === void 0 || t.dispose()) } getClassName() { return "DetailMapConfiguration" } getSamplers(e) { e.push("detailSampler") } getUniforms() { return { ubo: [{ name: "vDetailInfos", size: 4, type: "vec4" }, { name: "detailMatrix", size: 16, type: "mat4" }] } } } T([st("detailTexture"), ue("_markAllSubMeshesAsTexturesDirty")], Bt.prototype, "texture", void 0), T([M()], Bt.prototype, "diffuseBlendLevel", void 0), T([M()], Bt.prototype, "roughnessBlendLevel", void 0), T([M()], Bt.prototype, "bumpLevel", void 0), T([M(), ue("_markAllSubMeshesAsTexturesDirty")], Bt.prototype, "normalBlendMethod", void 0), T([M(), ue("_markAllSubMeshesAsTexturesDirty")], Bt.prototype, "isEnabled", void 0); const $i = { effect: null, subMesh: null }; class Ho extends Cs { constructor(e) { super(e), this.MAINUV1 = !1, this.MAINUV2 = !1, this.MAINUV3 = !1, this.MAINUV4 = !1, this.MAINUV5 = !1, this.MAINUV6 = !1, this.DIFFUSE = !1, this.DIFFUSEDIRECTUV = 0, this.BAKED_VERTEX_ANIMATION_TEXTURE = !1, this.AMBIENT = !1, this.AMBIENTDIRECTUV = 0, this.OPACITY = !1, this.OPACITYDIRECTUV = 0, this.OPACITYRGB = !1, this.REFLECTION = !1, this.EMISSIVE = !1, this.EMISSIVEDIRECTUV = 0, this.SPECULAR = !1, this.SPECULARDIRECTUV = 0, this.BUMP = !1, this.BUMPDIRECTUV = 0, this.PARALLAX = !1, this.PARALLAX_RHS = !1, this.PARALLAXOCCLUSION = !1, this.SPECULAROVERALPHA = !1, this.CLIPPLANE = !1, this.CLIPPLANE2 = !1, this.CLIPPLANE3 = !1, this.CLIPPLANE4 = !1, this.CLIPPLANE5 = !1, this.CLIPPLANE6 = !1, this.ALPHATEST = !1, this.DEPTHPREPASS = !1, this.ALPHAFROMDIFFUSE = !1, this.POINTSIZE = !1, this.FOG = !1, this.SPECULARTERM = !1, this.DIFFUSEFRESNEL = !1, this.OPACITYFRESNEL = !1, this.REFLECTIONFRESNEL = !1, this.REFRACTIONFRESNEL = !1, this.EMISSIVEFRESNEL = !1, this.FRESNEL = !1, this.NORMAL = !1, this.TANGENT = !1, this.UV1 = !1, this.UV2 = !1, this.UV3 = !1, this.UV4 = !1, this.UV5 = !1, this.UV6 = !1, this.VERTEXCOLOR = !1, this.VERTEXALPHA = !1, this.NUM_BONE_INFLUENCERS = 0, this.BonesPerMesh = 0, this.BONETEXTURE = !1, this.BONES_VELOCITY_ENABLED = !1, this.INSTANCES = !1, this.THIN_INSTANCES = !1, this.INSTANCESCOLOR = !1, this.GLOSSINESS = !1, this.ROUGHNESS = !1, this.EMISSIVEASILLUMINATION = !1, this.LINKEMISSIVEWITHDIFFUSE = !1, this.REFLECTIONFRESNELFROMSPECULAR = !1, this.LIGHTMAP = !1, this.LIGHTMAPDIRECTUV = 0, this.OBJECTSPACE_NORMALMAP = !1, this.USELIGHTMAPASSHADOWMAP = !1, this.REFLECTIONMAP_3D = !1, this.REFLECTIONMAP_SPHERICAL = !1, this.REFLECTIONMAP_PLANAR = !1, this.REFLECTIONMAP_CUBIC = !1, this.USE_LOCAL_REFLECTIONMAP_CUBIC = !1, this.USE_LOCAL_REFRACTIONMAP_CUBIC = !1, this.REFLECTIONMAP_PROJECTION = !1, this.REFLECTIONMAP_SKYBOX = !1, this.REFLECTIONMAP_EXPLICIT = !1, this.REFLECTIONMAP_EQUIRECTANGULAR = !1, this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, this.REFLECTIONMAP_OPPOSITEZ = !1, this.INVERTCUBICMAP = !1, this.LOGARITHMICDEPTH = !1, this.REFRACTION = !1, this.REFRACTIONMAP_3D = !1, this.REFLECTIONOVERALPHA = !1, this.TWOSIDEDLIGHTING = !1, this.SHADOWFLOAT = !1, this.MORPHTARGETS = !1, this.MORPHTARGETS_NORMAL = !1, this.MORPHTARGETS_TANGENT = !1, this.MORPHTARGETS_UV = !1, this.NUM_MORPH_INFLUENCERS = 0, this.MORPHTARGETS_TEXTURE = !1, this.NONUNIFORMSCALING = !1, this.PREMULTIPLYALPHA = !1, this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = !1, this.ALPHABLEND = !0, this.PREPASS = !1, this.PREPASS_IRRADIANCE = !1, this.PREPASS_IRRADIANCE_INDEX = -1, this.PREPASS_ALBEDO_SQRT = !1, this.PREPASS_ALBEDO_SQRT_INDEX = -1, this.PREPASS_DEPTH = !1, this.PREPASS_DEPTH_INDEX = -1, this.PREPASS_NORMAL = !1, this.PREPASS_NORMAL_INDEX = -1, this.PREPASS_NORMAL_WORLDSPACE = !1, this.PREPASS_POSITION = !1, this.PREPASS_POSITION_INDEX = -1, this.PREPASS_VELOCITY = !1, this.PREPASS_VELOCITY_INDEX = -1, this.PREPASS_REFLECTIVITY = !1, this.PREPASS_REFLECTIVITY_INDEX = -1, this.SCENE_MRT_COUNT = 0, this.RGBDLIGHTMAP = !1, this.RGBDREFLECTION = !1, this.RGBDREFRACTION = !1, this.IMAGEPROCESSING = !1, this.VIGNETTE = !1, this.VIGNETTEBLENDMODEMULTIPLY = !1, this.VIGNETTEBLENDMODEOPAQUE = !1, this.TONEMAPPING = !1, this.TONEMAPPING_ACES = !1, this.CONTRAST = !1, this.COLORCURVES = !1, this.COLORGRADING = !1, this.COLORGRADING3D = !1, this.SAMPLER3DGREENDEPTH = !1, this.SAMPLER3DBGRMAP = !1, this.DITHER = !1, this.IMAGEPROCESSINGPOSTPROCESS = !1, this.SKIPFINALCOLORCLAMP = !1, this.MULTIVIEW = !1, this.ORDER_INDEPENDENT_TRANSPARENCY = !1, this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !1, this.CAMERA_ORTHOGRAPHIC = !1, this.CAMERA_PERSPECTIVE = !1, this.IS_REFLECTION_LINEAR = !1, this.IS_REFRACTION_LINEAR = !1, this.EXPOSURE = !1, this.DECAL_AFTER_DETAIL = !1, this.rebuild() } setReflectionMode(e) { const t = ["REFLECTIONMAP_CUBIC", "REFLECTIONMAP_EXPLICIT", "REFLECTIONMAP_PLANAR", "REFLECTIONMAP_PROJECTION", "REFLECTIONMAP_PROJECTION", "REFLECTIONMAP_SKYBOX", "REFLECTIONMAP_SPHERICAL", "REFLECTIONMAP_EQUIRECTANGULAR", "REFLECTIONMAP_EQUIRECTANGULAR_FIXED", "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"]; for (const i of t) this[i] = i === e } } class F extends vn { get imageProcessingConfiguration() { return this._imageProcessingConfiguration } set imageProcessingConfiguration(e) { this._attachImageProcessingConfiguration(e), this._markAllSubMeshesAsTexturesDirty() } _attachImageProcessingConfiguration(e) { e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), e ? this._imageProcessingConfiguration = e : this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration, this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => { this._markAllSubMeshesAsImageProcessingDirty() }))) } get isPrePassCapable() { return !this.disableDepthWrite } get cameraColorCurvesEnabled() { return this.imageProcessingConfiguration.colorCurvesEnabled } set cameraColorCurvesEnabled(e) { this.imageProcessingConfiguration.colorCurvesEnabled = e } get cameraColorGradingEnabled() { return this.imageProcessingConfiguration.colorGradingEnabled } set cameraColorGradingEnabled(e) { this.imageProcessingConfiguration.colorGradingEnabled = e } get cameraToneMappingEnabled() { return this._imageProcessingConfiguration.toneMappingEnabled } set cameraToneMappingEnabled(e) { this._imageProcessingConfiguration.toneMappingEnabled = e } get cameraExposure() { return this._imageProcessingConfiguration.exposure } set cameraExposure(e) { this._imageProcessingConfiguration.exposure = e } get cameraContrast() { return this._imageProcessingConfiguration.contrast } set cameraContrast(e) { this._imageProcessingConfiguration.contrast = e } get cameraColorGradingTexture() { return this._imageProcessingConfiguration.colorGradingTexture } set cameraColorGradingTexture(e) { this._imageProcessingConfiguration.colorGradingTexture = e } get cameraColorCurves() { return this._imageProcessingConfiguration.colorCurves } set cameraColorCurves(e) { this._imageProcessingConfiguration.colorCurves = e } get canRenderToMRT() { return !0 } constructor(e, t) { super(e, t), this._diffuseTexture = null, this._ambientTexture = null, this._opacityTexture = null, this._reflectionTexture = null, this._emissiveTexture = null, this._specularTexture = null, this._bumpTexture = null, this._lightmapTexture = null, this._refractionTexture = null, this.ambientColor = new te(0, 0, 0), this.diffuseColor = new te(1, 1, 1), this.specularColor = new te(1, 1, 1), this.emissiveColor = new te(0, 0, 0), this.specularPower = 64, this._useAlphaFromDiffuseTexture = !1, this._useEmissiveAsIllumination = !1, this._linkEmissiveWithDiffuse = !1, this._useSpecularOverAlpha = !1, this._useReflectionOverAlpha = !1, this._disableLighting = !1, this._useObjectSpaceNormalMap = !1, this._useParallax = !1, this._useParallaxOcclusion = !1, this.parallaxScaleBias = .05, this._roughness = 0, this.indexOfRefraction = .98, this.invertRefractionY = !0, this.alphaCutOff = .4, this._useLightmapAsShadowmap = !1, this._useReflectionFresnelFromSpecular = !1, this._useGlossinessFromSpecularMapAlpha = !1, this._maxSimultaneousLights = 4, this._invertNormalMapX = !1, this._invertNormalMapY = !1, this._twoSidedLighting = !1, this._applyDecalMapAfterDetailMap = !1, this._renderTargets = new He(16), this._worldViewProjectionMatrix = A.Zero(), this._globalAmbientColor = new te(0, 0, 0), this._cacheHasRenderTargetTextures = !1, this.detailMap = new Bt(this), this._attachImageProcessingConfiguration(null), this.prePassConfiguration = new Ks, this.getRenderTargetTextures = () => (this._renderTargets.reset(), F.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget && this._renderTargets.push(this._reflectionTexture), F.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget && this._renderTargets.push(this._refractionTexture), this._eventInfo.renderTargets = this._renderTargets, this._callbackPluginEventFillRenderTargetTextures(this._eventInfo), this._renderTargets) } get hasRenderTargetTextures() { return F.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget || F.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget ? !0 : this._cacheHasRenderTargetTextures } getClassName() { return "StandardMaterial" } needAlphaBlending() { return this._disableAlphaBlending ? !1 : this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled } needAlphaTesting() { return this._forceAlphaTest ? !0 : this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === I.MATERIAL_ALPHATEST) } _shouldUseAlphaFromDiffuseTexture() { return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== I.MATERIAL_OPAQUE } _hasAlphaChannel() { return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null } getAlphaTestTexture() { return this._diffuseTexture } isReadyForSubMesh(e, t, i = !1) { if (this._uniformBufferLayoutBuilt || this.buildUniformLayout(), t.effect && this.isFrozen && t.effect._wasPreviouslyReady && t.effect._wasPreviouslyUsingInstances === i) return !0; t.materialDefines || (this._callbackPluginEventGeneric(Ue.GetDefineNames, this._eventInfo), t.materialDefines = new Ho(this._eventInfo.defineNames)); const s = this.getScene(), r = t.materialDefines; if (this._isReadyForSubMesh(t)) return !0; const n = s.getEngine(); r._needNormals = le.PrepareDefinesForLights(s, e, r, !0, this._maxSimultaneousLights, this._disableLighting), le.PrepareDefinesForMultiview(s, r); const a = this.needAlphaBlendingForMesh(e) && this.getScene().useOrderIndependentTransparency; if (le.PrepareDefinesForPrePass(s, r, this.canRenderToMRT && !a), le.PrepareDefinesForOIT(s, r, a), r._areTexturesDirty) { this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures, r._needUVs = !1; for (let l = 1; l <= 6; ++l)r["MAINUV" + l] = !1; if (s.texturesEnabled) { if (r.DIFFUSEDIRECTUV = 0, r.BUMPDIRECTUV = 0, r.AMBIENTDIRECTUV = 0, r.OPACITYDIRECTUV = 0, r.EMISSIVEDIRECTUV = 0, r.SPECULARDIRECTUV = 0, r.LIGHTMAPDIRECTUV = 0, this._diffuseTexture && F.DiffuseTextureEnabled) if (this._diffuseTexture.isReadyOrNotBlocking()) le.PrepareDefinesForMergedUV(this._diffuseTexture, r, "DIFFUSE"); else return !1; else r.DIFFUSE = !1; if (this._ambientTexture && F.AmbientTextureEnabled) if (this._ambientTexture.isReadyOrNotBlocking()) le.PrepareDefinesForMergedUV(this._ambientTexture, r, "AMBIENT"); else return !1; else r.AMBIENT = !1; if (this._opacityTexture && F.OpacityTextureEnabled) if (this._opacityTexture.isReadyOrNotBlocking()) le.PrepareDefinesForMergedUV(this._opacityTexture, r, "OPACITY"), r.OPACITYRGB = this._opacityTexture.getAlphaFromRGB; else return !1; else r.OPACITY = !1; if (this._reflectionTexture && F.ReflectionTextureEnabled) if (this._reflectionTexture.isReadyOrNotBlocking()) { switch (r._needNormals = !0, r.REFLECTION = !0, r.ROUGHNESS = this._roughness > 0, r.REFLECTIONOVERALPHA = this._useReflectionOverAlpha, r.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === V.INVCUBIC_MODE, r.REFLECTIONMAP_3D = this._reflectionTexture.isCube, r.REFLECTIONMAP_OPPOSITEZ = r.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ, r.RGBDREFLECTION = this._reflectionTexture.isRGBD, this._reflectionTexture.coordinatesMode) { case V.EXPLICIT_MODE: r.setReflectionMode("REFLECTIONMAP_EXPLICIT"); break; case V.PLANAR_MODE: r.setReflectionMode("REFLECTIONMAP_PLANAR"); break; case V.PROJECTION_MODE: r.setReflectionMode("REFLECTIONMAP_PROJECTION"); break; case V.SKYBOX_MODE: r.setReflectionMode("REFLECTIONMAP_SKYBOX"); break; case V.SPHERICAL_MODE: r.setReflectionMode("REFLECTIONMAP_SPHERICAL"); break; case V.EQUIRECTANGULAR_MODE: r.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR"); break; case V.FIXED_EQUIRECTANGULAR_MODE: r.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED"); break; case V.FIXED_EQUIRECTANGULAR_MIRRORED_MODE: r.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"); break; case V.CUBIC_MODE: case V.INVCUBIC_MODE: default: r.setReflectionMode("REFLECTIONMAP_CUBIC"); break }r.USE_LOCAL_REFLECTIONMAP_CUBIC = !!this._reflectionTexture.boundingBoxSize } else return !1; else r.REFLECTION = !1, r.REFLECTIONMAP_OPPOSITEZ = !1; if (this._emissiveTexture && F.EmissiveTextureEnabled) if (this._emissiveTexture.isReadyOrNotBlocking()) le.PrepareDefinesForMergedUV(this._emissiveTexture, r, "EMISSIVE"); else return !1; else r.EMISSIVE = !1; if (this._lightmapTexture && F.LightmapTextureEnabled) if (this._lightmapTexture.isReadyOrNotBlocking()) le.PrepareDefinesForMergedUV(this._lightmapTexture, r, "LIGHTMAP"), r.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap, r.RGBDLIGHTMAP = this._lightmapTexture.isRGBD; else return !1; else r.LIGHTMAP = !1; if (this._specularTexture && F.SpecularTextureEnabled) if (this._specularTexture.isReadyOrNotBlocking()) le.PrepareDefinesForMergedUV(this._specularTexture, r, "SPECULAR"), r.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha; else return !1; else r.SPECULAR = !1; if (s.getEngine().getCaps().standardDerivatives && this._bumpTexture && F.BumpTextureEnabled) { if (this._bumpTexture.isReady()) le.PrepareDefinesForMergedUV(this._bumpTexture, r, "BUMP"), r.PARALLAX = this._useParallax, r.PARALLAX_RHS = s.useRightHandedSystem, r.PARALLAXOCCLUSION = this._useParallaxOcclusion; else return !1; r.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap } else r.BUMP = !1, r.PARALLAX = !1, r.PARALLAX_RHS = !1, r.PARALLAXOCCLUSION = !1; if (this._refractionTexture && F.RefractionTextureEnabled) if (this._refractionTexture.isReadyOrNotBlocking()) r._needUVs = !0, r.REFRACTION = !0, r.REFRACTIONMAP_3D = this._refractionTexture.isCube, r.RGBDREFRACTION = this._refractionTexture.isRGBD, r.USE_LOCAL_REFRACTIONMAP_CUBIC = !!this._refractionTexture.boundingBoxSize; else return !1; else r.REFRACTION = !1; r.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting } else r.DIFFUSE = !1, r.AMBIENT = !1, r.OPACITY = !1, r.REFLECTION = !1, r.EMISSIVE = !1, r.LIGHTMAP = !1, r.BUMP = !1, r.REFRACTION = !1; r.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture(), r.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination, r.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse, r.SPECULAROVERALPHA = this._useSpecularOverAlpha, r.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8, r.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null, r.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(e) } if (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = r, this._eventInfo.subMesh = t, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), !this._eventInfo.isReadyForSubMesh) return !1; if (r._areImageProcessingDirty && this._imageProcessingConfiguration) { if (!this._imageProcessingConfiguration.isReady()) return !1; this._imageProcessingConfiguration.prepareDefines(r), r.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace, r.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace } r._areFresnelDirty && (F.FresnelEnabled ? (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) && (r.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled, r.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled, r.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled, r.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular, r.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled, r.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled, r._needNormals = !0, r.FRESNEL = !0) : r.FRESNEL = !1), le.PrepareDefinesForMisc(e, s, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(e) || this._forceAlphaTest, r, this._applyDecalMapAfterDetailMap), le.PrepareDefinesForFrameBoundValues(s, n, this, r, i, null, t.getRenderingMesh().hasThinInstances), this._eventInfo.defines = r, this._eventInfo.mesh = e, this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo), le.PrepareDefinesForAttributes(e, r, !0, !0, !0), this._callbackPluginEventPrepareDefines(this._eventInfo); let o = !1; if (r.isDirty) { const l = r._areLightsDisposed; r.markAsProcessed(); const h = new Vo; r.REFLECTION && h.addFallback(0, "REFLECTION"), r.SPECULAR && h.addFallback(0, "SPECULAR"), r.BUMP && h.addFallback(0, "BUMP"), r.PARALLAX && h.addFallback(1, "PARALLAX"), r.PARALLAX_RHS && h.addFallback(1, "PARALLAX_RHS"), r.PARALLAXOCCLUSION && h.addFallback(0, "PARALLAXOCCLUSION"), r.SPECULAROVERALPHA && h.addFallback(0, "SPECULAROVERALPHA"), r.FOG && h.addFallback(1, "FOG"), r.POINTSIZE && h.addFallback(0, "POINTSIZE"), r.LOGARITHMICDEPTH && h.addFallback(0, "LOGARITHMICDEPTH"), le.HandleFallbacksForShadows(r, h, this._maxSimultaneousLights), r.SPECULARTERM && h.addFallback(0, "SPECULARTERM"), r.DIFFUSEFRESNEL && h.addFallback(1, "DIFFUSEFRESNEL"), r.OPACITYFRESNEL && h.addFallback(2, "OPACITYFRESNEL"), r.REFLECTIONFRESNEL && h.addFallback(3, "REFLECTIONFRESNEL"), r.EMISSIVEFRESNEL && h.addFallback(4, "EMISSIVEFRESNEL"), r.FRESNEL && h.addFallback(4, "FRESNEL"), r.MULTIVIEW && h.addFallback(0, "MULTIVIEW"); const u = [d.PositionKind]; r.NORMAL && u.push(d.NormalKind), r.TANGENT && u.push(d.TangentKind); for (let y = 1; y <= 6; ++y)r["UV" + y] && u.push(`uv${y === 1 ? "" : y}`); r.VERTEXCOLOR && u.push(d.ColorKind), le.PrepareAttributesForBones(u, e, r, h), le.PrepareAttributesForInstances(u, r), le.PrepareAttributesForMorphTargets(u, e, r), le.PrepareAttributesForBakedVertexAnimation(u, e, r); let f = "default"; const _ = ["world", "view", "viewProjection", "vEyePosition", "vLightsType", "vAmbientColor", "vDiffuseColor", "vSpecularColor", "vEmissiveColor", "visibility", "vFogInfos", "vFogColor", "pointSize", "vDiffuseInfos", "vAmbientInfos", "vOpacityInfos", "vReflectionInfos", "vEmissiveInfos", "vSpecularInfos", "vBumpInfos", "vLightmapInfos", "vRefractionInfos", "mBones", "diffuseMatrix", "ambientMatrix", "opacityMatrix", "reflectionMatrix", "emissiveMatrix", "specularMatrix", "bumpMatrix", "normalMatrix", "lightmapMatrix", "refractionMatrix", "diffuseLeftColor", "diffuseRightColor", "opacityParts", "reflectionLeftColor", "reflectionRightColor", "emissiveLeftColor", "emissiveRightColor", "refractionLeftColor", "refractionRightColor", "vReflectionPosition", "vReflectionSize", "vRefractionPosition", "vRefractionSize", "logarithmicDepthConstant", "vTangentSpaceParams", "alphaCutOff", "boneTextureWidth", "morphTargetTextureInfo", "morphTargetTextureIndices"], p = ["diffuseSampler", "ambientSampler", "opacitySampler", "reflectionCubeSampler", "reflection2DSampler", "emissiveSampler", "specularSampler", "bumpSampler", "lightmapSampler", "refractionCubeSampler", "refraction2DSampler", "boneSampler", "morphTargets", "oitDepthSampler", "oitFrontColorSampler"], v = ["Material", "Scene", "Mesh"], E = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: r.NUM_MORPH_INFLUENCERS }; this._eventInfo.fallbacks = h, this._eventInfo.fallbackRank = 0, this._eventInfo.defines = r, this._eventInfo.uniforms = _, this._eventInfo.attributes = u, this._eventInfo.samplers = p, this._eventInfo.uniformBuffersNames = v, this._eventInfo.customCode = void 0, this._eventInfo.mesh = e, this._eventInfo.indexParameters = E, this._callbackPluginEventGeneric(Ue.PrepareEffect, this._eventInfo), Ks.AddUniforms(_), oe && (oe.PrepareUniforms(_, r), oe.PrepareSamplers(p, r)), le.PrepareUniformsAndSamplersList({ uniformsNames: _, uniformBuffersNames: v, samplers: p, defines: r, maxSimultaneousLights: this._maxSimultaneousLights }), cn(_); const m = {}; this.customShaderNameResolve && (f = this.customShaderNameResolve(f, _, v, p, r, u, m)); const x = r.toString(), C = t.effect; let S = s.getEngine().createEffect(f, { attributes: u, uniformsNames: _, uniformBuffersNames: v, samplers: p, defines: x, fallbacks: h, onCompiled: this.onCompiled, onError: this.onError, indexParameters: E, processFinalCode: m.processFinalCode, processCodeAfterIncludes: this._eventInfo.customCode, multiTarget: r.PREPASS }, n); if (this._eventInfo.customCode = void 0, S) if (this._onEffectCreatedObservable && ($i.effect = S, $i.subMesh = t, this._onEffectCreatedObservable.notifyObservers($i)), this.allowShaderHotSwapping && C && !S.isReady()) { if (S = C, r.markAsUnprocessed(), o = this.isFrozen, l) return r._areLightsDisposed = !0, !1 } else s.resetCachedMaterial(), t.setEffect(S, r, this._materialContext) } return !t.effect || !t.effect.isReady() ? !1 : (r._renderId = s.getRenderId(), t.effect._wasPreviouslyReady = !o, t.effect._wasPreviouslyUsingInstances = i, this._checkScenePerformancePriority(), !0) } buildUniformLayout() { const e = this._uniformBuffer; e.addUniform("diffuseLeftColor", 4), e.addUniform("diffuseRightColor", 4), e.addUniform("opacityParts", 4), e.addUniform("reflectionLeftColor", 4), e.addUniform("reflectionRightColor", 4), e.addUniform("refractionLeftColor", 4), e.addUniform("refractionRightColor", 4), e.addUniform("emissiveLeftColor", 4), e.addUniform("emissiveRightColor", 4), e.addUniform("vDiffuseInfos", 2), e.addUniform("vAmbientInfos", 2), e.addUniform("vOpacityInfos", 2), e.addUniform("vReflectionInfos", 2), e.addUniform("vReflectionPosition", 3), e.addUniform("vReflectionSize", 3), e.addUniform("vEmissiveInfos", 2), e.addUniform("vLightmapInfos", 2), e.addUniform("vSpecularInfos", 2), e.addUniform("vBumpInfos", 3), e.addUniform("diffuseMatrix", 16), e.addUniform("ambientMatrix", 16), e.addUniform("opacityMatrix", 16), e.addUniform("reflectionMatrix", 16), e.addUniform("emissiveMatrix", 16), e.addUniform("lightmapMatrix", 16), e.addUniform("specularMatrix", 16), e.addUniform("bumpMatrix", 16), e.addUniform("vTangentSpaceParams", 2), e.addUniform("pointSize", 1), e.addUniform("alphaCutOff", 1), e.addUniform("refractionMatrix", 16), e.addUniform("vRefractionInfos", 4), e.addUniform("vRefractionPosition", 3), e.addUniform("vRefractionSize", 3), e.addUniform("vSpecularColor", 4), e.addUniform("vEmissiveColor", 3), e.addUniform("vDiffuseColor", 4), e.addUniform("vAmbientColor", 3), super.buildUniformLayout() } bindForSubMesh(e, t, i) { var s; const r = this.getScene(), n = i.materialDefines; if (!n) return; const a = i.effect; if (!a) return; this._activeEffect = a, t.getMeshUniformBuffer().bindToEffect(a, "Mesh"), t.transferToEffect(e), this._uniformBuffer.bindToEffect(a, "Material"), this.prePassConfiguration.bindForSubMesh(this._activeEffect, r, t, e, this.isFrozen), this._eventInfo.subMesh = i, this._callbackPluginEventHardBindForSubMesh(this._eventInfo), n.OBJECTSPACE_NORMALMAP && (e.toNormalMatrix(this._normalMatrix), this.bindOnlyNormalMatrix(this._normalMatrix)); const o = a._forceRebindOnNextCall || this._mustRebind(r, a, t.visibility); le.BindBonesParameters(t, a); const l = this._uniformBuffer; if (o) { if (this.bindViewProjection(a), !l.useUbo || !this.isFrozen || !l.isSync || a._forceRebindOnNextCall) { if (F.FresnelEnabled && n.FRESNEL && (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled && (l.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power), l.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias)), this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && l.updateColor4("opacityParts", new te(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power), this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled && (l.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power), l.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias)), this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled && (l.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power), l.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias)), this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (l.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power), l.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias))), r.texturesEnabled) { if (this._diffuseTexture && F.DiffuseTextureEnabled && (l.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level), le.BindTextureMatrix(this._diffuseTexture, l, "diffuse")), this._ambientTexture && F.AmbientTextureEnabled && (l.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level), le.BindTextureMatrix(this._ambientTexture, l, "ambient")), this._opacityTexture && F.OpacityTextureEnabled && (l.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level), le.BindTextureMatrix(this._opacityTexture, l, "opacity")), this._hasAlphaChannel() && l.updateFloat("alphaCutOff", this.alphaCutOff), this._reflectionTexture && F.ReflectionTextureEnabled && (l.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness), l.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix()), this._reflectionTexture.boundingBoxSize)) { const h = this._reflectionTexture; l.updateVector3("vReflectionPosition", h.boundingBoxPosition), l.updateVector3("vReflectionSize", h.boundingBoxSize) } if (this._emissiveTexture && F.EmissiveTextureEnabled && (l.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level), le.BindTextureMatrix(this._emissiveTexture, l, "emissive")), this._lightmapTexture && F.LightmapTextureEnabled && (l.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level), le.BindTextureMatrix(this._lightmapTexture, l, "lightmap")), this._specularTexture && F.SpecularTextureEnabled && (l.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level), le.BindTextureMatrix(this._specularTexture, l, "specular")), this._bumpTexture && r.getEngine().getCaps().standardDerivatives && F.BumpTextureEnabled && (l.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias), le.BindTextureMatrix(this._bumpTexture, l, "bump"), r._mirroredCameraPosition ? l.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1) : l.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1)), this._refractionTexture && F.RefractionTextureEnabled) { let h = 1; if (this._refractionTexture.isCube || (l.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix()), this._refractionTexture.depth && (h = this._refractionTexture.depth)), l.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, h, this.invertRefractionY ? -1 : 1), this._refractionTexture.boundingBoxSize) { const u = this._refractionTexture; l.updateVector3("vRefractionPosition", u.boundingBoxPosition), l.updateVector3("vRefractionSize", u.boundingBoxSize) } } } this.pointsCloud && l.updateFloat("pointSize", this.pointSize), n.SPECULARTERM && l.updateColor4("vSpecularColor", this.specularColor, this.specularPower), l.updateColor3("vEmissiveColor", F.EmissiveTextureEnabled ? this.emissiveColor : te.BlackReadOnly), l.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha), r.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor), l.updateColor3("vAmbientColor", this._globalAmbientColor) } r.texturesEnabled && (this._diffuseTexture && F.DiffuseTextureEnabled && a.setTexture("diffuseSampler", this._diffuseTexture), this._ambientTexture && F.AmbientTextureEnabled && a.setTexture("ambientSampler", this._ambientTexture), this._opacityTexture && F.OpacityTextureEnabled && a.setTexture("opacitySampler", this._opacityTexture), this._reflectionTexture && F.ReflectionTextureEnabled && (this._reflectionTexture.isCube ? a.setTexture("reflectionCubeSampler", this._reflectionTexture) : a.setTexture("reflection2DSampler", this._reflectionTexture)), this._emissiveTexture && F.EmissiveTextureEnabled && a.setTexture("emissiveSampler", this._emissiveTexture), this._lightmapTexture && F.LightmapTextureEnabled && a.setTexture("lightmapSampler", this._lightmapTexture), this._specularTexture && F.SpecularTextureEnabled && a.setTexture("specularSampler", this._specularTexture), this._bumpTexture && r.getEngine().getCaps().standardDerivatives && F.BumpTextureEnabled && a.setTexture("bumpSampler", this._bumpTexture), this._refractionTexture && F.RefractionTextureEnabled && (this._refractionTexture.isCube ? a.setTexture("refractionCubeSampler", this._refractionTexture) : a.setTexture("refraction2DSampler", this._refractionTexture))), this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(t) && this.getScene().depthPeelingRenderer.bind(a), this._eventInfo.subMesh = i, this._callbackPluginEventBindForSubMesh(this._eventInfo), fn(a, this, r), this.bindEyePosition(a) } else r.getEngine()._features.needToAlwaysBindUniformBuffers && (this._needToBindSceneUbo = !0); (o || !this.isFrozen) && (r.lightsEnabled && !this._disableLighting && le.BindLights(r, t, a, n, this._maxSimultaneousLights), (r.fogEnabled && t.applyFog && r.fogMode !== Le.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || t.receiveShadows || n.PREPASS) && this.bindView(a), le.BindFogParameters(r, t, a), n.NUM_MORPH_INFLUENCERS && le.BindMorphTargetParameters(t, a), n.BAKED_VERTEX_ANIMATION_TEXTURE && ((s = t.bakedVertexAnimationManager) === null || s === void 0 || s.bind(a, n.INSTANCES)), this.useLogarithmicDepth && le.BindLogDepth(n, a, r), this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess && this._imageProcessingConfiguration.bind(this._activeEffect)), this._afterBind(t, this._activeEffect), l.update() } getAnimatables() { const e = super.getAnimatables(); return this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0 && e.push(this._diffuseTexture), this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0 && e.push(this._ambientTexture), this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0 && e.push(this._opacityTexture), this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0 && e.push(this._reflectionTexture), this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0 && e.push(this._emissiveTexture), this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0 && e.push(this._specularTexture), this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0 && e.push(this._bumpTexture), this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0 && e.push(this._lightmapTexture), this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0 && e.push(this._refractionTexture), e } getActiveTextures() { const e = super.getActiveTextures(); return this._diffuseTexture && e.push(this._diffuseTexture), this._ambientTexture && e.push(this._ambientTexture), this._opacityTexture && e.push(this._opacityTexture), this._reflectionTexture && e.push(this._reflectionTexture), this._emissiveTexture && e.push(this._emissiveTexture), this._specularTexture && e.push(this._specularTexture), this._bumpTexture && e.push(this._bumpTexture), this._lightmapTexture && e.push(this._lightmapTexture), this._refractionTexture && e.push(this._refractionTexture), e } hasTexture(e) { return !!(super.hasTexture(e) || this._diffuseTexture === e || this._ambientTexture === e || this._opacityTexture === e || this._reflectionTexture === e || this._emissiveTexture === e || this._specularTexture === e || this._bumpTexture === e || this._lightmapTexture === e || this._refractionTexture === e) } dispose(e, t) { var i, s, r, n, a, o, l, h, u; t && ((i = this._diffuseTexture) === null || i === void 0 || i.dispose(), (s = this._ambientTexture) === null || s === void 0 || s.dispose(), (r = this._opacityTexture) === null || r === void 0 || r.dispose(), (n = this._reflectionTexture) === null || n === void 0 || n.dispose(), (a = this._emissiveTexture) === null || a === void 0 || a.dispose(), (o = this._specularTexture) === null || o === void 0 || o.dispose(), (l = this._bumpTexture) === null || l === void 0 || l.dispose(), (h = this._lightmapTexture) === null || h === void 0 || h.dispose(), (u = this._refractionTexture) === null || u === void 0 || u.dispose()), this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), super.dispose(e, t) } clone(e, t = !0, i = "") { const s = re.Clone(() => new F(e, this.getScene()), this, { cloneTexturesOnlyOnce: t }); return s.name = e, s.id = e, this.stencil.copyTo(s.stencil), this._clonePlugins(s, i), s } static Parse(e, t, i) { const s = re.Parse(() => new F(e.name, t), e, t, i); return e.stencil && s.stencil.parse(e.stencil, t, i), I._parsePlugins(e, s, t, i), s } static get DiffuseTextureEnabled() { return se.DiffuseTextureEnabled } static set DiffuseTextureEnabled(e) { se.DiffuseTextureEnabled = e } static get DetailTextureEnabled() { return se.DetailTextureEnabled } static set DetailTextureEnabled(e) { se.DetailTextureEnabled = e } static get AmbientTextureEnabled() { return se.AmbientTextureEnabled } static set AmbientTextureEnabled(e) { se.AmbientTextureEnabled = e } static get OpacityTextureEnabled() { return se.OpacityTextureEnabled } static set OpacityTextureEnabled(e) { se.OpacityTextureEnabled = e } static get ReflectionTextureEnabled() { return se.ReflectionTextureEnabled } static set ReflectionTextureEnabled(e) { se.ReflectionTextureEnabled = e } static get EmissiveTextureEnabled() { return se.EmissiveTextureEnabled } static set EmissiveTextureEnabled(e) { se.EmissiveTextureEnabled = e } static get SpecularTextureEnabled() { return se.SpecularTextureEnabled } static set SpecularTextureEnabled(e) { se.SpecularTextureEnabled = e } static get BumpTextureEnabled() { return se.BumpTextureEnabled } static set BumpTextureEnabled(e) { se.BumpTextureEnabled = e } static get LightmapTextureEnabled() { return se.LightmapTextureEnabled } static set LightmapTextureEnabled(e) { se.LightmapTextureEnabled = e } static get RefractionTextureEnabled() { return se.RefractionTextureEnabled } static set RefractionTextureEnabled(e) { se.RefractionTextureEnabled = e } static get ColorGradingTextureEnabled() { return se.ColorGradingTextureEnabled } static set ColorGradingTextureEnabled(e) { se.ColorGradingTextureEnabled = e } static get FresnelEnabled() { return se.FresnelEnabled } static set FresnelEnabled(e) { se.FresnelEnabled = e } } T([st("diffuseTexture")], F.prototype, "_diffuseTexture", void 0), T([ue("_markAllSubMeshesAsTexturesAndMiscDirty")], F.prototype, "diffuseTexture", void 0), T([st("ambientTexture")], F.prototype, "_ambientTexture", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "ambientTexture", void 0), T([st("opacityTexture")], F.prototype, "_opacityTexture", void 0), T([ue("_markAllSubMeshesAsTexturesAndMiscDirty")], F.prototype, "opacityTexture", void 0), T([st("reflectionTexture")], F.prototype, "_reflectionTexture", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "reflectionTexture", void 0), T([st("emissiveTexture")], F.prototype, "_emissiveTexture", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "emissiveTexture", void 0), T([st("specularTexture")], F.prototype, "_specularTexture", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "specularTexture", void 0), T([st("bumpTexture")], F.prototype, "_bumpTexture", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "bumpTexture", void 0), T([st("lightmapTexture")], F.prototype, "_lightmapTexture", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "lightmapTexture", void 0), T([st("refractionTexture")], F.prototype, "_refractionTexture", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "refractionTexture", void 0), T([_i("ambient")], F.prototype, "ambientColor", void 0), T([_i("diffuse")], F.prototype, "diffuseColor", void 0), T([_i("specular")], F.prototype, "specularColor", void 0), T([_i("emissive")], F.prototype, "emissiveColor", void 0), T([M()], F.prototype, "specularPower", void 0), T([M("useAlphaFromDiffuseTexture")], F.prototype, "_useAlphaFromDiffuseTexture", void 0), T([ue("_markAllSubMeshesAsTexturesAndMiscDirty")], F.prototype, "useAlphaFromDiffuseTexture", void 0), T([M("useEmissiveAsIllumination")], F.prototype, "_useEmissiveAsIllumination", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "useEmissiveAsIllumination", void 0), T([M("linkEmissiveWithDiffuse")], F.prototype, "_linkEmissiveWithDiffuse", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "linkEmissiveWithDiffuse", void 0), T([M("useSpecularOverAlpha")], F.prototype, "_useSpecularOverAlpha", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "useSpecularOverAlpha", void 0), T([M("useReflectionOverAlpha")], F.prototype, "_useReflectionOverAlpha", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "useReflectionOverAlpha", void 0), T([M("disableLighting")], F.prototype, "_disableLighting", void 0), T([ue("_markAllSubMeshesAsLightsDirty")], F.prototype, "disableLighting", void 0), T([M("useObjectSpaceNormalMap")], F.prototype, "_useObjectSpaceNormalMap", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "useObjectSpaceNormalMap", void 0), T([M("useParallax")], F.prototype, "_useParallax", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "useParallax", void 0), T([M("useParallaxOcclusion")], F.prototype, "_useParallaxOcclusion", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "useParallaxOcclusion", void 0), T([M()], F.prototype, "parallaxScaleBias", void 0), T([M("roughness")], F.prototype, "_roughness", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "roughness", void 0), T([M()], F.prototype, "indexOfRefraction", void 0), T([M()], F.prototype, "invertRefractionY", void 0), T([M()], F.prototype, "alphaCutOff", void 0), T([M("useLightmapAsShadowmap")], F.prototype, "_useLightmapAsShadowmap", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "useLightmapAsShadowmap", void 0), T([jt("diffuseFresnelParameters")], F.prototype, "_diffuseFresnelParameters", void 0), T([ue("_markAllSubMeshesAsFresnelDirty")], F.prototype, "diffuseFresnelParameters", void 0), T([jt("opacityFresnelParameters")], F.prototype, "_opacityFresnelParameters", void 0), T([ue("_markAllSubMeshesAsFresnelAndMiscDirty")], F.prototype, "opacityFresnelParameters", void 0), T([jt("reflectionFresnelParameters")], F.prototype, "_reflectionFresnelParameters", void 0), T([ue("_markAllSubMeshesAsFresnelDirty")], F.prototype, "reflectionFresnelParameters", void 0), T([jt("refractionFresnelParameters")], F.prototype, "_refractionFresnelParameters", void 0), T([ue("_markAllSubMeshesAsFresnelDirty")], F.prototype, "refractionFresnelParameters", void 0), T([jt("emissiveFresnelParameters")], F.prototype, "_emissiveFresnelParameters", void 0), T([ue("_markAllSubMeshesAsFresnelDirty")], F.prototype, "emissiveFresnelParameters", void 0), T([M("useReflectionFresnelFromSpecular")], F.prototype, "_useReflectionFresnelFromSpecular", void 0), T([ue("_markAllSubMeshesAsFresnelDirty")], F.prototype, "useReflectionFresnelFromSpecular", void 0), T([M("useGlossinessFromSpecularMapAlpha")], F.prototype, "_useGlossinessFromSpecularMapAlpha", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "useGlossinessFromSpecularMapAlpha", void 0), T([M("maxSimultaneousLights")], F.prototype, "_maxSimultaneousLights", void 0), T([ue("_markAllSubMeshesAsLightsDirty")], F.prototype, "maxSimultaneousLights", void 0), T([M("invertNormalMapX")], F.prototype, "_invertNormalMapX", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "invertNormalMapX", void 0), T([M("invertNormalMapY")], F.prototype, "_invertNormalMapY", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "invertNormalMapY", void 0), T([M("twoSidedLighting")], F.prototype, "_twoSidedLighting", void 0), T([ue("_markAllSubMeshesAsTexturesDirty")], F.prototype, "twoSidedLighting", void 0), T([M("applyDecalMapAfterDetailMap")], F.prototype, "_applyDecalMapAfterDetailMap", void 0), T([ue("_markAllSubMeshesAsMiscDirty")], F.prototype, "applyDecalMapAfterDetailMap", void 0), at("BABYLON.StandardMaterial", F), Le.DefaultMaterialFactory = c => new F("default material", c); let Ut = []; const li = new Map; let hi = [], et = null; const Ko = () => et, Yo = (c, e, t) => { if (vt(`In pointerEventsCapture.requestCapture - Pointer events capture requested for ${c}`), $o(c)) { vt(`In pointerEventsCapture.requestCapture - Capture request matched previous release request ${c}.  Cancelling capture request`); return } else c !== et && jo(c, e, t); et || Zs() }, js = c => { vt(`In pointerEventsCapture.requestRelease - Pointer events release requested for ${c}`), !c || c === et ? Zs() : Zo(c) ? li.delete(c) : (vt(`In pointerEventsCapture.requestRelease - Received release request ${c} but no matching capture request was received`), hi.includes(c) || hi.push(c)) }, qo = () => { js(et) }, jo = (c, e, t) => { vt(`In pointerEventsCapture.enqueueCaptureRequest - Enqueueing capture request for  ${c}`), Ut.includes(c) || (Ut.push(c), li.set(c, { capture: e, release: t })) }, Zo = c => { let e = !1; return Ut = Ut.filter(t => t !== c ? !0 : (e = !0, vt(`In pointerEventsCapture.cancelRequest - Canceling pointer events capture request ${c}`), !1)), e }, $o = c => { let e = !1; return hi = hi.filter(t => t !== c ? !0 : (e = !0, !1)), e }, Zs = () => { const c = el(); vt(`In pointerEventsCapture.transferPointerEventsOwnership - Transferrring pointer events from ${et} to ${c}`), Qo(), c && Jo(c) }, Qo = () => { var c; vt(`In pointerEventsCapture.doRelease - Releasing pointer events from ${et}`), et && ((c = li.get(et)) == null || c.release(), li.delete(et), et = null) }, Jo = c => { var e; c && ((e = li.get(c)) == null || e.capture()), et = c, vt(`In pointerEventsCapture.doCapture - Pointer events now captured by ${c}`) }, el = () => Ut.length > 0 ? Ut.shift() : null, vt = c => { (typeof window > "u" || window["pointer-events-capture-debug"]) && console.log(`${performance.now()} - game.scene.pointerEvents - ${c} `, `currentOwner: ${et}`, `queue: ${Ut}`, `unmatched: ${hi}`) }; let Ct = null, ci = 0; const Ci = new WeakMap, $s = c => { typeof document > "u" || (ci === 0 && (document.addEventListener("pointermove", er), Ct = Ct ?? c, O.Log("PointerEventsCaptureBehavior: Starting observation of pointer move events."), Ct.onDisposeObservable.add(Qs)), ci++) }, Qs = () => { document.removeEventListener("pointermove", er), Ct = null, O.Log("PointerEventsCaptureBehavior: Stopping observation of pointer move events."), ci = 0 }, Js = () => { typeof document > "u" || Ct && (ci--, ci <= 0 && Qs()) }, er = c => { var o; if (!Ct) return; const e = Gr(Ct); if (!e) return; const t = c.clientX - e.left, i = c.clientY - e.top; let s; const r = Ct.pick(t, i, l => (s = Ci.get(l)) !== void 0); let n; r.hit ? n = r.pickedMesh : n = null; const a = parseInt(Ko() || ""); n && n.uniqueId === a || (a && (!n || n.uniqueId !== a) && qo(), n && ((o = s ?? Ci.get(n)) == null || o.capturePointerEvents())) }; class tr { constructor(e, t, { captureOnPointerEnter: i = !0 } = {}) { _e(this, "name", "PointerEventsCaptureBehavior"); _e(this, "attachedMesh"); _e(this, "_captureOnPointerEnter"); this.captureCallback = e, this.releaseCallback = t, this.attachedMesh = null, this._captureOnPointerEnter = i, typeof document > "u" && O.Warn("Creating an instance of PointerEventsCaptureBehavior outside of a browser.  The behavior will not work.") } set captureOnPointerEnter(e) { this._captureOnPointerEnter !== e && (this._captureOnPointerEnter = e, this.attachedMesh && (this._captureOnPointerEnter ? $s(this.attachedMesh.getScene()) : Js())) } init() { } attach(e) { this.attachedMesh = e, Ci.set(e, this), this._captureOnPointerEnter && $s(e.getScene()) } detach() { this.attachedMesh && (Ci.delete(this.attachedMesh), this.captureOnPointerEnter && Js(), this.attachedMesh = null) } dispose() { this.detach() } releasePointerEvents() { this.attachedMesh && js(this.attachedMesh.uniqueId.toString()) } capturePointerEvents() { this.attachedMesh && Yo(this.attachedMesh.uniqueId.toString(), this.captureCallback, this.releaseCallback) } } class tl extends ie { constructor(t, i, { captureOnPointerEnter: s = !0, top: r = !1 } = {}) { var n; super(i, t); _e(this, "isHtmlMesh", !0); _e(this, "top", !1); _e(this, "_requiresUpdate", !0); _e(this, "_element"); _e(this, "_width"); _e(this, "_height"); _e(this, "_wrapElement"); _e(this, "_inverseScaleMatrix", null); _e(this, "_captureOnPointerEnter", !0); _e(this, "_pointerEventCaptureBehavior", null); if (typeof document > "u") { O.Warn(`Creating an instance of an HtmlMesh with id ${i} outside of a browser.  The mesh will not be visible.`); return } this.top = r, this.createMask(), this._element = this.createElement(), this._wrapElement = this.createWrapElement(), (n = this._element) == null || n.appendChild(this._wrapElement), this.setEnabled(!1), this._captureOnPointerEnter = s, this._pointerEventCaptureBehavior = new tr(this.capturePointerEvents.bind(this), this.releasePointerEvents.bind(this), { captureOnPointerEnter: this._captureOnPointerEnter }), this.addBehavior(this._pointerEventCaptureBehavior) } get element() { return this._element } get requiresUpdate() { const t = this._requiresUpdate; return this._requiresUpdate = !1, t } set captureOnPointerEnter(t) { this._captureOnPointerEnter = t, this._pointerEventCaptureBehavior && (this._pointerEventCaptureBehavior.captureOnPointerEnter = t) } dispose() { var t; super.dispose(), (t = document.querySelector(`#${this.id}`)) == null || t.remove(), this._element = void 0, this._pointerEventCaptureBehavior && (this._pointerEventCaptureBehavior.dispose(), this._pointerEventCaptureBehavior = null) } setContent(t, i, s) { !this._element || !this._wrapElement || (this._wrapElement.innerHTML = "", this._width = i, this._height = s, this._requiresUpdate = !0, this.scaling.setAll(1), t ? (this._wrapElement.appendChild(t), this.updateScaleIfNecessary(), this.setEnabled(!0)) : this.setEnabled(!1), this.setElementZIndex(this.position.z * -1e4)) } setEnabled(t) { this._element && (this._element.style.display = t ? "" : "none", this.setElementZIndex(this.position.z * -1e4), super.setEnabled(t)) } setContentSizePx(t, i) { if (!this._element || !this._wrapElement) return; const s = this._wrapElement.firstElementChild; s.style.transform = "none"; const [r, n] = [s.offsetWidth, s.offsetHeight]; if (s) { this._wrapElement.style.width = `${t}px`, this._wrapElement.style.height = `${i}px`; const a = `scale(${Math.min(t / r, i / n)})`; console.log(a), s.style.transform = a } } updateScaleIfNecessary() { this.scaling.setAll(1), this._inverseScaleMatrix && (this.bakeTransformIntoVertices(this._inverseScaleMatrix), this._inverseScaleMatrix = null); const t = this._width || 1, i = this._height || 1, s = A.Scaling(t, i, 1); this.bakeTransformIntoVertices(s), this._inverseScaleMatrix = new A, s.invertToRef(this._inverseScaleMatrix) } createMask() { ji({ width: 1, height: 1 }).applyToMesh(this); const i = this.getScene(); this.checkCollisions = !0; const s = new F(`${this.id}-mat`, i); s.backFaceCulling = !1, s.disableColorWrite = !0, s.disableLighting = !0, this.top && (s.alpha = 0), this.material = s, this.material.freeze() } setElementZIndex(t) { this._element && (this._element.style.zIndex = `${t}`) } capturePointerEvents() { this._element && (this._element.style.pointerEvents = "auto", document.getElementsByTagName("body")[0].style.pointerEvents = "none") } releasePointerEvents() { this._element && (document.getElementsByTagName("body")[0].style.pointerEvents = "auto", this._element.style.pointerEvents = "none") } createElement() { if (typeof document > "u") return; const t = document.createElement("div"); return t.id = this.id, t.style.backgroundColor = this.top ? "transparent" : "#000", t.style.zIndex = "1", t.style.position = "absolute", t.style.pointerEvents = "auto", t.style.backfaceVisibility = "hidden", t } createWrapElement() { if (typeof document > "u") return; const t = document.createElement("div"); t.style.display = "flex", t.style.flexDirection = "column", t.style.alignItems = "center", t.style.justifyContent = "center"; const i = document.createElement("div"); return t.appendChild(i), t } } Xe.HtmlMesh = tl, Xe.HtmlMeshRenderer = zr, Xe.PointerEventsCaptureBehavior = tr, Object.defineProperty(Xe, Symbol.toStringTag, { value: "Module" })
});